"use strict";(self["webpackChunkbenefit"]=self["webpackChunkbenefit"]||[]).push([[6022],{50476:function(e,n,t){t.d(n,{v:function(){return i}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class i{constructor(e,n){this.variableNames=["x","segmentIds"];const t=e.windowSize,i=e.batchSize,r=e.inSize,o=e.numSegments,a=o*Math.ceil(r/t);this.outputShape=[i,a];const c="0.0",u="sumValue",l=4*Math.floor(t/4),s=t%4,p="\n        sumValue += dot(values, segFilter);\n    ";let x="";r%t>0&&(x=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `);let h="";r%t>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${c};\n\n      float getValue(int batch, int inIdx) {\n        ${x}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${o})) * float(${t}));\n        int currentSeg = int(mod(float(outIdx), float(${o})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${l}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${p}\n        }\n\n        int inIdx = inOffset + ${l};\n        if (${1===s}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${p}\n        } else if (${2===s}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${p}\n        } else if (${3===s}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${p}\n        }\n        setOutput(${u});\n      }\n    `}}},81847:function(e,n,t){t.d(n,{T:function(){return r}});var i=t(27575);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class r{constructor(e,n,t){let r,o;if(this.variableNames=["c","a","b"],this.outputShape=n,t>4)throw Error(`Where for rank ${t} is not yet supported`);if(1===t)o="resRC",r="resRC";else{const t=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],a=[];for(let r=0;r<n.length;r++)a.push(`${t[r]}`),r<e&&i.push(`${t[r]}`);r=i.join(),o=a.join()}const a=(0,i.bf)(t);this.userCode=`\n      void main() {\n        ${a} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${o}));\n        } else {\n          setOutput(getB(${o}));\n        }\n      }\n    `}}},27575:function(e,n,t){t.d(n,{YE:function(){return X},bf:function(){return W},yr:function(){return c}});var i=t(9495),r=t(18765),o=t(92394);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const{getBroadcastDims:a}=i.C0T;function c(e,n,t){const o=[];if(e.forEach((e=>{const n=i.ZSL.sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?o.push(`uniform float ${e.name}${n>1?`[${n}]`:""};`):(o.push(`uniform sampler2D ${e.name};`),o.push(`uniform int offset${e.name};`)),t.enableShapeUniforms){const{uniformShape:n}=X(t.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(n.length){case 1:o.push(`uniform int ${e.name}Shape;`);break;case 2:o.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:o.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:o.push(`uniform ivec4 ${e.name}Shape;`);break;default:break}o.push(`uniform ivec2 ${e.name}TexShape;`)}})),t.enableShapeUniforms){switch(n.logicalShape.length){case 1:o.push("uniform int outShape;");break;case 2:o.push("uniform ivec2 outShape;"),o.push("uniform int outShapeStrides;");break;case 3:o.push("uniform ivec3 outShape;"),o.push("uniform ivec2 outShapeStrides;");break;case 4:o.push("uniform ivec4 outShape;"),o.push("uniform ivec3 outShapeStrides;");break;default:break}o.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach((e=>{o.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));const a=o.join("\n"),c=e.map((e=>s(e,n,t.packedInputs,t.enableShapeUniforms))).join("\n"),u=n.texShape,l=(0,r.B)(),f=h(l);let S,g,C=v(l);n.isPacked?(S=p(n.logicalShape,u,t.enableShapeUniforms),g=$(l)):(S=x(n.logicalShape,u,t.enableShapeUniforms),g=d(l)),t.packedInputs&&(C+=m);const T=[C,f,g,a,S,c,t.userCode].join("\n");return T}function u(e,n=!1){const t=e.shapeInfo.logicalShape;switch(t.length){case 0:return L(e,n);case 1:return D(e,n);case 2:return z(e,n);case 3:return E(e,n);case 4:return j(e,n);case 5:return q(e);case 6:return P(e);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function l(e,n){const t=e.shapeInfo.logicalShape;switch(t.length){case 0:return F(e);case 1:return N(e,n);case 2:return M(e,n);case 3:return B(e,n);default:return Z(e,n)}}function s(e,n,t=!1,i){let r="";r+=t?l(e,i):u(e,i);const o=e.shapeInfo.logicalShape,a=n.logicalShape;return o.length<=a.length&&(r+=t?_(e,n):H(e,n)),r}function p(e,n,t){switch(e.length){case 0:return C();case 1:return T(e,n,t);case 2:return k(e,n,t);case 3:return I(e,n,t);default:return y(e,n,t)}}function x(e,n,t){switch(e.length){case 0:return C();case 1:return R(e,n,t);case 2:return O(e,n,t);case 3:return w(e,n,t);case 4:return V(e,n,t);case 5:return U(e,n);case 6:return b(e,n);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function h(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}function d(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}function $(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}function v(e){const n=`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${f}\n    ${S}\n    ${g}\n  `;return n}const f="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",S="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",g="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",m="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function C(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function T(e,n,t){const i=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];return 1===i[0]?t?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${i[1]}.0);\n      }\n    `:1===i[1]?t?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${i[0]}.0);\n      }\n    `:t?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${i[0]}, ${i[1]}));\n      return 2 * (resTexRC.x * ${i[1]} + resTexRC.y);\n    }\n  `}function R(e,n,t){return 1===n[0]?t?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?t?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `:t?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `}function I(e,n,t){if(t)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const i=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],r=Math.ceil(e[2]/2),o=r*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${i[0]}, ${i[1]}));\n      int index = resTexRC.x * ${i[1]} + resTexRC.y;\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}function w(e,n,t){if(t){const n=o.WA(["r","c","d"],e);return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${n}\n    return ivec3(r, c, d);\n  }\n`}const i=o.UG(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${i}\n      return ivec3(r, c, d);\n    }\n  `}function y(e,n,t){if(t)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const i=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],r=Math.ceil(e[e.length-1]/2),o=r*Math.ceil(e[e.length-2]/2);let a=o,c="",u="b, r, c";for(let l=2;l<e.length-1;l++)a*=e[e.length-l-1],c=`\n      int b${l} = index / ${a};\n      index -= b${l} * ${a};\n    `+c,u=`b${l}, `+u;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${i[0]}, ${i[1]}));\n      int index = resTexRC.x * ${i[1]} + resTexRC.y;\n\n      ${c}\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${e.length}(${u});\n    }\n  `}function V(e,n,t){if(t){const n=o.WA(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${n}\n      return ivec4(r, c, d, d2);\n    }\n  `}const i=o.UG(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${i}\n      return ivec4(r, c, d, d2);\n    }\n  `}function U(e,n){const t=o.UG(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${n[0]},\n                             ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${t}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}function b(e,n){const t=o.UG(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${t}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}function k(e,n,t){const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];if(i.ZSL.arraysEqual(e,n))return t?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const o=Math.ceil(e[1]/2);return t?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${o});\n      int c = imod(index, ${o}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}function O(e,n,t){return i.ZSL.arraysEqual(e,n)?t?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `:1===e[1]?t?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?t?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:t?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}function A(e){return`offset${e}`}function F(e){const n=e.name,t="get"+n.charAt(0).toUpperCase()+n.slice(1),i=(0,r.B)();return`\n    vec4 ${t}() {\n      return ${i.texture2D}(${n}, halfCR);\n    }\n  `}function L(e,n){const t=e.name,i="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`float ${i}() {return ${t};}`;const[r,o]=e.shapeInfo.texShape;if(1===r&&1===o)return`\n      float ${i}() {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const a=A(t);if(n)return`\n    float ${i}() {\n      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${a});\n      return sampleTexture(${t}, uv);\n    }\n  `;const[c,u]=e.shapeInfo.texShape;return`\n    float ${i}() {\n      vec2 uv = uvFromFlat(${c}, ${u}, ${a});\n      return sampleTexture(${t}, uv);\n    }\n  `}function N(e,n){const t=e.name,i="get"+t.charAt(0).toUpperCase()+t.slice(1),o=e.shapeInfo.texShape,a=(0,r.B)();if(n)return`\n    vec4 ${i}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${a.texture2D}(${t}, uv);\n    }\n  `;const c=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`\n    vec4 ${i}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${c[0]}, ${c[1]}, index);\n      return ${a.texture2D}(${t}, uv);\n    }\n  `}function D(e,n){const t=e.name,i="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${i}(int index) {\n        ${G(e)}\n      }\n    `;const r=e.shapeInfo.texShape,o=r[0],a=r[1];if(1===a&&1===o)return`\n      float ${i}(int index) {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const c=A(t);return 1===a?n?`\n      float ${i}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${c}) + 0.5) / float(${t}TexShape[0]));\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n      float ${i}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${c}) + 0.5) / ${o}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `:1===o?n?`\n      float ${i}(int index) {\n        vec2 uv = vec2((float(index + ${c}) + 0.5) / float(${t}TexShape[1]), 0.5);\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n      float ${i}(int index) {\n        vec2 uv = vec2((float(index + ${c}) + 0.5) / ${a}.0, 0.5);\n        return sampleTexture(${t}, uv);\n      }\n    `:n?`\n    float ${i}(int index) {\n      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${c});\n      return sampleTexture(${t}, uv);\n    }\n  `:`\n    float ${i}(int index) {\n      vec2 uv = uvFromFlat(${o}, ${a}, index + ${c});\n      return sampleTexture(${t}, uv);\n    }\n  `}function M(e,n){const t=e.shapeInfo.logicalShape,o=e.name,a="get"+o.charAt(0).toUpperCase()+o.slice(1),c=e.shapeInfo.texShape,u=c[0],l=c[1],s=(0,r.B)();if(null!=c&&i.ZSL.arraysEqual(t,c))return n?`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}TexShape[1], ${o}TexShape[0]);\n\n        return ${s.texture2D}(${o}, uv);\n      }\n    `:`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${u}.0);\n\n        return ${s.texture2D}(${o}, uv);\n      }\n    `;if(n)return`\n    vec4 ${a}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${o}TexShape[0]) / 2.0), ceil(float(${o}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${o}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${s.texture2D}(${o}, uv);\n    }\n  `;const p=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)],x=Math.ceil(t[1]/2);return`\n    vec4 ${a}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${x}, ${p[0]}, ${p[1]}, row, col);\n      return ${s.texture2D}(${o}, uv);\n    }\n  `}function z(e,n){const t=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape;if(null!=a&&i.ZSL.arraysEqual(t,a)){if(n)return`\n      float ${o}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;const e=a[0],t=a[1];return`\n    float ${o}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${t}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:c,keptDims:l}=i.ZSL.squeezeShape(t),s=c;if(s.length<t.length){const t=J(e,s),i=["row","col"];return`\n      ${u(t,n)}\n      float ${o}(int row, int col) {\n        return ${o}(${Y(i,l)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${o}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));\n        ${G(e)}\n      }\n    `;const p=a[0],x=a[1],h=A(r);return 1===x?n?`\n      float ${o}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${o}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${p}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===p?n?`\n      float ${o}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${o}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${x}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:n?`\n      float ${o}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${h};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${o}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${t[1]} + col + ${h};\n    vec2 uv = uvFromFlat(${p}, ${x}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}function B(e,n){const t=e.shapeInfo.logicalShape,i=e.name,o="get"+i.charAt(0).toUpperCase()+i.slice(1),a=e.shapeInfo.texShape,c=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(1===t[0]){const i=t.slice(1),r=[1,2],a=J(e,i),c=["b","row","col"];return`\n        ${l(a,n)}\n        vec4 ${o}(int b, int row, int col) {\n          return ${o}(${Y(c,r)});\n        }\n      `}const u=(0,r.B)();if(n)return`\n    vec4 ${o}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${i}TexShape[0]) / 2.0), ceil(float(${i}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${i}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${i}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${u.texture2D}(${i}, uv);\n    }\n  `;const s=c[0],p=c[1],x=Math.ceil(t[2]/2),h=x*Math.ceil(t[1]/2);return`\n    vec4 ${o}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${s}, ${p}, ${h}, ${x}, b, row, col);\n      return ${u.texture2D}(${i}, uv);\n    }\n  `}function E(e,n){const t=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),a=t[1]*t[2],c=t[2],{newShape:l,keptDims:s}=i.ZSL.squeezeShape(t),p=l;if(p.length<t.length){const t=J(e,p),i=["row","col","depth"];return`\n        ${u(t,n)}\n        float ${o}(int row, int col, int depth) {\n          return ${o}(${Y(i,s)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${o}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${a}, ${c}, 1)));\n        ${G(e)}\n      }\n    `;const x=e.shapeInfo.texShape,h=x[0],d=x[1],$=e.shapeInfo.flatOffset;if(d===a&&null==$)return n?`\n      float ${o}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${o}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${c}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${d}.0, ${h}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(d===c&&null==$)return n?`\n      float ${o}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${o}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const v=A(r);return n?`\n    float ${o}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${v};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${o}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${a} + col * ${c} + depth + ${v};\n        vec2 uv = uvFromFlat(${h}, ${d}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}function Z(e,n){const t=e.name,i="get"+t.charAt(0).toUpperCase()+t.slice(1),o=(0,r.B)();if(n)return`\n    vec4 ${i}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${t}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${t}, uv);\n    }\n  `;const a=e.shapeInfo.logicalShape,c=a.length,u=e.shapeInfo.texShape,l=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)],s=l[0],p=l[1],x=Math.ceil(a[c-1]/2);let h=x*Math.ceil(a[c-2]/2),d="int b, int row, int col",$=`b * ${h} + (row / 2) * ${x} + (col / 2)`;for(let r=2;r<c-1;r++)d=`int b${r}, `+d,h*=a[c-r-1],$=`b${r} * ${h} + `+$;return`\n    vec4 ${i}(${d}) {\n      int index = ${$};\n      int texR = index / ${p};\n      int texC = index - texR * ${p};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${s});\n      return ${o.texture2D}(${t}, uv);\n    }\n  `}function j(e,n){const t=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),a=t[3],c=t[2]*a,l=t[1]*c,{newShape:s,keptDims:p}=i.ZSL.squeezeShape(t);if(s.length<t.length){const t=J(e,s),i=["row","col","depth","depth2"];return`\n      ${u(t,n)}\n      float ${o}(int row, int col, int depth, int depth2) {\n        return ${o}(${Y(i,p)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${o}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${l}, ${c}, ${a}, 1)));\n        ${G(e)}\n      }\n    `;const x=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],$=h[1],v=`int stride2 = ${r}Shape[3];`,f=`int stride1 = ${r}Shape[2] * stride2;`,S=`int stride0 = ${r}Shape[1] * stride1;`;if($===l&&null==x)return n?`\n      float ${o}(int row, int col, int depth, int depth2) {\n        ${v}\n        ${f}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${c}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${$}.0, ${d}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if($===a&&null==x)return n?`\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${t[1]*t[2]}, ${t[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${$}.0, ${d}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const g=A(r);return n?`\n    float ${o}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${v}\n      ${f}\n      ${S}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${g});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${o}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${l} + col * ${c} +\n          depth * ${a} + depth2;\n      vec2 uv = uvFromFlat(${d}, ${$}, index + ${g});\n      return sampleTexture(${r}, uv);\n    }\n  `}function q(e){const n=e.shapeInfo.logicalShape,t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),o=n[4],a=n[3]*o,c=n[2]*a,l=n[1]*c,{newShape:s,keptDims:p}=i.ZSL.squeezeShape(n);if(s.length<n.length){const n=J(e,s),t=["row","col","depth","depth2","depth3"];return`\n      ${u(n)}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${Y(t,p)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${l}, ${c}, ${a}, ${o})) +\n          depth3;\n        ${G(e)}\n      }\n    `;const x=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],$=h[1];if($===l&&null==x)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${c}, ${a}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${$}.0, ${d}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `;if($===o&&null==x)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]},\n               ${n[2]*n[3]}, ${n[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${$}.0, ${d}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `;const v=A(t);return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${l} + col * ${c} + depth * ${a} +\n          depth2 * ${o} + depth3 + ${v};\n      vec2 uv = uvFromFlat(${d}, ${$}, index);\n      return sampleTexture(${t}, uv);\n    }\n  `}function P(e){const n=e.shapeInfo.logicalShape,t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:o,keptDims:a}=i.ZSL.squeezeShape(n);if(o.length<n.length){const n=J(e,o),t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${u(n)}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${Y(t,a)});\n      }\n    `}const c=n[5],l=n[4]*c,s=n[3]*l,p=n[2]*s,x=n[1]*p;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${x}, ${p}, ${s}, ${l})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${c}, 1)));\n        ${G(e)}\n      }\n    `;const h=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,$=d[0],v=d[1];if(v===x&&null==h)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${p}, ${s}, ${l}, ${c})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${v}.0, ${$}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `;if(v===c&&null==h)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]*n[4]},\n               ${n[2]*n[3]*n[4]},\n               ${n[3]*n[4]},\n               ${n[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${v}.0, ${$}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `;const f=A(t);return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${x} + col * ${p} + depth * ${s} +\n          depth2 * ${l} + depth3 * ${c} + depth4 + ${f};\n      vec2 uv = uvFromFlat(${$}, ${v}, index);\n      return sampleTexture(${t}, uv);\n    }\n  `}function G(e){const n=e.name,t=i.ZSL.sizeFromShape(e.shapeInfo.logicalShape);return t<2?`return ${n};`:`\n    for (int i = 0; i < ${t}; i++) {\n      if (i == index) {\n        return ${n}[i];\n      }\n    }\n  `}function _(e,n){const t=e.name,r=t.charAt(0).toUpperCase()+t.slice(1),o="get"+r+"AtOutCoords",c=e.shapeInfo.logicalShape.length,u=n.logicalShape.length,l=a(e.shapeInfo.logicalShape,n.logicalShape),s=W(u),p=u-c;let x;const h=["x","y","z","w","u","v"];x=0===c?"":u<2&&l.length>=1?"coords = 0;":l.map((e=>`coords.${h[e+p]} = 0;`)).join("\n");let d="";d=u<2&&c>0?"coords":e.shapeInfo.logicalShape.map(((e,n)=>`coords.${h[n+p]}`)).join(", ");let $="return outputValue;";const v=i.ZSL.sizeFromShape(e.shapeInfo.logicalShape),f=1===v,S=i.ZSL.sizeFromShape(n.logicalShape),g=1===S;if(1!==c||f||g){if(f&&!g)$=1===u?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(l.length){const e=c-2,n=c-1;l.indexOf(e)>-1&&l.indexOf(n)>-1?$="return vec4(outputValue.x);":l.indexOf(e)>-1?$="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":l.indexOf(n)>-1&&($="return vec4(outputValue.xx, outputValue.zz);")}}else $="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${o}() {\n      ${s} coords = getOutputCoords();\n      ${x}\n      vec4 outputValue = get${r}(${d});\n      ${$}\n    }\n  `}function H(e,n){const t=e.name,r=t.charAt(0).toUpperCase()+t.slice(1),o="get"+r+"AtOutCoords",c=n.texShape,u=e.shapeInfo.texShape,l=e.shapeInfo.logicalShape.length,s=n.logicalShape.length;if(!e.shapeInfo.isUniform&&l===s&&null==e.shapeInfo.flatOffset&&i.ZSL.arraysEqual(u,c))return`\n      float ${o}() {\n        return sampleTexture(${t}, resultUV);\n      }\n    `;const p=W(s),x=a(e.shapeInfo.logicalShape,n.logicalShape),h=s-l;let d;const $=["x","y","z","w","u","v"];d=0===l?"":s<2&&x.length>=1?"coords = 0;":x.map((e=>`coords.${$[e+h]} = 0;`)).join("\n");let v="";return v=s<2&&l>0?"coords":e.shapeInfo.logicalShape.map(((e,n)=>`coords.${$[n+h]}`)).join(", "),`\n    float ${o}() {\n      ${p} coords = getOutputCoords();\n      ${d}\n      return get${r}(${v});\n    }\n  `}function W(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function X(e,n,t){const{newShape:r,keptDims:o}=i.ZSL.squeezeShape(n),a=n.length,c=e&&3===a&&1===n[0],u=c?n.slice(1):r,l=!e&&a>1&&!i.ZSL.arraysEqual(n,t)&&r.length<a||c,s=l?u:n;return{useSqueezeShape:l,uniformShape:s,keptDims:o}}function J(e,n){const t=JSON.parse(JSON.stringify(e));return t.shapeInfo.logicalShape=n,t}function Y(e,n){return n.map((n=>e[n])).join(", ")}},92394:function(e,n,t){t.d(n,{G2:function(){return s},Od:function(){return l},TN:function(){return c},UG:function(){return r},WA:function(){return o},fM:function(){return u}});var i=t(9495);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r(e,n,t="index"){const r=i.ZSL.computeStrides(n);return r.map(((n,i)=>{const o=`int ${e[i]} = ${t} / ${n}`,a=i===r.length-1?`int ${e[i+1]} = ${t} - ${e[i]} * ${n}`:`index -= ${e[i]} * ${n}`;return`${o}; ${a};`})).join("")}function o(e,n,t="index"){const r=i.ZSL.computeStrides(n);return r.map(((n,i)=>{const o=`int ${e[i]} = ${t} / outShapeStrides[${i}]`,a=i===r.length-1?`int ${e[i+1]} = ${t} - ${e[i]} * outShapeStrides[${i}]`:`index -= ${e[i]} * outShapeStrides[${i}]`;return`${o}; ${a};`})).join("")}function a(e,n){const t=e.length,i=e.map((e=>`${n}[${e}]`)),r=new Array(t-1);r[t-2]=i[t-1];for(let o=t-3;o>=0;--o)r[o]=`(${r[o+1]} * ${i[o+1]})`;return r}function c(e,n,t="index"){const i=e.map(((e,n)=>n)),r=a(i,n);return r.map(((n,i)=>{const o=`int ${e[i]} = ${t} / ${r[i]}`,a=i===r.length-1?`int ${e[i+1]} = ${t} - ${e[i]} * ${r[i]}`:`index -= ${e[i]} * ${r[i]}`;return`${o}; ${a};`})).join("")}function u(e){const n=i.ZSL.computeStrides(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${n[0]} + coords.y * ${n[1]} + coords.z;\n  }\n`}function l(){return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n"}const s="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n"}}]);
//# sourceMappingURL=chunk-vendors-fee0d708.b4ff8c0c.js.map