{"version":3,"file":"js/chunk-vendors-629f752b.b11cc3e2.js","mappings":";;;;;;;;;;;;;;;;;AAiCA,SAASA,EAAOC,GACZ,MAAMC,GAAK,QAAgBD,EAAG,IAAK,SAC7BE,EAAS,CAAEF,EAAGC,GACpB,OAAO,KAAOE,UAAU,MAAOD,EACnC,CACO,MAAME,GAAwB,IAAAC,IAAG,CAAEN,U;;;;;;;;;;;;;;;;;ACLnC,SAASO,EAAOC,EAAOC,GAC1B,KAAM,IAAAC,cAAaF,IAAoB,WAAVC,GAAuBE,MAAMC,QAAQJ,KACpD,cAAVC,EACA,MAAM,IAAII,MAAM,kFAGpB,GAAc,WAAVJ,IAAsB,IAAAC,cAAaF,MACjCA,aAAiBM,YACnB,MAAM,IAAID,MAAM,6EAGpB,MAAME,EAAQ,GACRC,EAAgB,GACtB,OAAO,OAAWR,EAAOO,EAAOC,EAAeP,EACnD,C,wHCxCO,SAASQ,EAAoBF,EAAOG,EAASC,GAChD,MAAMC,EAAYF,EAAQG,KAAO,EAAKH,EAAQH,MAAMG,EAAQG,KAAO,GAAK,EAClEC,EAAYJ,EAAQG,KAAO,EAAKH,EAAQG,KAAO,EAAI,EACnDE,EACF,6FAAwCJ,EAAQJ,yBAC5BG,EAAQH,iBAAiBA,gBAC9BK,oBAA2BE,KAC9C,GAAIH,EAAQE,KAAOC,EACf,MAAM,IAAIT,MAAMU,EAAa,kBAAkBD,OAEnD,GAAIP,EAAMS,OAASJ,GAAYD,EAAQE,KAAOC,GAC1C,MAAM,IAAIT,MAAMU,EACZ,0BAA0BH,GAAYD,EAAQE,KAAOC,MAE7D,GAAIH,EAAQE,OAASC,EAAWP,EAAMS,OAASJ,EAC3C,MAAM,IAAIP,MAAMU,EAAa,oBAAmBD,EAAWP,EAAMS,OAASJ,IAE9E,IAAK,IAAIK,EAAI,EAAGA,EAAIH,IAAYG,EAC5B,GAAIN,EAAQJ,MAAMU,KAAOP,EAAQH,MAAMU,GACnC,MAAM,IAAIZ,MAAMU,EACZ,kBAAkBE,OAAON,EAAQJ,MAAMU,wBAAwBA,OAAOP,EAAQH,MAAMU,QAGhG,IAAK,IAAIA,EAAI,EAAGA,EAAIN,EAAQE,KAAOC,IAAYG,EAC3C,GAAIN,EAAQJ,MAAMU,EAAIH,KAAcP,EAAMU,EAAIL,GAC1C,MAAM,IAAIP,MAAMU,EACZ,kBAAkBE,EAAIH,OAAcH,EAAQJ,MAAMU,EAAIH,gBAAuBG,EAAIH,OAAcP,EAAMU,EAAIH,MAGzH,CAQO,SAASI,EAAcP,EAASD,EAASH,GAC5C,GAAIG,EAAQG,KAAO,EACf,MAAM,IAAIR,MACN,+EAAqBK,EAAQG,SAErC,GAAIF,EAAQE,KAAO,EACf,MAAM,IAAIR,MACN,+EAAqBM,EAAQE,SAErC,GAAsB,UAAlBH,EAAQT,MACR,MAAM,IAAII,MAAM,0DAA0DK,EAAQT,SAEtF,GAAIM,EAAMS,OAAS,EACf,MAAM,IAAIX,MAAM,6DAA6DE,KAEjF,GAAqB,IAAjBA,EAAMS,OAAc,CACpB,GAAqB,IAAjBN,EAAQS,KACR,MAAM,IAAId,MAAM,sDAAsDK,EAAQH,SAElF,GAAqB,IAAjBI,EAAQQ,KACR,MAAM,IAAId,MAAM,sDAAsDM,EAAQJ,QAEtF,CACAE,EAAoBF,EAAOG,EAASC,EACxC,CAUO,SAASS,EAAgBT,EAASD,EAASH,GAE9C,MAAMc,EAAcX,EAAQH,MAAMS,OAC5BM,EAAaD,EAAc,EAAKX,EAAQH,MAAMc,EAAc,GAAK,EAIjEE,EAAUhB,EAAMS,OACtB,IAAIQ,EAAY,EAChB,IAAK,IAAIC,EAAIH,EAAWG,EAAIF,IAAWE,EACnCD,GAAajB,EAAMkB,GAEvB,MAAMC,EAAgBJ,EAAY,EAAK,EAAIA,EACrCK,GAAa,QAAcjB,EAAQH,OAASmB,EAC5CE,EAAU,KAAI,QAAerB,EAAMsB,MAAM,EAAGP,IAAa,GACzDQ,GAAa,QAAcvB,GACjC,MAAO,CAAEe,YAAWK,aAAYH,YAAWI,UAASE,aACxD,C;;;;;;;;;;;;;;;;;AC7EO,SAASC,EAA8BC,EAAQC,GAClD,IACIC,EADAC,GAAO,EAEPH,GAAU,KACVE,EAAMF,EACNG,GAAO,GAGPD,GAAM,QAAeF,EAAQI,KAAKC,MAAMD,KAAKE,KAAKN,KAEtD,OAAQG,EACAD,EAAMD,GAAeC,IAAQF,EAC7BG,GAAO,EAGPD,GAAM,QAAeF,EAAQE,EAAM,GAG3C,OAAOA,CACX,CACO,SAASK,EAAgBC,EAAQC,EAAMR,GAC1C,MAAMS,EAAW,GACX7B,EAAO2B,EAAOxB,OACpB,IAAK,IAAI2B,EAAM,EAAGA,EAAM9B,EAAM8B,IACtBA,IAAQF,EACRC,EAASE,KAAKJ,EAAOG,IAGrBD,EAASE,KAAKX,GAGtB,OAAOS,CACX,CACO,SAASG,EAAyBpD,EAAGiB,EAAS+B,EAAMK,GACvD,MAAMzB,EAAcX,EAAQH,MAAMS,OAC5B+B,EAAQtD,EAAEc,MAAMS,OACtB,GAAkB,IAAd8B,IACIA,GAAazB,GAAeyB,EAAYzB,GACxC,MAAM,IAAIhB,MAAM,sCAAsCgB,MAAgBA,eAAyByB,KAMvG,GAHIA,EAAY,IACZA,GAAazB,GAEbyB,EAAYC,EACZ,MAAM,IAAI1C,MAAM,cAAcyC,uCAChCC,OAEF,GAAIN,EAAOK,EACP,MAAM,IAAIzC,MAAM,cAAcyC,0CAAkDL,OAEpF,IAAK,IAAIhB,EAAI,EAAGA,EAAIqB,IAAarB,EAC7B,GAAIhC,EAAEc,MAAMkB,KAAOf,EAAQH,MAAMkB,GAC7B,MAAM,IAAIpB,MAAM,WAAWoB,OAAOhC,EAAEc,MAAMkB,uCAAuCA,OAAOf,EAAQH,MAAMkB,OAG9G,MAAMuB,EAAUvD,EAAEc,MAAMkC,GAClBQ,EAAc,GACpB,IAAIC,EAAY,EACZC,EAAY,EACZ3B,EAAY,EAChB,IAAK,IAAIC,EAAI,EAAGA,EAAIqB,IAAarB,EAC7BwB,EAAYL,KAAKnD,EAAEc,MAAMkB,IACzByB,GAAazD,EAAEc,MAAMkB,GAEzB,IAAK,IAAIA,EAAIqB,EAAWrB,EAAIgB,EAAMhB,IAC9BwB,EAAYL,KAAKnD,EAAEc,MAAMkB,IACzB0B,GAAa1D,EAAEc,MAAMkB,GAEzB,IAAK,IAAIA,EAAIqB,EAAWrB,EAAIJ,EAAaI,IACrCwB,EAAYL,KAAKlC,EAAQH,MAAMkB,IAEnC,IAAK,IAAIA,EAAIgB,EAAO,EAAGhB,EAAIsB,EAAOtB,IAC9BwB,EAAYL,KAAKnD,EAAEc,MAAMkB,IACzBD,GAAa/B,EAAEc,MAAMkB,GAEzB,MAAO,CAAEyB,YAAW1B,YAAW2B,YAAWH,UAASC,cACvD,C;;;;;;;;;;;;;;;;;AC/EO,MAAMG,EAAkB,mBAClBC,EAAa,kB;;;;;;;;;;;;;;;;;ACe1B,SAASC,EAAS7D,GACd,MAAMC,GAAK,QAAgBD,EAAG,IAAK,UAAW,WACxCE,EAAS,CAAEF,EAAGC,GACpB,OAAO,KAAOE,UAAU,MAASD,EACrC,CACO,MAAM4D,GAA0B,IAAAzD,IAAG,CAAEwD,Y;;;;;;;;;;;;;;;;;ACC5C,SAASE,EAAOC,EAAQC,EAAaC,EAAWC,GAAS,EAAOC,EAAW,GACvE,IAAIC,EAAQ,EACZ,MAAMC,EAAS,GACf,MAAOD,EAAQJ,GAAeD,EAAOtC,KACjC4C,EAAOnB,MAAK,OAAMa,EAAQK,EAAOJ,IACjCI,GAASH,EAEb,GAAIC,EACA,MAAOE,EAAQL,EAAOtC,KAAM,CACxB,MAAM6C,EAAUF,EAAQJ,EAAeD,EAAOtC,KACxC8C,GAAM,OAAO,EACf,OAAMR,EAAQK,EAAOJ,EAAcM,IAAS,OAAK,CAACA,GAASH,KAE/DE,EAAOnB,KAAKqB,GACZH,GAASH,CACb,CAEJ,OAAsB,IAAlBI,EAAO/C,QACA,OAAS,GAAI,CAAC,EAAG0C,KAErB,QAAQ,OAAOK,GAAS,CAACA,EAAO/C,OAAQ0C,GACnD,CACO,MAAMQ,GAAwB,IAAApE,IAAG,CAAE0D,U;;;;;;;;;;;;;;;;;AC9B1C,SAASW,EAAeC,GACpB,OAAO,OAAaA,EAAc,IAAM,IAC5C,CACO,MAAMC,GAAgC,IAAAvE,IAAG,CAAEqE,kB;;;;;;;;;;;;;;;;;ACHlD,SAASG,EAAYF,GACjB,OAAO,OAAaA,EAAc,GAAK,GAC3C,CACO,MAAMG,GAA6B,IAAAzE,IAAG,CAAEwE,e;;;;;;;;;;;;;;;;;ACK/C,SAASE,EAAMf,EAAQC,EAAaC,EAAWc,EAAWC,EAAW,KAChD,MAAbD,IACAA,GAAY,OAAoBf,IAEpC,MAAMiB,GAAe,OAAMlB,EAAQC,EAAaC,GAC1CiB,GAAiB,OAAID,EAAcD,EAAShB,IAClD,OAAO,OAAKkB,EAAgBH,EAChC,CACO,MAAMI,GAAuB,IAAA/E,IAAG,CAAE0E,S;;;;;;;;;;;;;;;;GC7BlC,SAASM,EAAoB9E,GAEhC,OAAOoC,KAAKC,MAAMD,KAAK2C,IAAI,EAAG3C,KAAK4C,KAAK5C,KAAK6C,IAAIjF,GAASoC,KAAK6C,IAAI,KACvE,CACO,SAASC,EAAad,EAAce,EAAGC,GAC1C,MAAMC,EAAO,EAAIjB,EAAe,EAC1BkB,EAAY,IAAIC,aAAanB,GACnC,IAAK,IAAI3C,EAAI,EAAGA,EAAI2C,IAAgB3C,EAAG,CACnC,MAAM+D,EAAU,EAAMpD,KAAKqD,GAAKhE,GAAM2C,EAAeiB,EAAO,GAC5DC,EAAU7D,GAAK0D,EAAIC,EAAIhD,KAAKsD,IAAIF,EACpC,CACA,OAAO,IAAAG,GAASL,EAAW,UAC/B,C;;;;;;;;;;;;;;;;;ACyBA,SAASM,EAAOnG,EAAGoG,EAAO1E,GACtB,MAAMzB,GAAK,QAAgBD,EAAG,IAAK,QAAS,qBAC5C,GAAgB,IAAZC,EAAGmB,KACH,MAAM,IAAIR,MAAM,kCAEpB,MAAMV,EAAS,CAAEF,EAAGC,GACdoG,EAAQ,CAAED,QAAO1E,QACvB,OAAO,KAAOvB,UAAU,MAAOD,EAAQmG,EAC3C,CACO,MAAMjE,GAAwB,IAAA/B,IAAG,CAAE8F,U;;;;;;;;;;;;;;;;GC9C1C,MAAMG,GAAY,EACZC,GAAe,EACd,SAASC,EAAkBC,EAAOL,EAAO1E,GAC5C,MAAMgF,EAAYD,EAAM3F,MAAMS,OAC9B,KAAYmF,IAAcN,EAAM7E,QAAQ,IAAM,iBAAiBmF,uBAA+BN,uCAC1DM,QACpC,KAAYA,IAAchF,EAAKH,QAAQ,IAAM,iBAAiBmF,sBAA8BhF,uCACxDgF,QACpC,IAAK,IAAI1E,EAAI,EAAGA,EAAI0E,IAAa1E,EAC7B,KAAYoE,EAAMpE,GAAKN,EAAKM,IAAMyE,EAAM3F,MAAMkB,IAAI,IAAM,iBAAiB0E,aAAqB1E,aAAaA,OACnGoE,EAAMpE,GAAKN,EAAKM,kCAAkCA,OAAOyE,EAAM3F,MAAMkB,OAErF,CAEO,SAAS2E,EAAWC,GACvB,MAAMC,EAAO,GACb,IAAI7D,EAAO,EACX,MAAO4D,EAAO,EACC,EAAPA,GACAC,EAAK1D,KAAKH,GAEd4D,GAAQ,EACR5D,IAEJ,OAAO6D,CACX,CAEO,SAAS/D,EAAgBsD,EAAOU,EAAK3E,GACxC,MAAMT,EAAO,GACb,IAAK,IAAIsB,EAAO,EAAGA,EAAOoD,EAAM7E,OAAQyB,IACpCtB,EAAKsB,GAAQL,KAAK4C,MAAMuB,EAAI9D,GAAQoD,EAAMpD,IAASb,EAAQa,IAE/D,OAAOtB,CACX,CAGO,SAASqF,EAAsB5E,EAAS6E,EAAwBC,EAAeC,GAClF,MAAMC,EAAa,IAAIhF,GACvB,IAAK,IAAIH,EAAImF,EAAW5F,OAAQS,EAAIkF,EAAW3F,OAAQS,IACnDmF,EAAWhE,KAAK,GAEpB,IAAK,IAAInB,EAAI,EAAGA,EAAIiF,EAAejF,IACrB,IAANA,EACAmF,EAAWH,GAA0B,GAGrCG,EAAWC,OAAOJ,EAAwB,EAAgC,GAC1EG,EAAWE,OAGnB,OAAOF,CACX,CACA,SAASG,EAAgBN,EAAwBC,EAAeM,GAC5D,OAAIA,GAAkBP,EACXO,EAEJA,GAAkBN,EAAgB,EAC7C,CACA,SAASO,EAAcP,EAAeD,GAClC,MAAMS,EAAa,GACnB,IAAK,IAAIzF,EAAI,EAAGA,EAAIiF,EAAejF,IAC/ByF,EAAWtE,KAAK6D,EAAyBhF,GAE7C,OAAOyF,CACX,CAEO,SAASC,EAAkBR,EAAYS,EAAcC,EAAqBxB,EAAOU,EAAK3E,EAAS0F,EAAWC,EAASC,GACtH,MAAMrB,EAAYQ,EAAW3F,OAC7B,IAAIyG,EAAkB,IAAItH,MAAMgG,GAAYuB,EAAgB,IAAIvH,MAAMgG,GAAYwB,EAAoB,IAAIxH,MAAMgG,GAChH,GAAIiB,EAAapG,QAAUqG,EAAsB,EAAG,CAChD,MAAMO,EAAYR,EAAa,GAGzBV,EAAgBW,EAAsB,EAC5CI,EAAkBI,EAA2BP,EAAWM,EAAWlB,EAAeb,EAAOc,GACzFe,EAAgBI,EAA0BP,EAASK,EAAWlB,EAAeH,EAAKI,GAClFgB,EACInB,EAAsB5E,EAASgG,EAAWlB,EAAeC,EACjE,MAEI,IAAK,IAAIlE,EAAO,EAAGA,EAAO0D,EAAW1D,IACjCgF,EAAgBhF,GAAQsF,EAAaT,EAAWzB,EAAOjE,EAAS+E,EAAYlE,EAAM+E,GAClFE,EAAcjF,GACVuF,EAAYT,EAAShB,EAAK3E,EAAS+E,EAAYlE,EAAM+E,GACzDG,EAAkBlF,GAAQwF,EAAerG,EAASa,EAAM+E,GAGhE,MAAO,CACH3B,MAAO4B,EACPlB,IAAKmB,EACL9F,QAAS+F,EAEjB,CAGO,SAASE,EAA2BP,EAAWb,EAAwBC,EAAewB,EAAevB,GACxG,MAAMwB,EAAa,IAAIxB,GACjBO,EAAaD,EAAcP,EAAeD,GAChD,IAAK,IAAIhE,EAAO,EAAGA,EAAO0F,EAAWnH,OAAQyB,IACzC,GAAIyE,EAAWkB,QAAQ3F,IAAS,EAC5B0F,EAAW1F,GAAQ,MAElB,CACD,MAAM4F,EAAetB,EAAgBN,EAAwBC,EAAejE,GAC5E,IAAI6F,EAAgBJ,EAAcG,GAC9Bf,EAAY,GAAKe,IACjBC,EAAgB,GAEpBH,EAAW1F,GAAQ6F,CACvB,CAEJ,OAAOH,CACX,CAGO,SAASL,EAA0BP,EAASd,EAAwBC,EAAe6B,EAAa5B,GACnG,MAAMwB,EAAa,IAAIxB,GACjBO,EAAaD,EAAcP,EAAeD,GAChD,IAAK,IAAIhE,EAAO,EAAGA,EAAO0F,EAAWnH,OAAQyB,IACzC,GAAIyE,EAAWkB,QAAQ3F,IAAS,EAC5B0F,EAAW1F,GAAQ+F,OAAOC,qBAEzB,CACD,MAAMJ,EAAetB,EAAgBN,EAAwBC,EAAejE,GAC5E,IAAI6F,EAAgBC,EAAYF,GAC5Bd,EAAU,GAAKc,IACfC,EAAgBE,OAAOC,kBAE3BN,EAAW1F,GAAQ6F,CACvB,CAEJ,IAAK,IAAI7G,EAAI,EAAGA,EAAI0G,EAAWnH,OAAQS,IAAK,CAExC,MAAMiH,EAAW/B,EAAWlF,GACxB0G,EAAW1G,GAAK,IAChB0G,EAAW1G,IAAMiH,GAErBP,EAAW1G,GAAK,KAAW,EAAG0G,EAAW1G,GAAIkF,EAAWlF,GAC5D,CACA,OAAO0G,CACX,CACO,SAASF,EAAerG,EAASa,EAAM+E,GAC1C,IAAImB,EAAS/G,EAAQa,GAIrB,OAHI+E,EAAgB,GAAK/E,GAAmB,MAAVkG,KAC9BA,EAAS,GAENA,CACX,CACO,SAASZ,EAAaT,EAAWsB,EAAchH,EAAS+E,EAAYlE,EAAM+E,GAE7E,IAAI1D,EAAQ8E,EAAanG,GACzB,MAAMkG,EAAS/G,EAAQa,IAAS,GAG5B6E,EAAY,GAAK7E,GAAQ+E,EAAe,GAAK/E,GAAiB,MAATqB,KAKjDA,EAJA6E,EAAS,EAIDH,OAAOK,iBAIPL,OAAOC,kBAIvB,MAAMC,EAAW/B,EAAWlE,GAM5B,OALIqB,EAAQ,IACRA,GAAS4E,GAGb5E,EAAQ,KAAW,EAAGA,EAAO4E,EAAW,GACjC5E,CACX,CACO,SAASkE,EAAYT,EAASuB,EAAalH,EAAS+E,EAAYlE,EAAM+E,GAEzE,IAAIuB,EAAOD,EAAYrG,GACvB,MAAMkG,EAAS/G,EAAQa,IAAS,GAG5B8E,EAAW,GAAK9E,GAAS+E,EAAgB,GAAK/E,GAAiB,MAARsG,KAInDA,EAHAJ,EAAS,EAGFH,OAAOC,iBAIPD,OAAOK,kBAItB,MAAMH,EAAW/B,EAAWlE,GAe5B,OAdIsG,EAAO,IACPA,GAAQL,GAORK,EAFAJ,EAAS,EAEF,KAAW,EAAGI,EAAML,GAIpB,MAAY,EAAGK,EAAML,EAAW,GAEpCK,CACX,CAKO,SAASC,EAAiBzI,EAAOsF,EAAO1E,GAE3C,IAAI8H,EAAkB9H,EAAKH,OAC3B,IAAK,IAAIS,EAAI,EAAGA,EAAIN,EAAKH,OAAQS,IAC7B,GAAIN,EAAKM,GAAK,EAAG,CACbwH,EAAkBxH,EAClB,KACJ,CAEJ,IAAK,IAAIA,EAAIwH,EAAkB,EAAGxH,EAAIN,EAAKH,OAAQS,IAC/C,GAAIoE,EAAMpE,GAAK,GAAKN,EAAKM,KAAOlB,EAAMkB,GAClC,OAAO,EAGf,OAAO,CACX,CACO,SAASyH,EAAkBrD,EAAOjE,GACrC,IAAIuH,EAAatD,EAAM7E,OAAS,EAAI6E,EAAMA,EAAM7E,OAAS,GAAK,EAC9D,IAAK,IAAIS,EAAI,EAAGA,EAAIoE,EAAM7E,OAAS,EAAGS,IAClC0H,GAActD,EAAMpE,GAAKG,EAAQH,GAErC,OAAO0H,CACX,CACO,SAASC,EAAiB3J,EAAGoG,EAAO1E,GAEvC,IAAIkI,EACJ,MAAMtG,EAAQtD,EAAEc,MAAMS,OAatB,IAAIsI,EAuBJ,OAlCID,EADiB,kBAAVxD,EACE,CAACA,KAAU,IAAI1F,MAAM4C,EAAQ,GAAGwG,KAAK,IAEzC1D,EAAM7E,OAAS+B,EACX8C,EAAM2D,OAAO,IAAIrJ,MAAM4C,EAAQ8C,EAAM7E,QAAQuI,KAAK,IAGlD1D,EAAMhE,QAEnBwH,EAAOI,SAAQxI,IACX,MAAmB,IAAPA,GAAU,IAAM,qDAAoD,IAIhFqI,EADQ,MAARnI,EACQ,IAAIhB,MAAM4C,GAAOwG,MAAM,GAEV,kBAATpI,EACJ,CAACA,KAAS,IAAIhB,MAAM4C,EAAQ,GAAGwG,MAAM,IAExCpI,EAAKH,OAAS+B,EACX5B,EAAKqI,OAAO,IAAIrJ,MAAM4C,EAAQ5B,EAAKH,QAAQuI,MAAM,IAGjDpI,EAEZmI,EAAQA,EAAMI,KAAI,CAACzI,EAAGQ,IACdR,GAAK,EACEA,GAGP,MAAmB,IAAPA,GAAU,IAClB,qDAAGA,mCAAmCQ,OACnChC,EAAEc,MAAMkB,GAAK4H,EAAO5H,MAG5B,CAAC4H,EAAQC,EACpB,CAGO,SAASK,EAAUC,EAAQ/D,EAAOU,EAAK3E,EAAS0F,EAAWC,EAASC,EAAcqC,EAAaC,GAClG,IAAIC,EAaJ,GAZe,MAAXnI,GACAmI,EAAiB,IAAI5J,MAAM0F,EAAM7E,QACjC+I,EAAeR,KAAK,IAGpBQ,EAAiBnI,EAOD,MAAhB4F,GAAgE,KAAvCA,EAAgBA,EAAe,GACxD,MAAM,IAAInH,MAAM,8CAIpB,IAAI2J,GAAe,EACnB,MAAMC,EAAa,CACfC,KAAMH,EAAe/I,OACrBmJ,wBAAyB,EACzBtE,MAAOA,EAAMhE,QACb0E,IAAKA,EAAI1E,QACTD,QAASmI,EAAelI,QACxByF,YACAC,UACAC,eACAqC,cACAC,kBAEJ,IAAK,IAAIrI,EAAI,EAAGA,EAAIwI,EAAWC,KAAMzI,IAC7BuI,GAA6C,KAA3B,GAAKvI,EAAKoI,IAC5BI,EAAWE,0BAEV,GAAK1I,EAAK+F,IACXwC,GAAe,GAIlBA,IACDC,EAAWzC,cAAiB,GAAKyC,EAAWC,KAC5CD,EAAWC,QAWf,MAAME,EAAY,CACdF,KAAMN,EAAO5I,OACbsG,UAAW,EACXC,QAAS,EACT8C,YAAY,EACZC,UAAU,GAEdC,EAAeN,EAAYG,GAG3B,IAAII,GAAa,EACbC,GAAY,EACZC,GAAgB,EACpB,MAAMC,EAAkB,GAClBC,EAAa,GACnB,IAAK,IAAInJ,EAAI,EAAGA,EAAImI,EAAO5I,SAAUS,EAAG,CACpC,GAA6B,IAAzB2I,EAAUxI,QAAQH,GAClB,MAAMpB,MAAM,WAAWoB,uBAE3B,MAAMoJ,KAAaT,EAAUN,eAAkB,GAAKrI,GAC9CqJ,EAAOlB,EAAOnI,GACpB,IAAc,IAAVqJ,EAAa,CACbH,EAAgB/H,KAAKiI,EAAU,GAAK,GACpC,QACJ,CACA,MAAME,EAAQ,CAACX,EAAU9C,UAAa,GAAK7F,EAAI2I,EAAU7C,QAAW,GAAK9F,GACnEuJ,EAAa,CACfZ,EAAUxI,QAAQH,GAAK,EAAI,GAAK,EAChC2I,EAAUxI,QAAQH,GAAK,EAAIqJ,EAAOA,EAAO,GAE7C,GAAID,GAAWT,EAAUxI,QAAQH,IAAM,EACnC,MAAMpB,MAAM,gDAEhBqK,EAAgBA,GAA2C,IAAzBN,EAAUxI,QAAQH,GACpD,MAAMwJ,KAAwBb,EAAU9C,UAAa,GAAK7F,GAAQ2I,EAAU7C,QAAW,GAAK9F,GAC5F,GAAI2I,EAAUC,YAAcD,EAAUE,SAAU,CAC5C,GAAIO,EAAS,CAKT,MAAMK,EAAOd,EAAUvE,MAAMpE,GAAK,EAAIqJ,EAAOV,EAAUvE,MAAMpE,GACzD2I,EAAUvE,MAAMpE,GAGpB,GAFA2I,EAAUvE,MAAMpE,GAAKyJ,EACrBd,EAAU7D,IAAI9E,GAAK2I,EAAUvE,MAAMpE,GAAK,EACpCyJ,EAAO,GAAKA,GAAQJ,EACpB,MAAMzK,MAAM,eAAe+J,EAAUvE,MAAMpE,mBAAmBA,mBAEtE,MAEI2I,EAAUvE,MAAMpE,GAAK0J,EAAUf,EAAUvE,MAAMpE,GAAI,EAAG2I,EAAUxI,QAAQH,GAAIqJ,EAAMC,EAAOC,GACzFZ,EAAU7D,IAAI9E,GAAK0J,EAAUf,EAAU7D,IAAI9E,GAAI,EAAG2I,EAAUxI,QAAQH,GAAIqJ,EAAMC,EAAOC,GAGzF,MAAMI,EAA8C,IAAzBhB,EAAUxI,QAAQH,IAClB,IAAvB2I,EAAUvE,MAAMpE,IAAY2I,EAAU7D,IAAI9E,KAAOqJ,EACrDN,EAAaA,GAAcY,EAC3BX,EAAYA,IACA,IAANhJ,GAAoC,IAAzB2I,EAAUxI,QAAQH,IAAa2J,EACpD,MAEIZ,EACIA,GAAyC,IAAzBJ,EAAUxI,QAAQH,IAAawJ,EACnDR,EAAYA,IACA,IAANhJ,GAAoC,IAAzB2I,EAAUxI,QAAQH,IAAawJ,GAGpD,IAAII,EACAC,GAAgB,EAyBpB,GAxBIlB,EAAUC,YAAcD,EAAUE,UAClCe,EAAiBjB,EAAU7D,IAAI9E,GAAK2I,EAAUvE,MAAMpE,GACpD6J,GAAgB,GAEXT,GAGLQ,EAAiB,EACjBC,GAAgB,GAEXL,GAIDH,GAAQ,IAEJO,EADAjB,EAAUxI,QAAQH,GAAK,GACLqJ,EAGDA,EAErBQ,GAAgB,GAGpBA,EAAe,CACf,IAAIC,EAKAA,EAFmB,IAAnBF,GACEA,EAAiB,IAAQjB,EAAUxI,QAAQH,GAAK,EAC1C,EAGAW,KAAKoJ,MAAMH,EAAiBjB,EAAUxI,QAAQH,KACjD4J,EAAiBjB,EAAUxI,QAAQH,KAAO,EAAI,EAAI,GAE3DkJ,EAAgB/H,KAAK2I,EACzB,MAEIZ,EAAgB/H,MAAM,EAE9B,CAMA,IAAK,IAAI6I,EAAW,EAAGA,EAAWrB,EAAUsB,wBAAwB1K,SAAUyK,EAAU,CACpF,MAAME,EAAcvB,EAAUsB,wBAAwBD,GAClDE,GAAe,EACff,EAAWhI,KAAK+H,EAAgBgB,IAE3BA,IAAgB5F,GACrB6E,EAAWhI,KAAK,EAExB,CACA,MAAMgJ,EAAmBhB,EAAWiB,QAAO,CAAClJ,EAAKlB,IAAM2I,EAAUsB,wBAAwBjK,KAAOsE,IAChG,MAAO,CACH6F,mBACAhB,aACAJ,aACAC,YACAC,gBACA7E,MAAOuE,EAAUvE,MACjBU,IAAK6D,EAAU7D,IACf3E,QAASwI,EAAUxI,QAE3B,CACA,SAAS2I,EAAeuB,EAAQC,GAC5BA,EAAMzE,UAAY,EAClByE,EAAMxE,QAAU,EAChBwE,EAAMjC,eAAiB,EACvB,IAAIlC,EAAY,EAChBmE,EAAM1B,WAA6B,MAAhByB,EAAOjG,MAC1BkG,EAAMzB,SAAyB,MAAdwB,EAAOvF,IACxBwF,EAAMlG,MAAQ,IAAI1F,MAAM4L,EAAM7B,MAC9B6B,EAAMxF,IAAM,IAAIpG,MAAM4L,EAAM7B,MAC5B6B,EAAMnK,QAAU,IAAIzB,MAAM4L,EAAM7B,MAChC6B,EAAML,wBAA0B,GAChCK,EAAMC,8BAAgC,GACtCD,EAAME,8BAAgC,IAAI9L,MAAM4L,EAAM7B,MACtD,IAAK,IAAIzI,EAAI,EAAGA,EAAIqK,EAAO5B,KAAMzI,IAC7B,GAAK,GAAKA,EAAKqK,EAAOtE,aAAc,CAIhC,MAAM0E,EAAY9J,KAAK+J,IAAIJ,EAAM7B,MAAQ4B,EAAO5B,KAAOzI,GAAK,EAAIqK,EAAO3B,wBAAyB4B,EAAM7B,MACtG,KAAOtC,EAAYsE,EAAWtE,IAE1BmE,EAAMlG,MAAM+B,GAAa,EACzBmE,EAAMxF,IAAIqB,GAAa,EACvBmE,EAAMnK,QAAQgG,GAAa,EAC3BmE,EAAMzE,WAAc,GAAKM,EACzBmE,EAAMxE,SAAY,GAAKK,EACvBmE,EAAML,wBAAwB9I,KAAKgF,GACnCmE,EAAMC,8BAA8BpJ,MAAM,GAC1CmJ,EAAME,8BAA8BrE,GAAanG,CAEzD,MACK,GAAK,GAAKA,EAAKqK,EAAOjC,YAEvBkC,EAAML,wBAAwB9I,KAAKmD,GACnCgG,EAAMC,8BAA8BpJ,MAAM,OAEzC,CACD,GAAIgF,IAAcmE,EAAMlG,MAAM7E,OAC1B,MAAMX,MAAM,sCAAsCuH,qBAClCmE,EAAM7B,cAAc6B,EAAMlG,MAAM7E,WAGhC,MAAhB8K,EAAOjG,QACPkG,EAAMlG,MAAM+B,GAAakE,EAAOjG,MAAMpE,IAExB,MAAdqK,EAAOvF,MACPwF,EAAMxF,IAAIqB,GAAakE,EAAOvF,IAAI9E,IAEtCsK,EAAMnK,QAAQgG,GAAakE,EAAOlK,QAAQH,GACtCqK,EAAOxE,UAAa,GAAK7F,IACzBsK,EAAMzE,WAAc,GAAKM,GAEzBkE,EAAOvE,QAAW,GAAK9F,IACvBsK,EAAMxE,SAAY,GAAKK,GAKvBkE,EAAOhC,eAAkB,GAAKrI,GAC9BsK,EAAML,wBAAwB9I,KAAKoD,GACnC+F,EAAMC,8BAA8BpJ,MAAM,GAC1CmJ,EAAMjC,gBAAmB,GAAKlC,IAG9BmE,EAAML,wBAAwB9I,KAAKgF,GAEnCmE,EAAMC,8BAA8BpJ,KAAKnB,IAE7CsK,EAAME,8BAA8BrE,GAAanG,EACjDmG,GACJ,CAER,CACA,SAASuD,EAAU1L,EAAG2M,EAAGC,EAASvB,EAAMC,EAAOC,GAC3C,GAAID,EAAMqB,GACN,OAAOC,EAAU,EAAIrB,EAAWoB,GAAKpB,EAAYoB,EAAI,EAAK,GAEzD,CACD,MAAMlB,EAAOzL,EAAI,EAAIqL,EAAOrL,EAAIA,EAChC,OAAOyL,EAAOF,EAAW,GAAKA,EAAW,GACrCE,EAAOF,EAAW,GAAKA,EAAW,GAAKE,CAC/C,CACJ,C","sources":["webpack://benefit/./node_modules/@tensorflow/tfjs-core/dist/ops/round.js","webpack://benefit/./node_modules/@tensorflow/tfjs-core/dist/ops/scalar.js","webpack://benefit/./node_modules/@tensorflow/tfjs-core/dist/ops/scatter_nd_util.js","webpack://benefit/./node_modules/@tensorflow/tfjs-core/dist/ops/segment_util.js","webpack://benefit/./node_modules/@tensorflow/tfjs-core/dist/ops/selu_util.js","webpack://benefit/./node_modules/@tensorflow/tfjs-core/dist/ops/sigmoid.js","webpack://benefit/./node_modules/@tensorflow/tfjs-core/dist/ops/signal/frame.js","webpack://benefit/./node_modules/@tensorflow/tfjs-core/dist/ops/signal/hamming_window.js","webpack://benefit/./node_modules/@tensorflow/tfjs-core/dist/ops/signal/hann_window.js","webpack://benefit/./node_modules/@tensorflow/tfjs-core/dist/ops/signal/stft.js","webpack://benefit/./node_modules/@tensorflow/tfjs-core/dist/ops/signal_ops_util.js","webpack://benefit/./node_modules/@tensorflow/tfjs-core/dist/ops/slice.js","webpack://benefit/./node_modules/@tensorflow/tfjs-core/dist/ops/slice_util.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Round } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Computes round of input `tf.Tensor` element-wise: `round(x)`.\n * It implements banker's rounding.\n *\n * ```js\n * const x = tf.tensor1d([.6, 1.1, -3.3]);\n *\n * x.round().print();  // or tf.round(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction round_(x) {\n    const $x = convertToTensor(x, 'x', 'round');\n    const inputs = { x: $x };\n    return ENGINE.runKernel(Round, inputs);\n}\nexport const round = /* @__PURE__ */ op({ round_ });\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91bmQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWNvcmUvc3JjL29wcy9yb3VuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sV0FBVyxDQUFDO0FBQ2pDLE9BQU8sRUFBQyxLQUFLLEVBQWMsTUFBTSxpQkFBaUIsQ0FBQztBQUduRCxPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFHbkQsT0FBTyxFQUFDLEVBQUUsRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUUvQjs7Ozs7Ozs7Ozs7O0dBWUc7QUFDSCxTQUFTLE1BQU0sQ0FBbUIsQ0FBZTtJQUMvQyxNQUFNLEVBQUUsR0FBRyxlQUFlLENBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUM1QyxNQUFNLE1BQU0sR0FBZ0IsRUFBQyxDQUFDLEVBQUUsRUFBRSxFQUFDLENBQUM7SUFFcEMsT0FBTyxNQUFNLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxNQUFtQyxDQUFDLENBQUM7QUFDdEUsQ0FBQztBQUVELE1BQU0sQ0FBQyxNQUFNLEtBQUssR0FBRyxlQUFlLENBQUMsRUFBRSxDQUFDLEVBQUMsTUFBTSxFQUFDLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtFTkdJTkV9IGZyb20gJy4uL2VuZ2luZSc7XG5pbXBvcnQge1JvdW5kLCBSb3VuZElucHV0c30gZnJvbSAnLi4va2VybmVsX25hbWVzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi90ZW5zb3InO1xuaW1wb3J0IHtOYW1lZFRlbnNvck1hcH0gZnJvbSAnLi4vdGVuc29yX3R5cGVzJztcbmltcG9ydCB7Y29udmVydFRvVGVuc29yfSBmcm9tICcuLi90ZW5zb3JfdXRpbF9lbnYnO1xuaW1wb3J0IHtUZW5zb3JMaWtlfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7b3B9IGZyb20gJy4vb3BlcmF0aW9uJztcblxuLyoqXG4gKiBDb21wdXRlcyByb3VuZCBvZiBpbnB1dCBgdGYuVGVuc29yYCBlbGVtZW50LXdpc2U6IGByb3VuZCh4KWAuXG4gKiBJdCBpbXBsZW1lbnRzIGJhbmtlcidzIHJvdW5kaW5nLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCB4ID0gdGYudGVuc29yMWQoWy42LCAxLjEsIC0zLjNdKTtcbiAqXG4gKiB4LnJvdW5kKCkucHJpbnQoKTsgIC8vIG9yIHRmLnJvdW5kKHgpXG4gKiBgYGBcbiAqIEBwYXJhbSB4IFRoZSBpbnB1dCB0ZW5zb3IuXG4gKlxuICogQGRvYyB7aGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCd9XG4gKi9cbmZ1bmN0aW9uIHJvdW5kXzxUIGV4dGVuZHMgVGVuc29yPih4OiBUfFRlbnNvckxpa2UpOiBUIHtcbiAgY29uc3QgJHggPSBjb252ZXJ0VG9UZW5zb3IoeCwgJ3gnLCAncm91bmQnKTtcbiAgY29uc3QgaW5wdXRzOiBSb3VuZElucHV0cyA9IHt4OiAkeH07XG5cbiAgcmV0dXJuIEVOR0lORS5ydW5LZXJuZWwoUm91bmQsIGlucHV0cyBhcyB1bmtub3duIGFzIE5hbWVkVGVuc29yTWFwKTtcbn1cblxuZXhwb3J0IGNvbnN0IHJvdW5kID0gLyogQF9fUFVSRV9fICovIG9wKHtyb3VuZF99KTtcbiJdfQ==","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { isTypedArray } from '../util';\nimport { makeTensor } from './tensor_ops_util';\n/**\n * Creates rank-0 `tf.Tensor` (scalar) with the provided value and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.scalar` as it makes the code more readable.\n *\n * ```js\n * tf.scalar(3.14).print();\n * ```\n *\n * @param value The value of the scalar.\n * @param dtype The data type.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nexport function scalar(value, dtype) {\n    if (((isTypedArray(value) && dtype !== 'string') || Array.isArray(value)) &&\n        dtype !== 'complex64') {\n        throw new Error('Error creating a new Scalar: value must be a primitive ' +\n            '(number|boolean|string)');\n    }\n    if (dtype === 'string' && isTypedArray(value) &&\n        !(value instanceof Uint8Array)) {\n        throw new Error('When making a scalar from encoded string, ' +\n            'the value must be `Uint8Array`.');\n    }\n    const shape = [];\n    const inferredShape = [];\n    return makeTensor(value, shape, inferredShape, dtype);\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NhbGFyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1jb3JlL3NyYy9vcHMvc2NhbGFyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUlILE9BQU8sRUFBQyxZQUFZLEVBQUMsTUFBTSxTQUFTLENBQUM7QUFDckMsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLG1CQUFtQixDQUFDO0FBRTdDOzs7Ozs7Ozs7Ozs7OztHQWNHO0FBQ0gsTUFBTSxVQUFVLE1BQU0sQ0FDbEIsS0FBdUMsRUFBRSxLQUFnQjtJQUMzRCxJQUFJLENBQUMsQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxLQUFLLFFBQVEsQ0FBQyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDckUsS0FBSyxLQUFLLFdBQVcsRUFBRTtRQUN6QixNQUFNLElBQUksS0FBSyxDQUNYLHlEQUF5RDtZQUN6RCx5QkFBeUIsQ0FBQyxDQUFDO0tBQ2hDO0lBQ0QsSUFBSSxLQUFLLEtBQUssUUFBUSxJQUFJLFlBQVksQ0FBQyxLQUFLLENBQUM7UUFDekMsQ0FBQyxDQUFDLEtBQUssWUFBWSxVQUFVLENBQUMsRUFBRTtRQUNsQyxNQUFNLElBQUksS0FBSyxDQUNYLDRDQUE0QztZQUM1QyxpQ0FBaUMsQ0FBQyxDQUFDO0tBQ3hDO0lBQ0QsTUFBTSxLQUFLLEdBQWEsRUFBRSxDQUFDO0lBQzNCLE1BQU0sYUFBYSxHQUFhLEVBQUUsQ0FBQztJQUNuQyxPQUFPLFVBQVUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLGFBQWEsRUFBRSxLQUFLLENBQVcsQ0FBQztBQUNsRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge1NjYWxhcn0gZnJvbSAnLi4vdGVuc29yJztcbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7aXNUeXBlZEFycmF5fSBmcm9tICcuLi91dGlsJztcbmltcG9ydCB7bWFrZVRlbnNvcn0gZnJvbSAnLi90ZW5zb3Jfb3BzX3V0aWwnO1xuXG4vKipcbiAqIENyZWF0ZXMgcmFuay0wIGB0Zi5UZW5zb3JgIChzY2FsYXIpIHdpdGggdGhlIHByb3ZpZGVkIHZhbHVlIGFuZCBkdHlwZS5cbiAqXG4gKiBUaGUgc2FtZSBmdW5jdGlvbmFsaXR5IGNhbiBiZSBhY2hpZXZlZCB3aXRoIGB0Zi50ZW5zb3JgLCBidXQgaW4gZ2VuZXJhbFxuICogd2UgcmVjb21tZW5kIHVzaW5nIGB0Zi5zY2FsYXJgIGFzIGl0IG1ha2VzIHRoZSBjb2RlIG1vcmUgcmVhZGFibGUuXG4gKlxuICogYGBganNcbiAqIHRmLnNjYWxhcigzLjE0KS5wcmludCgpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgc2NhbGFyLlxuICogQHBhcmFtIGR0eXBlIFRoZSBkYXRhIHR5cGUuXG4gKlxuICogQGRvYyB7aGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGFyKFxuICAgIHZhbHVlOiBudW1iZXJ8Ym9vbGVhbnxzdHJpbmd8VWludDhBcnJheSwgZHR5cGU/OiBEYXRhVHlwZSk6IFNjYWxhciB7XG4gIGlmICgoKGlzVHlwZWRBcnJheSh2YWx1ZSkgJiYgZHR5cGUgIT09ICdzdHJpbmcnKSB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSkgJiZcbiAgICAgIGR0eXBlICE9PSAnY29tcGxleDY0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0Vycm9yIGNyZWF0aW5nIGEgbmV3IFNjYWxhcjogdmFsdWUgbXVzdCBiZSBhIHByaW1pdGl2ZSAnICtcbiAgICAgICAgJyhudW1iZXJ8Ym9vbGVhbnxzdHJpbmcpJyk7XG4gIH1cbiAgaWYgKGR0eXBlID09PSAnc3RyaW5nJyAmJiBpc1R5cGVkQXJyYXkodmFsdWUpICYmXG4gICAgICAhKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdXaGVuIG1ha2luZyBhIHNjYWxhciBmcm9tIGVuY29kZWQgc3RyaW5nLCAnICtcbiAgICAgICAgJ3RoZSB2YWx1ZSBtdXN0IGJlIGBVaW50OEFycmF5YC4nKTtcbiAgfVxuICBjb25zdCBzaGFwZTogbnVtYmVyW10gPSBbXTtcbiAgY29uc3QgaW5mZXJyZWRTaGFwZTogbnVtYmVyW10gPSBbXTtcbiAgcmV0dXJuIG1ha2VUZW5zb3IodmFsdWUsIHNoYXBlLCBpbmZlcnJlZFNoYXBlLCBkdHlwZSkgYXMgU2NhbGFyO1xufVxuIl19","import { computeStrides, sizeFromShape } from '../util';\n/**\n * Check whether updates.shape = indices.shape[:batchDim] +\n * shape[sliceDim:]\n *\n * @param x The input tensor.\n */\nexport function validateUpdateShape(shape, indices, updates) {\n    const sliceDim = (indices.rank > 1) ? indices.shape[indices.rank - 1] : 1;\n    const batchDim = (indices.rank > 1) ? indices.rank - 1 : 1;\n    const shapeError = 'Must have updates.shape = indices.shape[:batchDim] + ' +\n        `shape[sliceDim:], got updates.shape: ${updates.shape}` +\n        `, indices.shape: ${indices.shape}, shape: ${shape}` +\n        `, sliceDim: ${sliceDim}, and batchDim: ${batchDim}.`;\n    if (updates.rank < batchDim) {\n        throw new Error(shapeError + ` update.rank < ${batchDim}. `);\n    }\n    if (shape.length < sliceDim + (updates.rank - batchDim)) {\n        throw new Error(shapeError +\n            ` Output shape length < ${sliceDim + (updates.rank - batchDim)}`);\n    }\n    if (updates.rank !== batchDim + shape.length - sliceDim) {\n        throw new Error(shapeError + ` update.rank != ${batchDim + shape.length - sliceDim}`);\n    }\n    for (let d = 0; d < batchDim; ++d) {\n        if (updates.shape[d] !== indices.shape[d]) {\n            throw new Error(shapeError +\n                ` updates.shape[${d}] (${updates.shape[d]}) != indices.shape[${d}] (${indices.shape[d]}).`);\n        }\n    }\n    for (let d = 0; d < updates.rank - batchDim; ++d) {\n        if (updates.shape[d + batchDim] !== shape[d + sliceDim]) {\n            throw new Error(shapeError +\n                ` updates.shape[${d + batchDim}] (${updates.shape[d + batchDim]}) != shape[${d + batchDim}] (${shape[d + batchDim]})`);\n        }\n    }\n}\n/**\n * Validate scatter nd inputs.\n *\n * @param update The tensor contains the update values.\n * @param indices The tensor contains the indices for the update values.\n * @param shape The shape of the output tensor.\n */\nexport function validateInput(updates, indices, shape) {\n    if (indices.rank < 1) {\n        throw new Error('tf.scatterND() expects the indices to be rank 1 or higher,' +\n            ` but the rank was ${indices.rank}.`);\n    }\n    if (updates.rank < 1) {\n        throw new Error('tf.scatterND() expects the updates to be rank 1 or higher,' +\n            ` but the rank was ${updates.rank}.`);\n    }\n    if (indices.dtype !== 'int32') {\n        throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${indices.dtype}`);\n    }\n    if (shape.length < 1) {\n        throw new Error(`Output rank must be greater or equal to 1, but got shape: ${shape}`);\n    }\n    if (shape.length === 0) {\n        if (indices.size === 0) {\n            throw new Error(`Indices specified for empty output. indices shape: ${indices.shape}`);\n        }\n        if (updates.size === 0) {\n            throw new Error(`Updates specified for empty output. updates shape: ${updates.shape}`);\n        }\n    }\n    validateUpdateShape(shape, indices, updates);\n}\n/**\n * Calculate the shape information for the output.\n *\n * @param update The tensor contains the update values.\n * @param indices The tensor contains the indices for the update values.\n * @param shape The shape of the output tensor.\n *\n * @returns ScatterShapeInfo\n */\nexport function calculateShapes(updates, indices, shape) {\n    // Calculate the number of dimensions in indices\n    const indicesRank = indices.shape.length;\n    const sliceRank = (indicesRank > 1) ? indices.shape[indicesRank - 1] : 1;\n    // Calculate the number of elements that make up each slice of our updated\n    // tensor. This allows us to work with flattened tensors and copy over whole\n    // slices at a time.\n    const totalNd = shape.length;\n    let sliceSize = 1;\n    for (let i = sliceRank; i < totalNd; ++i) {\n        sliceSize *= shape[i];\n    }\n    const safeSliceDim = (sliceRank < 1) ? 1 : sliceRank;\n    const numUpdates = sizeFromShape(indices.shape) / safeSliceDim;\n    const strides = [...computeStrides(shape.slice(0, sliceRank)), 1];\n    const outputSize = sizeFromShape(shape);\n    return { sliceRank, numUpdates, sliceSize, strides, outputSize };\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NhdHRlcl9uZF91dGlsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1jb3JlL3NyYy9vcHMvc2NhdHRlcl9uZF91dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWtCQSxPQUFPLEVBQUMsY0FBYyxFQUFFLGFBQWEsRUFBQyxNQUFNLFNBQVMsQ0FBQztBQUV0RDs7Ozs7R0FLRztBQUNILE1BQU0sVUFBVSxtQkFBbUIsQ0FDL0IsS0FBZSxFQUFFLE9BQWUsRUFBRSxPQUFlO0lBQ25ELE1BQU0sUUFBUSxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDMUUsTUFBTSxRQUFRLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRTNELE1BQU0sVUFBVSxHQUFHLHVEQUF1RDtRQUN0RSx3Q0FBd0MsT0FBTyxDQUFDLEtBQUssRUFBRTtRQUN2RCxvQkFBb0IsT0FBTyxDQUFDLEtBQUssWUFBWSxLQUFLLEVBQUU7UUFDcEQsZUFBZSxRQUFRLG1CQUFtQixRQUFRLEdBQUcsQ0FBQztJQUUxRCxJQUFJLE9BQU8sQ0FBQyxJQUFJLEdBQUcsUUFBUSxFQUFFO1FBQzNCLE1BQU0sSUFBSSxLQUFLLENBQUMsVUFBVSxHQUFHLGtCQUFrQixRQUFRLElBQUksQ0FBQyxDQUFDO0tBQzlEO0lBQ0QsSUFBSSxLQUFLLENBQUMsTUFBTSxHQUFHLFFBQVEsR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEdBQUcsUUFBUSxDQUFDLEVBQUU7UUFDdkQsTUFBTSxJQUFJLEtBQUssQ0FDWCxVQUFVO1lB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cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5pbXBvcnQgeyBUZW5zb3JJbmZvIH0gZnJvbSAnLi4vdGVuc29yX2luZm8nO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5pbXBvcnQge2NvbXB1dGVTdHJpZGVzLCBzaXplRnJvbVNoYXBlfSBmcm9tICcuLi91dGlsJztcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHVwZGF0ZXMuc2hhcGUgPSBpbmRpY2VzLnNoYXBlWzpiYXRjaERpbV0gK1xuICogc2hhcGVbc2xpY2VEaW06XVxuICpcbiAqIEBwYXJhbSB4IFRoZSBpbnB1dCB0ZW5zb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVVwZGF0ZVNoYXBlKFxuICAgIHNoYXBlOiBudW1iZXJbXSwgaW5kaWNlczogVGVuc29yLCB1cGRhdGVzOiBUZW5zb3IpIHtcbiAgY29uc3Qgc2xpY2VEaW0gPSAoaW5kaWNlcy5yYW5rID4gMSkgPyBpbmRpY2VzLnNoYXBlW2luZGljZXMucmFuayAtIDFdIDogMTtcbiAgY29uc3QgYmF0Y2hEaW0gPSAoaW5kaWNlcy5yYW5rID4gMSkgPyBpbmRpY2VzLnJhbmsgLSAxIDogMTtcblxuICBjb25zdCBzaGFwZUVycm9yID0gJ011c3QgaGF2ZSB1cGRhdGVzLnNoYXBlID0gaW5kaWNlcy5zaGFwZVs6YmF0Y2hEaW1dICsgJyArXG4gICAgICBgc2hhcGVbc2xpY2VEaW06XSwgZ290IHVwZGF0ZXMuc2hhcGU6ICR7dXBkYXRlcy5zaGFwZX1gICtcbiAgICAgIGAsIGluZGljZXMuc2hhcGU6ICR7aW5kaWNlcy5zaGFwZX0sIHNoYXBlOiAke3NoYXBlfWAgK1xuICAgICAgYCwgc2xpY2VEaW06ICR7c2xpY2VEaW19LCBhbmQgYmF0Y2hEaW06ICR7YmF0Y2hEaW19LmA7XG5cbiAgaWYgKHVwZGF0ZXMucmFuayA8IGJhdGNoRGltKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHNoYXBlRXJyb3IgKyBgIHVwZGF0ZS5yYW5rIDwgJHtiYXRjaERpbX0uIGApO1xuICB9XG4gIGlmIChzaGFwZS5sZW5ndGggPCBzbGljZURpbSArICh1cGRhdGVzLnJhbmsgLSBiYXRjaERpbSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIHNoYXBlRXJyb3IgK1xuICAgICAgICBgIE91dHB1dCBzaGFwZSBsZW5ndGggPCAke3NsaWNlRGltICsgKHVwZGF0ZXMucmFuayAtIGJhdGNoRGltKX1gKTtcbiAgfVxuICBpZiAodXBkYXRlcy5yYW5rICE9PSBiYXRjaERpbSArIHNoYXBlLmxlbmd0aCAtIHNsaWNlRGltKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBzaGFwZUVycm9yICsgYCB1cGRhdGUucmFuayAhPSAke2JhdGNoRGltICsgc2hhcGUubGVuZ3RoIC0gc2xpY2VEaW19YCk7XG4gIH1cbiAgZm9yIChsZXQgZCA9IDA7IGQgPCBiYXRjaERpbTsgKytkKSB7XG4gICAgaWYgKHVwZGF0ZXMuc2hhcGVbZF0gIT09IGluZGljZXMuc2hhcGVbZF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBzaGFwZUVycm9yICtcbiAgICAgICAgICBgIHVwZGF0ZXMuc2hhcGVbJHtkfV0gKCR7dXBkYXRlcy5zaGFwZVtkXX0pICE9IGluZGljZXMuc2hhcGVbJHtkfV0gKCR7XG4gICAgICAgICAgICAgIGluZGljZXMuc2hhcGVbZF19KS5gKTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgZCA9IDA7IGQgPCB1cGRhdGVzLnJhbmsgLSBiYXRjaERpbTsgKytkKSB7XG4gICAgaWYgKHVwZGF0ZXMuc2hhcGVbZCArIGJhdGNoRGltXSAhPT0gc2hhcGVbZCArIHNsaWNlRGltXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIHNoYXBlRXJyb3IgK1xuICAgICAgICAgIGAgdXBkYXRlcy5zaGFwZVske2QgKyBiYXRjaERpbX1dICgke1xuICAgICAgICAgICAgICB1cGRhdGVzLnNoYXBlW2QgKyBiYXRjaERpbV19KSAhPSBzaGFwZVske2QgKyBiYXRjaERpbX1dICgke1xuICAgICAgICAgICAgICBzaGFwZVtkICsgYmF0Y2hEaW1dfSlgKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTY2F0dGVyU2hhcGVJbmZvIHtcbiAgc2xpY2VSYW5rOiBudW1iZXI7XG4gIG51bVVwZGF0ZXM6IG51bWJlcjtcbiAgc2xpY2VTaXplOiBudW1iZXI7XG4gIHN0cmlkZXM6IG51bWJlcltdO1xuICBvdXRwdXRTaXplOiBudW1iZXI7XG59XG4vKipcbiAqIFZhbGlkYXRlIHNjYXR0ZXIgbmQgaW5wdXRzLlxuICpcbiAqIEBwYXJhbSB1cGRhdGUgVGhlIHRlbnNvciBjb250YWlucyB0aGUgdXBkYXRlIHZhbHVlcy5cbiAqIEBwYXJhbSBpbmRpY2VzIFRoZSB0ZW5zb3IgY29udGFpbnMgdGhlIGluZGljZXMgZm9yIHRoZSB1cGRhdGUgdmFsdWVzLlxuICogQHBhcmFtIHNoYXBlIFRoZSBzaGFwZSBvZiB0aGUgb3V0cHV0IHRlbnNvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlSW5wdXQoXG4gICAgdXBkYXRlczogVGVuc29yLCBpbmRpY2VzOiBUZW5zb3IsIHNoYXBlOiBudW1iZXJbXSkge1xuICBpZiAoaW5kaWNlcy5yYW5rIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ3RmLnNjYXR0ZXJORCgpIGV4cGVjdHMgdGhlIGluZGljZXMgdG8gYmUgcmFuayAxIG9yIGhpZ2hlciwnICtcbiAgICAgICAgYCBidXQgdGhlIHJhbmsgd2FzICR7aW5kaWNlcy5yYW5rfS5gKTtcbiAgfVxuICBpZiAodXBkYXRlcy5yYW5rIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ3RmLnNjYXR0ZXJORCgpIGV4cGVjdHMgdGhlIHVwZGF0ZXMgdG8gYmUgcmFuayAxIG9yIGhpZ2hlciwnICtcbiAgICAgICAgYCBidXQgdGhlIHJhbmsgd2FzICR7dXBkYXRlcy5yYW5rfS5gKTtcbiAgfVxuICBpZiAoaW5kaWNlcy5kdHlwZSAhPT0gJ2ludDMyJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGR0eXBlIG9mICdpbmRpY2VzJyBzaG91bGQgYmUgaW50MzIsIGJ1dCBnb3QgZHR5cGU6ICR7XG4gICAgICAgIGluZGljZXMuZHR5cGV9YCk7XG4gIH1cbiAgaWYgKHNoYXBlLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBPdXRwdXQgcmFuayBtdXN0IGJlIGdyZWF0ZXIgb3IgZXF1YWwgdG8gMSwgYnV0IGdvdCBzaGFwZTogJHtzaGFwZX1gKTtcbiAgfVxuXG4gIGlmIChzaGFwZS5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaW5kaWNlcy5zaXplID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEluZGljZXMgc3BlY2lmaWVkIGZvciBlbXB0eSBvdXRwdXQuIGluZGljZXMgc2hhcGU6ICR7XG4gICAgICAgICAgaW5kaWNlcy5zaGFwZX1gKTtcbiAgICB9XG4gICAgaWYgKHVwZGF0ZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVcGRhdGVzIHNwZWNpZmllZCBmb3IgZW1wdHkgb3V0cHV0LiB1cGRhdGVzIHNoYXBlOiAke1xuICAgICAgICAgIHVwZGF0ZXMuc2hhcGV9YCk7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGVVcGRhdGVTaGFwZShzaGFwZSwgaW5kaWNlcywgdXBkYXRlcyk7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBzaGFwZSBpbmZvcm1hdGlvbiBmb3IgdGhlIG91dHB1dC5cbiAqXG4gKiBAcGFyYW0gdXBkYXRlIFRoZSB0ZW5zb3IgY29udGFpbnMgdGhlIHVwZGF0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0gaW5kaWNlcyBUaGUgdGVuc29yIGNvbnRhaW5zIHRoZSBpbmRpY2VzIGZvciB0aGUgdXBkYXRlIHZhbHVlcy5cbiAqIEBwYXJhbSBzaGFwZSBUaGUgc2hhcGUgb2YgdGhlIG91dHB1dCB0ZW5zb3IuXG4gKlxuICogQHJldHVybnMgU2NhdHRlclNoYXBlSW5mb1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlU2hhcGVzKFxuICAgIHVwZGF0ZXM6IFRlbnNvckluZm8sIGluZGljZXM6IFRlbnNvckluZm8sXG4gICAgc2hhcGU6IG51bWJlcltdKTogU2NhdHRlclNoYXBlSW5mbyB7XG4gIC8vIENhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIGRpbWVuc2lvbnMgaW4gaW5kaWNlc1xuICBjb25zdCBpbmRpY2VzUmFuayA9IGluZGljZXMuc2hhcGUubGVuZ3RoO1xuICBjb25zdCBzbGljZVJhbmsgPSAoaW5kaWNlc1JhbmsgPiAxKSA/IGluZGljZXMuc2hhcGVbaW5kaWNlc1JhbmsgLSAxXSA6IDE7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdGhhdCBtYWtlIHVwIGVhY2ggc2xpY2Ugb2Ygb3VyIHVwZGF0ZWRcbiAgLy8gdGVuc29yLiBUaGlzIGFsbG93cyB1cyB0byB3b3JrIHdpdGggZmxhdHRlbmVkIHRlbnNvcnMgYW5kIGNvcHkgb3ZlciB3aG9sZVxuICAvLyBzbGljZXMgYXQgYSB0aW1lLlxuICBjb25zdCB0b3RhbE5kID0gc2hhcGUubGVuZ3RoO1xuXG4gIGxldCBzbGljZVNpemUgPSAxO1xuICBmb3IgKGxldCBpID0gc2xpY2VSYW5rOyBpIDwgdG90YWxOZDsgKytpKSB7XG4gICAgc2xpY2VTaXplICo9IHNoYXBlW2ldO1xuICB9XG5cbiAgY29uc3Qgc2FmZVNsaWNlRGltID0gKHNsaWNlUmFuayA8IDEpID8gMSA6IHNsaWNlUmFuaztcbiAgY29uc3QgbnVtVXBkYXRlcyA9IHNpemVGcm9tU2hhcGUoaW5kaWNlcy5zaGFwZSkgLyBzYWZlU2xpY2VEaW07XG5cbiAgY29uc3Qgc3RyaWRlcyA9IFsuLi5jb21wdXRlU3RyaWRlcyhzaGFwZS5zbGljZSgwLCBzbGljZVJhbmspKSwgMV07XG4gIGNvbnN0IG91dHB1dFNpemUgPSBzaXplRnJvbVNoYXBlKHNoYXBlKTtcbiAgcmV0dXJuIHtzbGljZVJhbmssIG51bVVwZGF0ZXMsIHNsaWNlU2l6ZSwgc3RyaWRlcywgb3V0cHV0U2l6ZX07XG59XG4iXX0=","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { nearestDivisor } from '../util';\nimport { PARALLELIZE_THRESHOLD } from './reduce_util';\nexport function segOpComputeOptimalWindowSize(inSize, numSegments) {\n    let done = false;\n    let res;\n    if (inSize <= PARALLELIZE_THRESHOLD) {\n        res = inSize;\n        done = true;\n    }\n    else {\n        res = nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));\n    }\n    while (!done) {\n        if (res > numSegments || res === inSize) {\n            done = true;\n        }\n        else {\n            res = nearestDivisor(inSize, res + 1);\n        }\n    }\n    return res;\n}\nexport function computeOutShape(aShape, axis, numSegments) {\n    const outShape = [];\n    const rank = aShape.length;\n    for (let dim = 0; dim < rank; dim++) {\n        if (dim !== axis) {\n            outShape.push(aShape[dim]);\n        }\n        else {\n            outShape.push(numSegments);\n        }\n    }\n    return outShape;\n}\nexport function collectGatherOpShapeInfo(x, indices, axis, batchDims) {\n    const indicesRank = indices.shape.length;\n    const xRank = x.shape.length;\n    if (batchDims !== 0) {\n        if (batchDims < -indicesRank || batchDims > indicesRank) {\n            throw new Error(`Expect batchDims in the range of [-${indicesRank}, ${indicesRank}], but got ${batchDims}`);\n        }\n    }\n    if (batchDims < 0) {\n        batchDims += indicesRank;\n    }\n    if (batchDims > xRank) {\n        throw new Error(`batchDims (${batchDims}) must be less than rank(x) (\n    ${xRank}).`);\n    }\n    if (axis < batchDims) {\n        throw new Error(`batchDims (${batchDims}) must be less than or equal to axis (${axis}).`);\n    }\n    for (let i = 0; i < batchDims; ++i) {\n        if (x.shape[i] !== indices.shape[i]) {\n            throw new Error(`x.shape[${i}]: ${x.shape[i]} should be equal to indices.shape[${i}]: ${indices.shape[i]}.`);\n        }\n    }\n    const dimSize = x.shape[axis];\n    const outputShape = [];\n    let batchSize = 1;\n    let outerSize = 1;\n    let sliceSize = 1;\n    for (let i = 0; i < batchDims; ++i) {\n        outputShape.push(x.shape[i]);\n        batchSize *= x.shape[i];\n    }\n    for (let i = batchDims; i < axis; i++) {\n        outputShape.push(x.shape[i]);\n        outerSize *= x.shape[i];\n    }\n    for (let i = batchDims; i < indicesRank; i++) {\n        outputShape.push(indices.shape[i]);\n    }\n    for (let i = axis + 1; i < xRank; i++) {\n        outputShape.push(x.shape[i]);\n        sliceSize *= x.shape[i];\n    }\n    return { batchSize, sliceSize, outerSize, dimSize, outputShape };\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VnbWVudF91dGlsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1jb3JlL3NyYy9vcHMvc2VnbWVudF91dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUdILE9BQU8sRUFBQyxjQUFjLEVBQUMsTUFBTSxTQUFTLENBQUM7QUFFdkMsT0FBTyxFQUFDLHFCQUFxQixFQUFDLE1BQU0sZUFBZSxDQUFDO0FBU3BELE1BQU0sVUFBVSw2QkFBNkIsQ0FDekMsTUFBYyxFQUFFLFdBQW1CO0lBQ3JDLElBQUksSUFBSSxHQUFHLEtBQUssQ0FBQztJQUNqQixJQUFJLEdBQUcsQ0FBQztJQUVSLElBQUksTUFBTSxJQUFJLHFCQUFxQixFQUFFO1FBQ25DLEdBQUcsR0FBRyxNQUFNLENBQUM7UUFDYixJQUFJLEdBQUcsSUFBSSxDQUFDO0tBQ2I7U0FBTTtRQUNMLEdBQUcsR0FBRyxjQUFjLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDN0Q7SUFFRCxPQUFPLENBQUMsSUFBSSxFQUFFO1FBQ1osSUFBSSxHQUFHLEdBQUcsV0FBVyxJQUFJLEdBQUcsS0FBSyxNQUFNLEVBQUU7WUFDdkMsSUFBSSxHQUFHLElBQUksQ0FBQztTQUNiO2FBQU07WUFDTCxHQUFHLEdBQUcsY0FBYyxDQUFDLE1BQU0sRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUM7U0FDdkM7S0FDRjtJQUNELE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQztBQUVELE1BQU0sVUFBVSxlQUFlLENBQzNCLE1BQWdCLEVBQUUsSUFBWSxFQUFFLFdBQW1CO0lBQ3JELE1BQU0sUUFBUSxHQUFHLEVBQUUsQ0FBQztJQUNwQixNQUFNLElBQUksR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO0lBQzNCLEtBQUssSUFBSSxH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QUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNwQztJQUVELEtBQUssSUFBSSxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ3JDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzdCLFNBQVMsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3pCO0lBRUQsT0FBTyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUMsQ0FBQztBQUNqRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQgeyBUZW5zb3JJbmZvIH0gZnJvbSAnLi4vdGVuc29yX2luZm8nO1xuaW1wb3J0IHtuZWFyZXN0RGl2aXNvcn0gZnJvbSAnLi4vdXRpbCc7XG5cbmltcG9ydCB7UEFSQUxMRUxJWkVfVEhSRVNIT0xEfSBmcm9tICcuL3JlZHVjZV91dGlsJztcblxuZXhwb3J0IGludGVyZmFjZSBTZWdPcEluZm8ge1xuICB3aW5kb3dTaXplOiBudW1iZXI7XG4gIGJhdGNoU2l6ZTogbnVtYmVyO1xuICBpblNpemU6IG51bWJlcjtcbiAgbnVtU2VnbWVudHM6IG51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlZ09wQ29tcHV0ZU9wdGltYWxXaW5kb3dTaXplKFxuICAgIGluU2l6ZTogbnVtYmVyLCBudW1TZWdtZW50czogbnVtYmVyKTogbnVtYmVyIHtcbiAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgbGV0IHJlcztcblxuICBpZiAoaW5TaXplIDw9IFBBUkFMTEVMSVpFX1RIUkVTSE9MRCkge1xuICAgIHJlcyA9IGluU2l6ZTtcbiAgICBkb25lID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXMgPSBuZWFyZXN0RGl2aXNvcihpblNpemUsIE1hdGguZmxvb3IoTWF0aC5zcXJ0KGluU2l6ZSkpKTtcbiAgfVxuXG4gIHdoaWxlICghZG9uZSkge1xuICAgIGlmIChyZXMgPiBudW1TZWdtZW50cyB8fCByZXMgPT09IGluU2l6ZSkge1xuICAgICAgZG9uZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IG5lYXJlc3REaXZpc29yKGluU2l6ZSwgcmVzICsgMSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlT3V0U2hhcGUoXG4gICAgYVNoYXBlOiBudW1iZXJbXSwgYXhpczogbnVtYmVyLCBudW1TZWdtZW50czogbnVtYmVyKTogbnVtYmVyW10ge1xuICBjb25zdCBvdXRTaGFwZSA9IFtdO1xuICBjb25zdCByYW5rID0gYVNoYXBlLmxlbmd0aDtcbiAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgcmFuazsgZGltKyspIHtcbiAgICBpZiAoZGltICE9PSBheGlzKSB7XG4gICAgICBvdXRTaGFwZS5wdXNoKGFTaGFwZVtkaW1dKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0U2hhcGUucHVzaChudW1TZWdtZW50cyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRTaGFwZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHYXRoZXJPcFNoYXBlSW5mbyB7XG4gIGJhdGNoU2l6ZTogbnVtYmVyO1xuICBzbGljZVNpemU6IG51bWJlcjtcbiAgb3V0ZXJTaXplOiBudW1iZXI7XG4gIGRpbVNpemU6IG51bWJlcjtcbiAgb3V0cHV0U2hhcGU6IG51bWJlcltdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29sbGVjdEdhdGhlck9wU2hhcGVJbmZvKFxuICAgIHg6IFRlbnNvckluZm8sIGluZGljZXM6IFRlbnNvckluZm8sIGF4aXM6IG51bWJlcixcbiAgICBiYXRjaERpbXM6IG51bWJlcik6IEdhdGhlck9wU2hhcGVJbmZvIHtcbiAgY29uc3QgaW5kaWNlc1JhbmsgPSBpbmRpY2VzLnNoYXBlLmxlbmd0aDtcbiAgY29uc3QgeFJhbmsgPSB4LnNoYXBlLmxlbmd0aDtcblxuICBpZiAoYmF0Y2hEaW1zICE9PSAwKSB7XG4gICAgaWYgKGJhdGNoRGltcyA8IC1pbmRpY2VzUmFuayB8fCBiYXRjaERpbXMgPiBpbmRpY2VzUmFuaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3QgYmF0Y2hEaW1zIGluIHRoZSByYW5nZSBvZiBbLSR7aW5kaWNlc1Jhbmt9LCAke1xuICAgICAgICAgIGluZGljZXNSYW5rfV0sIGJ1dCBnb3QgJHtiYXRjaERpbXN9YCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGJhdGNoRGltcyA8IDApIHtcbiAgICBiYXRjaERpbXMgKz0gaW5kaWNlc1Jhbms7XG4gIH1cblxuICBpZiAoYmF0Y2hEaW1zID4geFJhbmspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGJhdGNoRGltcyAoJHtiYXRjaERpbXN9KSBtdXN0IGJlIGxlc3MgdGhhbiByYW5rKHgpIChcbiAgICAke3hSYW5rfSkuYCk7XG4gIH1cblxuICBpZiAoYXhpcyA8IGJhdGNoRGltcykge1xuICAgIHRocm93IG5ldyBFcnJvcihgYmF0Y2hEaW1zICgke1xuICAgICAgICBiYXRjaERpbXN9KSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBheGlzICgke2F4aXN9KS5gKTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmF0Y2hEaW1zOyArK2kpIHtcbiAgICBpZiAoeC5zaGFwZVtpXSAhPT0gaW5kaWNlcy5zaGFwZVtpXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGB4LnNoYXBlWyR7aX1dOiAke3guc2hhcGVbaV19IHNob3VsZCBiZSBlcXVhbCB0byBpbmRpY2VzLnNoYXBlWyR7XG4gICAgICAgICAgICAgIGl9XTogJHtpbmRpY2VzLnNoYXBlW2ldfS5gKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZGltU2l6ZSA9IHguc2hhcGVbYXhpc107XG5cbiAgY29uc3Qgb3V0cHV0U2hhcGU6IG51bWJlcltdID0gW107XG4gIGxldCBiYXRjaFNpemUgPSAxO1xuICBsZXQgb3V0ZXJTaXplID0gMTtcbiAgbGV0IHNsaWNlU2l6ZSA9IDE7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaERpbXM7ICsraSkge1xuICAgIG91dHB1dFNoYXBlLnB1c2goeC5zaGFwZVtpXSk7XG4gICAgYmF0Y2hTaXplICo9IHguc2hhcGVbaV07XG4gIH1cblxuICBmb3IgKGxldCBpID0gYmF0Y2hEaW1zOyBpIDwgYXhpczsgaSsrKSB7XG4gICAgb3V0cHV0U2hhcGUucHVzaCh4LnNoYXBlW2ldKTtcbiAgICBvdXRlclNpemUgKj0geC5zaGFwZVtpXTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSBiYXRjaERpbXM7IGkgPCBpbmRpY2VzUmFuazsgaSsrKSB7XG4gICAgb3V0cHV0U2hhcGUucHVzaChpbmRpY2VzLnNoYXBlW2ldKTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSBheGlzICsgMTsgaSA8IHhSYW5rOyBpKyspIHtcbiAgICBvdXRwdXRTaGFwZS5wdXNoKHguc2hhcGVbaV0pO1xuICAgIHNsaWNlU2l6ZSAqPSB4LnNoYXBlW2ldO1xuICB9XG5cbiAgcmV0dXJuIHtiYXRjaFNpemUsIHNsaWNlU2l6ZSwgb3V0ZXJTaXplLCBkaW1TaXplLCBvdXRwdXRTaGFwZX07XG59XG4iXX0=","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport const SELU_SCALEALPHA = 1.7580993408473768599402175208123;\nexport const SELU_SCALE = 1.0507009873554804934193349852946;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsdV91dGlsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1jb3JlL3NyYy9vcHMvc2VsdV91dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUVILE1BQU0sQ0FBQyxNQUFNLGVBQWUsR0FBRyxpQ0FBaUMsQ0FBQztBQUNqRSxNQUFNLENBQUMsTUFBTSxVQUFVLEdBQUcsaUNBQWlDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmV4cG9ydCBjb25zdCBTRUxVX1NDQUxFQUxQSEEgPSAxLjc1ODA5OTM0MDg0NzM3Njg1OTk0MDIxNzUyMDgxMjM7XG5leHBvcnQgY29uc3QgU0VMVV9TQ0FMRSA9IDEuMDUwNzAwOTg3MzU1NDgwNDkzNDE5MzM0OTg1Mjk0NjtcbiJdfQ==","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Sigmoid } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Computes sigmoid element-wise, `1 / (1 + exp(-x))`\n *\n * ```js\n * const x = tf.tensor1d([0, -1, 2, -3]);\n *\n * x.sigmoid().print();  // or tf.sigmoid(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction sigmoid_(x) {\n    const $x = convertToTensor(x, 'x', 'sigmoid', 'float32');\n    const inputs = { x: $x };\n    return ENGINE.runKernel(Sigmoid, inputs);\n}\nexport const sigmoid = /* @__PURE__ */ op({ sigmoid_ });\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2lnbW9pZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtY29yZS9zcmMvb3BzL3NpZ21vaWQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUNqQyxPQUFPLEVBQUMsT0FBTyxFQUFnQixNQUFNLGlCQUFpQixDQUFDO0FBR3ZELE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSxvQkFBb0IsQ0FBQztBQUduRCxPQUFPLEVBQUMsRUFBRSxFQUFDLE1BQU0sYUFBYSxDQUFDO0FBRS9COzs7Ozs7Ozs7OztHQVdHO0FBQ0gsU0FBUyxRQUFRLENBQW1CLENBQWU7SUFDakQsTUFBTSxFQUFFLEdBQUcsZUFBZSxDQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBRXpELE1BQU0sTUFBTSxHQUFrQixFQUFDLENBQUMsRUFBRSxFQUFFLEVBQUMsQ0FBQztJQUV0QyxPQUFPLE1BQU0sQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFLE1BQW1DLENBQUMsQ0FBQztBQUN4RSxDQUFDO0FBQ0QsTUFBTSxDQUFDLE1BQU0sT0FBTyxHQUFHLGVBQWUsQ0FBQyxFQUFFLENBQUMsRUFBQyxRQUFRLEVBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge0VOR0lORX0gZnJvbSAnLi4vZW5naW5lJztcbmltcG9ydCB7U2lnbW9pZCwgU2lnbW9pZElucHV0c30gZnJvbSAnLi4va2VybmVsX25hbWVzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi90ZW5zb3InO1xuaW1wb3J0IHtOYW1lZFRlbnNvck1hcH0gZnJvbSAnLi4vdGVuc29yX3R5cGVzJztcbmltcG9ydCB7Y29udmVydFRvVGVuc29yfSBmcm9tICcuLi90ZW5zb3JfdXRpbF9lbnYnO1xuaW1wb3J0IHtUZW5zb3JMaWtlfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7b3B9IGZyb20gJy4vb3BlcmF0aW9uJztcblxuLyoqXG4gKiBDb21wdXRlcyBzaWdtb2lkIGVsZW1lbnQtd2lzZSwgYDEgLyAoMSArIGV4cCgteCkpYFxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCB4ID0gdGYudGVuc29yMWQoWzAsIC0xLCAyLCAtM10pO1xuICpcbiAqIHguc2lnbW9pZCgpLnByaW50KCk7ICAvLyBvciB0Zi5zaWdtb2lkKHgpXG4gKiBgYGBcbiAqIEBwYXJhbSB4IFRoZSBpbnB1dCB0ZW5zb3IuXG4gKlxuICogQGRvYyB7aGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCd9XG4gKi9cbmZ1bmN0aW9uIHNpZ21vaWRfPFQgZXh0ZW5kcyBUZW5zb3I+KHg6IFR8VGVuc29yTGlrZSk6IFQge1xuICBjb25zdCAkeCA9IGNvbnZlcnRUb1RlbnNvcih4LCAneCcsICdzaWdtb2lkJywgJ2Zsb2F0MzInKTtcblxuICBjb25zdCBpbnB1dHM6IFNpZ21vaWRJbnB1dHMgPSB7eDogJHh9O1xuXG4gIHJldHVybiBFTkdJTkUucnVuS2VybmVsKFNpZ21vaWQsIGlucHV0cyBhcyB1bmtub3duIGFzIE5hbWVkVGVuc29yTWFwKTtcbn1cbmV4cG9ydCBjb25zdCBzaWdtb2lkID0gLyogQF9fUFVSRV9fICovIG9wKHtzaWdtb2lkX30pO1xuIl19","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { concat } from '../concat';\nimport { fill } from '../fill';\nimport { op } from '../operation';\nimport { reshape } from '../reshape';\nimport { slice } from '../slice';\nimport { tensor2d } from '../tensor2d';\n/**\n * Expands input into frames of frameLength.\n * Slides a window size with frameStep.\n *\n * ```js\n * tf.signal.frame([1, 2, 3], 2, 1).print();\n * ```\n * @param signal The input tensor to be expanded\n * @param frameLength Length of each frame\n * @param frameStep The frame hop size in samples.\n * @param padEnd Whether to pad the end of signal with padValue.\n * @param padValue A number to use where the input signal does\n *     not exist when padEnd is True.\n *\n * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}\n */\nfunction frame_(signal, frameLength, frameStep, padEnd = false, padValue = 0) {\n    let start = 0;\n    const output = [];\n    while (start + frameLength <= signal.size) {\n        output.push(slice(signal, start, frameLength));\n        start += frameStep;\n    }\n    if (padEnd) {\n        while (start < signal.size) {\n            const padLen = (start + frameLength) - signal.size;\n            const pad = concat([\n                slice(signal, start, frameLength - padLen), fill([padLen], padValue)\n            ]);\n            output.push(pad);\n            start += frameStep;\n        }\n    }\n    if (output.length === 0) {\n        return tensor2d([], [0, frameLength]);\n    }\n    return reshape(concat(output), [output.length, frameLength]);\n}\nexport const frame = /* @__PURE__ */ op({ frame_ });\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnJhbWUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWNvcmUvc3JjL29wcy9zaWduYWwvZnJhbWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBR0gsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUNqQyxPQUFPLEVBQUMsSUFBSSxFQUFDLE1BQU0sU0FBUyxDQUFDO0FBQzdCLE9BQU8sRUFBQyxFQUFFLEVBQUMsTUFBTSxjQUFjLENBQUM7QUFDaEMsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLFlBQVksQ0FBQztBQUNuQyxPQUFPLEVBQUMsS0FBSyxFQUFDLE1BQU0sVUFBVSxDQUFDO0FBQy9CLE9BQU8sRUFBQyxRQUFRLEVBQUMsTUFBTSxhQUFhLENBQUM7QUFFckM7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBQ0gsU0FBUyxNQUFNLENBQ1gsTUFBZ0IsRUFBRSxXQUFtQixFQUFFLFNBQWlCLEVBQUUsTUFBTSxHQUFHLEtBQUssRUFDeEUsUUFBUSxHQUFHLENBQUM7SUFDZCxJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7SUFDZCxNQUFNLE1BQU0sR0FBYSxFQUFFLENBQUM7SUFDNUIsT0FBTyxLQUFLLEdBQUcsV0FBVyxJQUFJLE1BQU0sQ0FBQyxJQUFJLEVBQUU7UUFDekMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDO1FBQy9DLEtBQUssSUFBSSxTQUFTLENBQUM7S0FDcEI7SUFFRCxJQUFJLE1BQU0sRUFBRTtRQUNWLE9BQU8sS0FBSyxHQUFHLE1BQU0sQ0FBQyxJQUFJLEVBQUU7WUFDMUIsTUFBTSxNQUFNLEdBQUcsQ0FBQyxLQUFLLEdBQUcsV0FBVyxDQUFDLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQztZQUNuRCxNQUFNLEdBQUcsR0FBRyxNQUFNLENBQUM7Z0JBQ2pCLEtBQUssQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLFdBQVcsR0FBRyxNQUFNLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxRQUFRLENBQUM7YUFDckUsQ0FBQyxDQUFDO1lBQ0gsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNqQixLQUFLLElBQUksU0FBUyxDQUFDO1NBQ3BCO0tBQ0Y7SUFFRCxJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ3ZCLE9BQU8sUUFBUSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDO0tBQ3ZDO0lBRUQsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDO0FBQy9ELENBQUM7QUFDRCxNQUFNLENBQUMsTUFBTSxLQUFLLEdBQUcsZUFBZSxDQUFDLEVBQUUsQ0FBQyxFQUFDLE1BQU0sRUFBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7VGVuc29yLCBUZW5zb3IxRH0gZnJvbSAnLi4vLi4vdGVuc29yJztcbmltcG9ydCB7Y29uY2F0fSBmcm9tICcuLi9jb25jYXQnO1xuaW1wb3J0IHtmaWxsfSBmcm9tICcuLi9maWxsJztcbmltcG9ydCB7b3B9IGZyb20gJy4uL29wZXJhdGlvbic7XG5pbXBvcnQge3Jlc2hhcGV9IGZyb20gJy4uL3Jlc2hhcGUnO1xuaW1wb3J0IHtzbGljZX0gZnJvbSAnLi4vc2xpY2UnO1xuaW1wb3J0IHt0ZW5zb3IyZH0gZnJvbSAnLi4vdGVuc29yMmQnO1xuXG4vKipcbiAqIEV4cGFuZHMgaW5wdXQgaW50byBmcmFtZXMgb2YgZnJhbWVMZW5ndGguXG4gKiBTbGlkZXMgYSB3aW5kb3cgc2l6ZSB3aXRoIGZyYW1lU3RlcC5cbiAqXG4gKiBgYGBqc1xuICogdGYuc2lnbmFsLmZyYW1lKFsxLCAyLCAzXSwgMiwgMSkucHJpbnQoKTtcbiAqIGBgYFxuICogQHBhcmFtIHNpZ25hbCBUaGUgaW5wdXQgdGVuc29yIHRvIGJlIGV4cGFuZGVkXG4gKiBAcGFyYW0gZnJhbWVMZW5ndGggTGVuZ3RoIG9mIGVhY2ggZnJhbWVcbiAqIEBwYXJhbSBmcmFtZVN0ZXAgVGhlIGZyYW1lIGhvcCBzaXplIGluIHNhbXBsZXMuXG4gKiBAcGFyYW0gcGFkRW5kIFdoZXRoZXIgdG8gcGFkIHRoZSBlbmQgb2Ygc2lnbmFsIHdpdGggcGFkVmFsdWUuXG4gKiBAcGFyYW0gcGFkVmFsdWUgQSBudW1iZXIgdG8gdXNlIHdoZXJlIHRoZSBpbnB1dCBzaWduYWwgZG9lc1xuICogICAgIG5vdCBleGlzdCB3aGVuIHBhZEVuZCBpcyBUcnVlLlxuICpcbiAqIEBkb2Mge2hlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ1NpZ25hbCcsIG5hbWVzcGFjZTogJ3NpZ25hbCd9XG4gKi9cbmZ1bmN0aW9uIGZyYW1lXyhcbiAgICBzaWduYWw6IFRlbnNvcjFELCBmcmFtZUxlbmd0aDogbnVtYmVyLCBmcmFtZVN0ZXA6IG51bWJlciwgcGFkRW5kID0gZmFsc2UsXG4gICAgcGFkVmFsdWUgPSAwKTogVGVuc29yIHtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgY29uc3Qgb3V0cHV0OiBUZW5zb3JbXSA9IFtdO1xuICB3aGlsZSAoc3RhcnQgKyBmcmFtZUxlbmd0aCA8PSBzaWduYWwuc2l6ZSkge1xuICAgIG91dHB1dC5wdXNoKHNsaWNlKHNpZ25hbCwgc3RhcnQsIGZyYW1lTGVuZ3RoKSk7XG4gICAgc3RhcnQgKz0gZnJhbWVTdGVwO1xuICB9XG5cbiAgaWYgKHBhZEVuZCkge1xuICAgIHdoaWxlIChzdGFydCA8IHNpZ25hbC5zaXplKSB7XG4gICAgICBjb25zdCBwYWRMZW4gPSAoc3RhcnQgKyBmcmFtZUxlbmd0aCkgLSBzaWduYWwuc2l6ZTtcbiAgICAgIGNvbnN0IHBhZCA9IGNvbmNhdChbXG4gICAgICAgIHNsaWNlKHNpZ25hbCwgc3RhcnQsIGZyYW1lTGVuZ3RoIC0gcGFkTGVuKSwgZmlsbChbcGFkTGVuXSwgcGFkVmFsdWUpXG4gICAgICBdKTtcbiAgICAgIG91dHB1dC5wdXNoKHBhZCk7XG4gICAgICBzdGFydCArPSBmcmFtZVN0ZXA7XG4gICAgfVxuICB9XG5cbiAgaWYgKG91dHB1dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGVuc29yMmQoW10sIFswLCBmcmFtZUxlbmd0aF0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc2hhcGUoY29uY2F0KG91dHB1dCksIFtvdXRwdXQubGVuZ3RoLCBmcmFtZUxlbmd0aF0pO1xufVxuZXhwb3J0IGNvbnN0IGZyYW1lID0gLyogQF9fUFVSRV9fICovIG9wKHtmcmFtZV99KTtcbiJdfQ==","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { op } from '../operation';\nimport { cosineWindow } from '../signal_ops_util';\n/**\n * Generate a hamming window.\n *\n * See: https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows\n *\n * ```js\n * tf.signal.hammingWindow(10).print();\n * ```\n * @param The length of window\n *\n * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}\n */\nfunction hammingWindow_(windowLength) {\n    return cosineWindow(windowLength, 0.54, 0.46);\n}\nexport const hammingWindow = /* @__PURE__ */ op({ hammingWindow_ });\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGFtbWluZ193aW5kb3cuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWNvcmUvc3JjL29wcy9zaWduYWwvaGFtbWluZ193aW5kb3cudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBR0gsT0FBTyxFQUFDLEVBQUUsRUFBQyxNQUFNLGNBQWMsQ0FBQztBQUNoQyxPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFFaEQ7Ozs7Ozs7Ozs7O0dBV0c7QUFDSCxTQUFTLGNBQWMsQ0FBQyxZQUFvQjtJQUMxQyxPQUFPLFlBQVksQ0FBQyxZQUFZLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ2hELENBQUM7QUFDRCxNQUFNLENBQUMsTUFBTSxhQUFhLEdBQUcsZUFBZSxDQUFDLEVBQUUsQ0FBQyxFQUFDLGNBQWMsRUFBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7VGVuc29yMUR9IGZyb20gJy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge29wfSBmcm9tICcuLi9vcGVyYXRpb24nO1xuaW1wb3J0IHtjb3NpbmVXaW5kb3d9IGZyb20gJy4uL3NpZ25hbF9vcHNfdXRpbCc7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBoYW1taW5nIHdpbmRvdy5cbiAqXG4gKiBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dpbmRvd19mdW5jdGlvbiNIYW5uX2FuZF9IYW1taW5nX3dpbmRvd3NcbiAqXG4gKiBgYGBqc1xuICogdGYuc2lnbmFsLmhhbW1pbmdXaW5kb3coMTApLnByaW50KCk7XG4gKiBgYGBcbiAqIEBwYXJhbSBUaGUgbGVuZ3RoIG9mIHdpbmRvd1xuICpcbiAqIEBkb2Mge2hlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ1NpZ25hbCcsIG5hbWVzcGFjZTogJ3NpZ25hbCd9XG4gKi9cbmZ1bmN0aW9uIGhhbW1pbmdXaW5kb3dfKHdpbmRvd0xlbmd0aDogbnVtYmVyKTogVGVuc29yMUQge1xuICByZXR1cm4gY29zaW5lV2luZG93KHdpbmRvd0xlbmd0aCwgMC41NCwgMC40Nik7XG59XG5leHBvcnQgY29uc3QgaGFtbWluZ1dpbmRvdyA9IC8qIEBfX1BVUkVfXyAqLyBvcCh7aGFtbWluZ1dpbmRvd199KTtcbiJdfQ==","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { op } from '../operation';\nimport { cosineWindow } from '../signal_ops_util';\n/**\n * Generate a Hann window.\n *\n * See: https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows\n *\n * ```js\n * tf.signal.hannWindow(10).print();\n * ```\n * @param The length of window\n *\n * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}\n */\nfunction hannWindow_(windowLength) {\n    return cosineWindow(windowLength, 0.5, 0.5);\n}\nexport const hannWindow = /* @__PURE__ */ op({ hannWindow_ });\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGFubl93aW5kb3cuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWNvcmUvc3JjL29wcy9zaWduYWwvaGFubl93aW5kb3cudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBR0gsT0FBTyxFQUFDLEVBQUUsRUFBQyxNQUFNLGNBQWMsQ0FBQztBQUNoQyxPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFFaEQ7Ozs7Ozs7Ozs7O0dBV0c7QUFDSCxTQUFTLFdBQVcsQ0FBQyxZQUFvQjtJQUN2QyxPQUFPLFlBQVksQ0FBQyxZQUFZLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQzlDLENBQUM7QUFFRCxNQUFNLENBQUMsTUFBTSxVQUFVLEdBQUcsZUFBZSxDQUFDLEVBQUUsQ0FBQyxFQUFDLFdBQVcsRUFBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7VGVuc29yMUR9IGZyb20gJy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge29wfSBmcm9tICcuLi9vcGVyYXRpb24nO1xuaW1wb3J0IHtjb3NpbmVXaW5kb3d9IGZyb20gJy4uL3NpZ25hbF9vcHNfdXRpbCc7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBIYW5uIHdpbmRvdy5cbiAqXG4gKiBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dpbmRvd19mdW5jdGlvbiNIYW5uX2FuZF9IYW1taW5nX3dpbmRvd3NcbiAqXG4gKiBgYGBqc1xuICogdGYuc2lnbmFsLmhhbm5XaW5kb3coMTApLnByaW50KCk7XG4gKiBgYGBcbiAqIEBwYXJhbSBUaGUgbGVuZ3RoIG9mIHdpbmRvd1xuICpcbiAqIEBkb2Mge2hlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ1NpZ25hbCcsIG5hbWVzcGFjZTogJ3NpZ25hbCd9XG4gKi9cbmZ1bmN0aW9uIGhhbm5XaW5kb3dfKHdpbmRvd0xlbmd0aDogbnVtYmVyKTogVGVuc29yMUQge1xuICByZXR1cm4gY29zaW5lV2luZG93KHdpbmRvd0xlbmd0aCwgMC41LCAwLjUpO1xufVxuXG5leHBvcnQgY29uc3QgaGFubldpbmRvdyA9IC8qIEBfX1BVUkVfXyAqLyBvcCh7aGFubldpbmRvd199KTtcbiJdfQ==","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { mul } from '../mul';\nimport { op } from '../operation';\nimport { enclosingPowerOfTwo } from '../signal_ops_util';\nimport { rfft } from '../spectral/rfft';\nimport { frame } from './frame';\nimport { hannWindow } from './hann_window';\n/**\n * Computes the Short-time Fourier Transform of signals\n * See: https://en.wikipedia.org/wiki/Short-time_Fourier_transform\n *\n * ```js\n * const input = tf.tensor1d([1, 1, 1, 1, 1])\n * tf.signal.stft(input, 3, 1).print();\n * ```\n * @param signal 1-dimensional real value tensor.\n * @param frameLength The window length of samples.\n * @param frameStep The number of samples to step.\n * @param fftLength The size of the FFT to apply.\n * @param windowFn A callable that takes a window length and returns 1-d tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}\n */\nfunction stft_(signal, frameLength, frameStep, fftLength, windowFn = hannWindow) {\n    if (fftLength == null) {\n        fftLength = enclosingPowerOfTwo(frameLength);\n    }\n    const framedSignal = frame(signal, frameLength, frameStep);\n    const windowedSignal = mul(framedSignal, windowFn(frameLength));\n    return rfft(windowedSignal, fftLength);\n}\nexport const stft = /* @__PURE__ */ op({ stft_ });\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RmdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3RmanMtY29yZS9zcmMvb3BzL3NpZ25hbC9zdGZ0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUdILE9BQU8sRUFBQyxHQUFHLEVBQUMsTUFBTSxRQUFRLENBQUM7QUFDM0IsT0FBTyxFQUFDLEVBQUUsRUFBQyxNQUFNLGNBQWMsQ0FBQztBQUNoQyxPQUFPLEVBQUMsbUJBQW1CLEVBQUMsTUFBTSxvQkFBb0IsQ0FBQztBQUN2RCxPQUFPLEVBQUMsSUFBSSxFQUFDLE1BQU0sa0JBQWtCLENBQUM7QUFFdEMsT0FBTyxFQUFDLEtBQUssRUFBQyxNQUFNLFNBQVMsQ0FBQztBQUM5QixPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBRXpDOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUNILFNBQVMsS0FBSyxDQUNWLE1BQWdCLEVBQUUsV0FBbUIsRUFBRSxTQUFpQixFQUN4RCxTQUFrQixFQUNsQixXQUF5QyxVQUFVO0lBQ3JELElBQUksU0FBUyxJQUFJLElBQUksRUFBRTtRQUNyQixTQUFTLEdBQUcsbUJBQW1CLENBQUMsV0FBVyxDQUFDLENBQUM7S0FDOUM7SUFDRCxNQUFNLFlBQVksR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLFdBQVcsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUMzRCxNQUFNLGNBQWMsR0FBRyxHQUFHLENBQUMsWUFBWSxFQUFFLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO0lBQ2hFLE9BQU8sSUFBSSxDQUFDLGNBQWMsRUFBRSxTQUFTLENBQUMsQ0FBQztBQUN6QyxDQUFDO0FBQ0QsTUFBTSxDQUFDLE1BQU0sSUFBSSxHQUFHLGVBQWUsQ0FBQyxFQUFFLENBQUMsRUFBQyxLQUFLLEVBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge1RlbnNvciwgVGVuc29yMUR9IGZyb20gJy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge211bH0gZnJvbSAnLi4vbXVsJztcbmltcG9ydCB7b3B9IGZyb20gJy4uL29wZXJhdGlvbic7XG5pbXBvcnQge2VuY2xvc2luZ1Bvd2VyT2ZUd299IGZyb20gJy4uL3NpZ25hbF9vcHNfdXRpbCc7XG5pbXBvcnQge3JmZnR9IGZyb20gJy4uL3NwZWN0cmFsL3JmZnQnO1xuXG5pbXBvcnQge2ZyYW1lfSBmcm9tICcuL2ZyYW1lJztcbmltcG9ydCB7aGFubldpbmRvd30gZnJvbSAnLi9oYW5uX3dpbmRvdyc7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFNob3J0LXRpbWUgRm91cmllciBUcmFuc2Zvcm0gb2Ygc2lnbmFsc1xuICogU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaG9ydC10aW1lX0ZvdXJpZXJfdHJhbnNmb3JtXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGlucHV0ID0gdGYudGVuc29yMWQoWzEsIDEsIDEsIDEsIDFdKVxuICogdGYuc2lnbmFsLnN0ZnQoaW5wdXQsIDMsIDEpLnByaW50KCk7XG4gKiBgYGBcbiAqIEBwYXJhbSBzaWduYWwgMS1kaW1lbnNpb25hbCByZWFsIHZhbHVlIHRlbnNvci5cbiAqIEBwYXJhbSBmcmFtZUxlbmd0aCBUaGUgd2luZG93IGxlbmd0aCBvZiBzYW1wbGVzLlxuICogQHBhcmFtIGZyYW1lU3RlcCBUaGUgbnVtYmVyIG9mIHNhbXBsZXMgdG8gc3RlcC5cbiAqIEBwYXJhbSBmZnRMZW5ndGggVGhlIHNpemUgb2YgdGhlIEZGVCB0byBhcHBseS5cbiAqIEBwYXJhbSB3aW5kb3dGbiBBIGNhbGxhYmxlIHRoYXQgdGFrZXMgYSB3aW5kb3cgbGVuZ3RoIGFuZCByZXR1cm5zIDEtZCB0ZW5zb3IuXG4gKlxuICogQGRvYyB7aGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnU2lnbmFsJywgbmFtZXNwYWNlOiAnc2lnbmFsJ31cbiAqL1xuZnVuY3Rpb24gc3RmdF8oXG4gICAgc2lnbmFsOiBUZW5zb3IxRCwgZnJhbWVMZW5ndGg6IG51bWJlciwgZnJhbWVTdGVwOiBudW1iZXIsXG4gICAgZmZ0TGVuZ3RoPzogbnVtYmVyLFxuICAgIHdpbmRvd0ZuOiAobGVuZ3RoOiBudW1iZXIpID0+IFRlbnNvcjFEID0gaGFubldpbmRvdyk6IFRlbnNvciB7XG4gIGlmIChmZnRMZW5ndGggPT0gbnVsbCkge1xuICAgIGZmdExlbmd0aCA9IGVuY2xvc2luZ1Bvd2VyT2ZUd28oZnJhbWVMZW5ndGgpO1xuICB9XG4gIGNvbnN0IGZyYW1lZFNpZ25hbCA9IGZyYW1lKHNpZ25hbCwgZnJhbWVMZW5ndGgsIGZyYW1lU3RlcCk7XG4gIGNvbnN0IHdpbmRvd2VkU2lnbmFsID0gbXVsKGZyYW1lZFNpZ25hbCwgd2luZG93Rm4oZnJhbWVMZW5ndGgpKTtcbiAgcmV0dXJuIHJmZnQod2luZG93ZWRTaWduYWwsIGZmdExlbmd0aCk7XG59XG5leHBvcnQgY29uc3Qgc3RmdCA9IC8qIEBfX1BVUkVfXyAqLyBvcCh7c3RmdF99KTtcbiJdfQ==","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { tensor1d } from './tensor1d';\nexport function enclosingPowerOfTwo(value) {\n    // Return 2**N for integer N such that 2**N >= value.\n    return Math.floor(Math.pow(2, Math.ceil(Math.log(value) / Math.log(2.0))));\n}\nexport function cosineWindow(windowLength, a, b) {\n    const even = 1 - windowLength % 2;\n    const newValues = new Float32Array(windowLength);\n    for (let i = 0; i < windowLength; ++i) {\n        const cosArg = (2.0 * Math.PI * i) / (windowLength + even - 1);\n        newValues[i] = a - b * Math.cos(cosArg);\n    }\n    return tensor1d(newValues, 'float32');\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2lnbmFsX29wc191dGlsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1jb3JlL3NyYy9vcHMvc2lnbmFsX29wc191dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUdILE9BQU8sRUFBQyxRQUFRLEVBQUMsTUFBTSxZQUFZLENBQUM7QUFFcEMsTUFBTSxVQUFVLG1CQUFtQixDQUFDLEtBQWE7SUFDL0MscURBQXFEO0lBQ3JELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM3RSxDQUFDO0FBRUQsTUFBTSxVQUFVLFlBQVksQ0FDeEIsWUFBb0IsRUFBRSxDQUFTLEVBQUUsQ0FBUztJQUM1QyxNQUFNLElBQUksR0FBRyxDQUFDLEdBQUcsWUFBWSxHQUFHLENBQUMsQ0FBQztJQUNsQyxNQUFNLFNBQVMsR0FBRyxJQUFJLFlBQVksQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUNqRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsWUFBWSxFQUFFLEVBQUUsQ0FBQyxFQUFFO1FBQ3JDLE1BQU0sTUFBTSxHQUFHLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxZQUFZLEdBQUcsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQy9ELFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDekM7SUFDRCxPQUFPLFFBQVEsQ0FBQyxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFDeEMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtUZW5zb3IxRH0gZnJvbSAnLi4vdGVuc29yJztcbmltcG9ydCB7dGVuc29yMWR9IGZyb20gJy4vdGVuc29yMWQnO1xuXG5leHBvcnQgZnVuY3Rpb24gZW5jbG9zaW5nUG93ZXJPZlR3byh2YWx1ZTogbnVtYmVyKSB7XG4gIC8vIFJldHVybiAyKipOIGZvciBpbnRlZ2VyIE4gc3VjaCB0aGF0IDIqKk4gPj0gdmFsdWUuXG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgucG93KDIsIE1hdGguY2VpbChNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLmxvZygyLjApKSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29zaW5lV2luZG93KFxuICAgIHdpbmRvd0xlbmd0aDogbnVtYmVyLCBhOiBudW1iZXIsIGI6IG51bWJlcik6IFRlbnNvcjFEIHtcbiAgY29uc3QgZXZlbiA9IDEgLSB3aW5kb3dMZW5ndGggJSAyO1xuICBjb25zdCBuZXdWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHdpbmRvd0xlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgd2luZG93TGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjb3NBcmcgPSAoMi4wICogTWF0aC5QSSAqIGkpIC8gKHdpbmRvd0xlbmd0aCArIGV2ZW4gLSAxKTtcbiAgICBuZXdWYWx1ZXNbaV0gPSBhIC0gYiAqIE1hdGguY29zKGNvc0FyZyk7XG4gIH1cbiAgcmV0dXJuIHRlbnNvcjFkKG5ld1ZhbHVlcywgJ2Zsb2F0MzInKTtcbn1cbiJdfQ==","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Slice } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Extracts a slice from a `tf.Tensor` starting at coordinates `begin`\n * and is of size `size`.\n *\n * Also available are stricter rank-specific methods with the same signature\n * as this method that assert that `x` is of the given rank:\n *   - `tf.slice1d`\n *   - `tf.slice2d`\n *   - `tf.slice3d`\n *   - `tf.slice4d`\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n *\n * x.slice([1], [2]).print();\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * x.slice([1, 0], [1, 2]).print();\n * ```\n * @param x The input `tf.Tensor` to slice from.\n * @param begin The coordinates to start the slice from. The length can be\n *     less than the rank of x - the rest of the axes will have implicit 0 as\n *     start. Can also be a single number, in which case it specifies the\n *     first axis.\n * @param size The size of the slice. The length can be less than the rank of\n *     x - the rest of the axes will have implicit -1. A value of -1 requests\n *     the rest of the dimensions in the axis. Can also be a single number,\n *     in which case it specifies the size of the first axis.\n *\n * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}\n */\nfunction slice_(x, begin, size) {\n    const $x = convertToTensor(x, 'x', 'slice', 'string_or_numeric');\n    if ($x.rank === 0) {\n        throw new Error('Slicing scalar is not possible');\n    }\n    const inputs = { x: $x };\n    const attrs = { begin, size };\n    return ENGINE.runKernel(Slice, inputs, attrs);\n}\nexport const slice = /* @__PURE__ */ op({ slice_ });\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWNvcmUvc3JjL29wcy9zbGljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sV0FBVyxDQUFDO0FBQ2pDLE9BQU8sRUFBQyxLQUFLLEVBQTBCLE1BQU0saUJBQWlCLENBQUM7QUFJL0QsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLG9CQUFvQixDQUFDO0FBR25ELE9BQU8sRUFBQyxFQUFFLEVBQUMsTUFBTSxhQUFhLENBQUM7QUFFL0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWlDRztBQUNILFNBQVMsTUFBTSxDQUNYLENBQWUsRUFBRSxLQUFzQixFQUFFLElBQXNCO0lBQ2pFLE1BQU0sRUFBRSxHQUFHLGVBQWUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO0lBRWpFLElBQUksRUFBRSxDQUFDLElBQUksS0FBSyxDQUFDLEVBQUU7UUFDakIsTUFBTSxJQUFJLEtBQUssQ0FBQyxnQ0FBZ0MsQ0FBQyxDQUFDO0tBQ25EO0lBRUQsTUFBTSxNQUFNLEdBQWdCLEVBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBQyxDQUFDO0lBQ3BDLE1BQU0sS0FBSyxHQUFlLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBQyxDQUFDO0lBRXhDLE9BQU8sTUFBTSxDQUFDLFNBQVMsQ0FDbkIsS0FBSyxFQUFFLE1BQW1DLEVBQzFDLEtBQWdDLENBQUMsQ0FBQztBQUN4QyxDQUFDO0FBRUQsTUFBTSxDQUFDLE1BQU0sS0FBSyxHQUFHLGVBQWUsQ0FBQyxFQUFFLENBQUMsRUFBQyxNQUFNLEVBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge0VOR0lORX0gZnJvbSAnLi4vZW5naW5lJztcbmltcG9ydCB7U2xpY2UsIFNsaWNlQXR0cnMsIFNsaWNlSW5wdXRzfSBmcm9tICcuLi9rZXJuZWxfbmFtZXMnO1xuaW1wb3J0IHtOYW1lZEF0dHJNYXB9IGZyb20gJy4uL2tlcm5lbF9yZWdpc3RyeSc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yJztcbmltcG9ydCB7TmFtZWRUZW5zb3JNYXB9IGZyb20gJy4uL3RlbnNvcl90eXBlcyc7XG5pbXBvcnQge2NvbnZlcnRUb1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yX3V0aWxfZW52JztcbmltcG9ydCB7UmFuaywgVGVuc29yTGlrZX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge29wfSBmcm9tICcuL29wZXJhdGlvbic7XG5cbi8qKlxuICogRXh0cmFjdHMgYSBzbGljZSBmcm9tIGEgYHRmLlRlbnNvcmAgc3RhcnRpbmcgYXQgY29vcmRpbmF0ZXMgYGJlZ2luYFxuICogYW5kIGlzIG9mIHNpemUgYHNpemVgLlxuICpcbiAqIEFsc28gYXZhaWxhYmxlIGFyZSBzdHJpY3RlciByYW5rLXNwZWNpZmljIG1ldGhvZHMgd2l0aCB0aGUgc2FtZSBzaWduYXR1cmVcbiAqIGFzIHRoaXMgbWV0aG9kIHRoYXQgYXNzZXJ0IHRoYXQgYHhgIGlzIG9mIHRoZSBnaXZlbiByYW5rOlxuICogICAtIGB0Zi5zbGljZTFkYFxuICogICAtIGB0Zi5zbGljZTJkYFxuICogICAtIGB0Zi5zbGljZTNkYFxuICogICAtIGB0Zi5zbGljZTRkYFxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCB4ID0gdGYudGVuc29yMWQoWzEsIDIsIDMsIDRdKTtcbiAqXG4gKiB4LnNsaWNlKFsxXSwgWzJdKS5wcmludCgpO1xuICogYGBgXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHggPSB0Zi50ZW5zb3IyZChbMSwgMiwgMywgNF0sIFsyLCAyXSk7XG4gKlxuICogeC5zbGljZShbMSwgMF0sIFsxLCAyXSkucHJpbnQoKTtcbiAqIGBgYFxuICogQHBhcmFtIHggVGhlIGlucHV0IGB0Zi5UZW5zb3JgIHRvIHNsaWNlIGZyb20uXG4gKiBAcGFyYW0gYmVnaW4gVGhlIGNvb3JkaW5hdGVzIHRvIHN0YXJ0IHRoZSBzbGljZSBmcm9tLiBUaGUgbGVuZ3RoIGNhbiBiZVxuICogICAgIGxlc3MgdGhhbiB0aGUgcmFuayBvZiB4IC0gdGhlIHJlc3Qgb2YgdGhlIGF4ZXMgd2lsbCBoYXZlIGltcGxpY2l0IDAgYXNcbiAqICAgICBzdGFydC4gQ2FuIGFsc28gYmUgYSBzaW5nbGUgbnVtYmVyLCBpbiB3aGljaCBjYXNlIGl0IHNwZWNpZmllcyB0aGVcbiAqICAgICBmaXJzdCBheGlzLlxuICogQHBhcmFtIHNpemUgVGhlIHNpemUgb2YgdGhlIHNsaWNlLiBUaGUgbGVuZ3RoIGNhbiBiZSBsZXNzIHRoYW4gdGhlIHJhbmsgb2ZcbiAqICAgICB4IC0gdGhlIHJlc3Qgb2YgdGhlIGF4ZXMgd2lsbCBoYXZlIGltcGxpY2l0IC0xLiBBIHZhbHVlIG9mIC0xIHJlcXVlc3RzXG4gKiAgICAgdGhlIHJlc3Qgb2YgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGF4aXMuIENhbiBhbHNvIGJlIGEgc2luZ2xlIG51bWJlcixcbiAqICAgICBpbiB3aGljaCBjYXNlIGl0IHNwZWNpZmllcyB0aGUgc2l6ZSBvZiB0aGUgZmlyc3QgYXhpcy5cbiAqXG4gKiBAZG9jIHtoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdTbGljaW5nIGFuZCBKb2luaW5nJ31cbiAqL1xuZnVuY3Rpb24gc2xpY2VfPFIgZXh0ZW5kcyBSYW5rLCBUIGV4dGVuZHMgVGVuc29yPFI+PihcbiAgICB4OiBUfFRlbnNvckxpa2UsIGJlZ2luOiBudW1iZXJ8bnVtYmVyW10sIHNpemU/OiBudW1iZXJ8bnVtYmVyW10pOiBUIHtcbiAgY29uc3QgJHggPSBjb252ZXJ0VG9UZW5zb3IoeCwgJ3gnLCAnc2xpY2UnLCAnc3RyaW5nX29yX251bWVyaWMnKTtcblxuICBpZiAoJHgucmFuayA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2xpY2luZyBzY2FsYXIgaXMgbm90IHBvc3NpYmxlJyk7XG4gIH1cblxuICBjb25zdCBpbnB1dHM6IFNsaWNlSW5wdXRzID0ge3g6ICR4fTtcbiAgY29uc3QgYXR0cnM6IFNsaWNlQXR0cnMgPSB7YmVnaW4sIHNpemV9O1xuXG4gIHJldHVybiBFTkdJTkUucnVuS2VybmVsKFxuICAgICAgU2xpY2UsIGlucHV0cyBhcyB1bmtub3duIGFzIE5hbWVkVGVuc29yTWFwLFxuICAgICAgYXR0cnMgYXMgdW5rbm93biBhcyBOYW1lZEF0dHJNYXApO1xufVxuXG5leHBvcnQgY29uc3Qgc2xpY2UgPSAvKiBAX19QVVJFX18gKi8gb3Aoe3NsaWNlX30pO1xuIl19","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from '../util';\nconst NEW_AXIS = -2;\nconst SHRINK_AXIS = -1;\nexport function assertParamsValid(input, begin, size) {\n    const inputRank = input.shape.length;\n    util.assert(inputRank === begin.length, () => `Error in slice${inputRank}D: Length of begin ${begin} must ` +\n        `match the rank of the array (${inputRank}).`);\n    util.assert(inputRank === size.length, () => `Error in slice${inputRank}D: Length of size ${size} must ` +\n        `match the rank of the array (${inputRank}).`);\n    for (let i = 0; i < inputRank; ++i) {\n        util.assert(begin[i] + size[i] <= input.shape[i], () => `Error in slice${inputRank}D: begin[${i}] + size[${i}] ` +\n            `(${begin[i] + size[i]}) would overflow input.shape[${i}] (${input.shape[i]})`);\n    }\n}\n/** Converts a binary mask to an array of axes. Used in stridedSlice(). */\nexport function maskToAxes(mask) {\n    const axes = [];\n    let axis = 0;\n    while (mask > 0) {\n        if (mask & 1) {\n            axes.push(axis);\n        }\n        mask /= 2;\n        axis++;\n    }\n    return axes;\n}\n/** Computes the output shape given the strided slice params. */\nexport function computeOutShape(begin, end, strides) {\n    const size = [];\n    for (let axis = 0; axis < begin.length; axis++) {\n        size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);\n    }\n    return size;\n}\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stride value. Otherwise, insert.\nexport function stridesWithElidedDims(strides, ellipsisInsertionIndex, numElidedAxes, inputShape) {\n    const newStrides = [...strides];\n    for (let i = newStrides.length; i < inputShape.length; i++) {\n        newStrides.push(1);\n    }\n    for (let i = 0; i < numElidedAxes; i++) {\n        if (i === 0) {\n            newStrides[ellipsisInsertionIndex] = 1;\n        }\n        else {\n            newStrides.splice(ellipsisInsertionIndex, 0 /* num elements to delete */, 1 /* element to add */);\n            newStrides.pop();\n        }\n    }\n    return newStrides;\n}\nfunction unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, normalizedAxis) {\n    if (normalizedAxis <= ellipsisInsertionIndex) {\n        return normalizedAxis;\n    }\n    return normalizedAxis - (numElidedAxes - 1);\n}\nfunction getElidedAxes(numElidedAxes, ellipsisInsertionIndex) {\n    const elidedAxes = [];\n    for (let i = 0; i < numElidedAxes; i++) {\n        elidedAxes.push(ellipsisInsertionIndex + i);\n    }\n    return elidedAxes;\n}\n// Normalize the start, end and strides.\nexport function getNormalizedAxes(inputShape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask) {\n    const inputRank = inputShape.length;\n    let normalizedBegin = new Array(inputRank), normalizedEnd = new Array(inputRank), normalizedStrides = new Array(inputRank);\n    if (ellipsisAxes.length && numInterpolatedAxes > 0) {\n        const fullIndex = ellipsisAxes[0];\n        // The ellipsis applies to the masked index as well as any dimensions\n        // that are interpolated.\n        const numElidedAxes = numInterpolatedAxes + 1;\n        normalizedBegin = startIndicesWithElidedDims(beginMask, fullIndex, numElidedAxes, begin, inputShape);\n        normalizedEnd = stopIndicesWithElidedDims(endMask, fullIndex, numElidedAxes, end, inputShape);\n        normalizedStrides =\n            stridesWithElidedDims(strides, fullIndex, numElidedAxes, inputShape);\n    }\n    else {\n        for (let axis = 0; axis < inputRank; axis++) {\n            normalizedBegin[axis] = startForAxis(beginMask, begin, strides, inputShape, axis, ellipsisMask);\n            normalizedEnd[axis] =\n                stopForAxis(endMask, end, strides, inputShape, axis, ellipsisMask);\n            normalizedStrides[axis] = stridesForAxis(strides, axis, ellipsisMask);\n        }\n    }\n    return {\n        begin: normalizedBegin,\n        end: normalizedEnd,\n        strides: normalizedStrides\n    };\n}\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current start value. Otherwise, insert.\nexport function startIndicesWithElidedDims(beginMask, ellipsisInsertionIndex, numElidedAxes, originalBegin, inputShape) {\n    const newIndices = [...inputShape];\n    const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n    for (let axis = 0; axis < newIndices.length; axis++) {\n        if (elidedAxes.indexOf(axis) > -1) {\n            newIndices[axis] = 0;\n        }\n        else {\n            const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n            let originalValue = originalBegin[originalAxis];\n            if (beginMask & 1 << originalAxis) {\n                originalValue = 0;\n            }\n            newIndices[axis] = originalValue;\n        }\n    }\n    return newIndices;\n}\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stop value. Otherwise, insert.\nexport function stopIndicesWithElidedDims(endMask, ellipsisInsertionIndex, numElidedAxes, originalEnd, inputShape) {\n    const newIndices = [...inputShape];\n    const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n    for (let axis = 0; axis < newIndices.length; axis++) {\n        if (elidedAxes.indexOf(axis) > -1) {\n            newIndices[axis] = Number.MAX_SAFE_INTEGER;\n        }\n        else {\n            const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n            let originalValue = originalEnd[originalAxis];\n            if (endMask & 1 << originalAxis) {\n                originalValue = Number.MAX_SAFE_INTEGER;\n            }\n            newIndices[axis] = originalValue;\n        }\n    }\n    for (let i = 0; i < newIndices.length; i++) {\n        // Handle negative indices\n        const axisSize = inputShape[i];\n        if (newIndices[i] < 0) {\n            newIndices[i] += axisSize;\n        }\n        newIndices[i] = util.clamp(0, newIndices[i], inputShape[i]);\n    }\n    return newIndices;\n}\nexport function stridesForAxis(strides, axis, ellipsisMask) {\n    let stride = strides[axis];\n    if (ellipsisMask & (1 << axis) || stride == null) {\n        stride = 1;\n    }\n    return stride;\n}\nexport function startForAxis(beginMask, startIndices, strides, inputShape, axis, ellipsisMask) {\n    // Begin with the specified index\n    let start = startIndices[axis];\n    const stride = strides[axis] || 1;\n    // Check the axis bit from right of masked axes, or the begin index is not set\n    // for the axis.\n    if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {\n        if (stride > 0) {\n            // Forward iteration - use the first element. These values will get\n            // clamped below (Note: We could have set them to 0 and axis_size-1, but\n            // use lowest() and max() to maintain symmetry with StopForAxis())\n            start = Number.MIN_SAFE_INTEGER;\n        }\n        else {\n            // Backward iteration - use the last element.\n            start = Number.MAX_SAFE_INTEGER;\n        }\n    }\n    // Handle negative indices\n    const axisSize = inputShape[axis];\n    if (start < 0) {\n        start += axisSize;\n    }\n    // Clamping\n    start = util.clamp(0, start, axisSize - 1);\n    return start;\n}\nexport function stopForAxis(endMask, stopIndices, strides, inputShape, axis, ellipsisMask) {\n    // Begin with the specified index\n    let stop = stopIndices[axis];\n    const stride = strides[axis] || 1;\n    // Check the axis bit from right of masked axes, or if the stop index is not\n    // set for this axis.\n    if (endMask & (1 << axis) || ellipsisMask & (1 << axis) || stop == null) {\n        if (stride > 0) {\n            // Forward iteration - use the last element. These values will get\n            // clamped below\n            stop = Number.MAX_SAFE_INTEGER;\n        }\n        else {\n            // Backward iteration - use the first element.\n            stop = Number.MIN_SAFE_INTEGER;\n        }\n    }\n    // Handle negative indices\n    const axisSize = inputShape[axis];\n    if (stop < 0) {\n        stop += axisSize;\n    }\n    // Clamping\n    // Because the end index points one past the last element, we need slightly\n    // different clamping ranges depending on the direction.\n    if (stride > 0) {\n        // Forward iteration\n        stop = util.clamp(0, stop, axisSize);\n    }\n    else {\n        // Backward iteration\n        stop = util.clamp(-1, stop, axisSize - 1);\n    }\n    return stop;\n}\n/**\n * Returns true if the slice occupies a continous set of elements in the\n * 'flat' space.\n */\nexport function isSliceContinous(shape, begin, size) {\n    // Index of the first axis that has size > 1.\n    let firstNonOneAxis = size.length;\n    for (let i = 0; i < size.length; i++) {\n        if (size[i] > 1) {\n            firstNonOneAxis = i;\n            break;\n        }\n    }\n    for (let i = firstNonOneAxis + 1; i < size.length; i++) {\n        if (begin[i] > 0 || size[i] !== shape[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function computeFlatOffset(begin, strides) {\n    let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;\n    for (let i = 0; i < begin.length - 1; i++) {\n        flatOffset += begin[i] * strides[i];\n    }\n    return flatOffset;\n}\nexport function parseSliceParams(x, begin, size) {\n    // The following logic allows for more ergonomic calls.\n    let begin_;\n    const xRank = x.shape.length;\n    if (typeof begin === 'number') {\n        begin_ = [begin, ...new Array(xRank - 1).fill(0)];\n    }\n    else if (begin.length < xRank) {\n        begin_ = begin.concat(new Array(xRank - begin.length).fill(0));\n    }\n    else {\n        begin_ = begin.slice();\n    }\n    begin_.forEach(d => {\n        util.assert(d !== -1, () => 'slice() does not support negative begin indexing.');\n    });\n    let size_;\n    if (size == null) {\n        size_ = new Array(xRank).fill(-1);\n    }\n    else if (typeof size === 'number') {\n        size_ = [size, ...new Array(xRank - 1).fill(-1)];\n    }\n    else if (size.length < xRank) {\n        size_ = size.concat(new Array(xRank - size.length).fill(-1));\n    }\n    else {\n        size_ = size;\n    }\n    size_ = size_.map((d, i) => {\n        if (d >= 0) {\n            return d;\n        }\n        else {\n            util.assert(d === -1, () => `Negative size values should be exactly -1 but got ` +\n                `${d} for the slice() size at index ${i}.`);\n            return x.shape[i] - begin_[i];\n        }\n    });\n    return [begin_, size_];\n}\n// Convert the slicing specification from a sparse representation to a dense\n// representation. This means that all ellipses and newaxis are expanded out.\nexport function sliceInfo(xShape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {\n    let stridesNonNull;\n    if (strides == null) {\n        stridesNonNull = new Array(begin.length);\n        stridesNonNull.fill(1);\n    }\n    else {\n        stridesNonNull = strides;\n    }\n    // Only one non-zero bit is allowed in ellipsisMask, which means ellipsisMask\n    // is a power of 2. Use bit compares to ensure ellipsisMask is 0 or a power\n    // of 2. When i is a power of 2, i & (i - 1) is always 0.\n    // Also ref:\n    // https://stackoverflow.com/questions/600293/how-to-check-if-a-number-is-a-power-of-2\n    if (ellipsisMask != null && (ellipsisMask & (ellipsisMask - 1)) !== 0) {\n        throw new Error('Multiple ellipses in slice is not allowed.');\n    }\n    // Step 1: Account for ellipsis and new axis.\n    // Check for ellipsis and count how many non-newaxis there are after.\n    let ellipsisSeen = false;\n    const sparseSpec = {\n        dims: stridesNonNull.length,\n        numAddAxisAfterEllipsis: 0,\n        begin: begin.slice(),\n        end: end.slice(),\n        strides: stridesNonNull.slice(),\n        beginMask,\n        endMask,\n        ellipsisMask,\n        newAxisMask,\n        shrinkAxisMask\n    };\n    for (let i = 0; i < sparseSpec.dims; i++) {\n        if (ellipsisSeen && ((1 << i) & newAxisMask) !== 0) {\n            sparseSpec.numAddAxisAfterEllipsis++;\n        }\n        if ((1 << i) & ellipsisMask) {\n            ellipsisSeen = true;\n        }\n    }\n    // If no ellipsis insert one at the end.\n    if (!ellipsisSeen) {\n        sparseSpec.ellipsisMask |= (1 << sparseSpec.dims);\n        sparseSpec.dims++; // this effects loop iteration below\n    }\n    // Step 2: Make a sparse spec into a full index spec.\n    //\n    // The sparse spec deos not correspond to the number of dimensions.\n    // Make a dense spec that cooresponds to the number of dimensions.\n    //\n    // For example suppose foo[...,3:] on foo.shape = [2, 2, 3] then we need to\n    // produce the missing beginMask for the first two dimensions i.e. from\n    // beginMaskSpec = 0, endMaskSpec = 2, we achieve beginMask = 6 (110),\n    // endMask = 7 (111).\n    const denseSpec = {\n        dims: xShape.length,\n        beginMask: 0,\n        endMask: 0,\n        beginValid: false,\n        endValid: false\n    };\n    buildDenseSpec(sparseSpec, denseSpec);\n    // Step 3: Make implicit ranges (non-zero beginMasks and endMasks) explicit\n    // and bounds check.\n    let isIdentity = true;\n    let sliceDim0 = true;\n    let isSimpleSlice = true;\n    const processingShape = [];\n    const finalShape = [];\n    for (let i = 0; i < xShape.length; ++i) {\n        if (denseSpec.strides[i] === 0) {\n            throw Error(`strides[${i}] must be non-zero`);\n        }\n        const shrinkI = !!(denseSpec.shrinkAxisMask & (1 << i));\n        const dimI = xShape[i];\n        if (dimI === -1) {\n            processingShape.push(shrinkI ? 1 : -1);\n            continue;\n        }\n        const masks = [denseSpec.beginMask & (1 << i), denseSpec.endMask & (1 << i)];\n        const validRange = [\n            denseSpec.strides[i] > 0 ? 0 : -1,\n            denseSpec.strides[i] > 0 ? dimI : dimI - 1\n        ];\n        if (shrinkI && denseSpec.strides[i] <= 0) {\n            throw Error('only stride 1 allowed on non-range indexing.');\n        }\n        isSimpleSlice = isSimpleSlice && (denseSpec.strides[i] === 1);\n        const beginAndEndMasked = !!((denseSpec.beginMask & (1 << i)) && (denseSpec.endMask & (1 << i)));\n        if (denseSpec.beginValid && denseSpec.endValid) {\n            if (shrinkI) {\n                // If we are shrinking, the end index is now possibly incorrect. In\n                // particular foo[-1] produces sparseBegin = -1, sparseEnd = 0.\n                // and canonical puts these to n-1 and 0, which implies a degenerate\n                // interval. Fortunately, it is now safe to re-create end as begin + 1.\n                const xFwd = denseSpec.begin[i] < 0 ? dimI + denseSpec.begin[i] :\n                    denseSpec.begin[i];\n                denseSpec.begin[i] = xFwd;\n                denseSpec.end[i] = denseSpec.begin[i] + 1;\n                if (xFwd < 0 || xFwd >= dimI) {\n                    throw Error(`slice index ${denseSpec.begin[i]} of dimension ${i} out of bounds.`);\n                }\n            }\n            else {\n                denseSpec.begin[i] = canonical(denseSpec.begin[i], 0, denseSpec.strides[i], dimI, masks, validRange);\n                denseSpec.end[i] = canonical(denseSpec.end[i], 1, denseSpec.strides[i], dimI, masks, validRange);\n            }\n            // Update optimization values\n            const takeAllInDimension = denseSpec.strides[i] === 1 &&\n                denseSpec.begin[i] === 0 && denseSpec.end[i] === dimI;\n            isIdentity = isIdentity && takeAllInDimension;\n            sliceDim0 = sliceDim0 &&\n                ((i === 0 && denseSpec.strides[i] === 1) || takeAllInDimension);\n        }\n        else {\n            isIdentity =\n                isIdentity && ((denseSpec.strides[i] === 1) && beginAndEndMasked);\n            sliceDim0 = sliceDim0 &&\n                ((i === 0 && denseSpec.strides[i] === 1) || beginAndEndMasked);\n        }\n        // Compute the processing shape (the intermediate Eigen will produce)\n        let intervalLength;\n        let knownInterval = false;\n        if (denseSpec.beginValid && denseSpec.endValid) {\n            intervalLength = denseSpec.end[i] - denseSpec.begin[i];\n            knownInterval = true;\n        }\n        else if (shrinkI) {\n            // The dimension is still known as 1 for the processingShape, but will be\n            // discarded for the final shape.\n            intervalLength = 1;\n            knownInterval = true;\n        }\n        else if (beginAndEndMasked) {\n            // Even if we don't have values for begin or end, we do know that this\n            // dimension covers the whole interval. If we have shape information for\n            // this dimension, that tells us the interval length.\n            if (dimI >= 0) {\n                if (denseSpec.strides[i] < 0) {\n                    intervalLength = -dimI;\n                }\n                else {\n                    intervalLength = dimI;\n                }\n                knownInterval = true;\n            }\n        }\n        if (knownInterval) {\n            let sizeI;\n            // Hold zero if the interval is degenerate, otherwise account for\n            // remainder\n            if (intervalLength === 0 ||\n                ((intervalLength < 0) !== (denseSpec.strides[i] < 0))) {\n                sizeI = 0;\n            }\n            else {\n                sizeI = Math.trunc(intervalLength / denseSpec.strides[i]) +\n                    (intervalLength % denseSpec.strides[i] !== 0 ? 1 : 0);\n            }\n            processingShape.push(sizeI);\n        }\n        else {\n            processingShape.push(-1);\n        }\n    }\n    // Step 4: Compute the final shape\n    //\n    // newAxis will increase dimension by 1 (with a one-size dimension)\n    // slices like foo[3, ...] will reduce dimension by 1.\n    // This cannot be done earlier, because it depends on Step 3.\n    for (let denseDim = 0; denseDim < denseSpec.finalShapeGatherIndices.length; ++denseDim) {\n        const gatherIndex = denseSpec.finalShapeGatherIndices[denseDim];\n        if (gatherIndex >= 0) {\n            finalShape.push(processingShape[gatherIndex]);\n        }\n        else if (gatherIndex === NEW_AXIS) {\n            finalShape.push(1);\n        }\n    }\n    const finalShapeSparse = finalShape.filter((dim, i) => denseSpec.finalShapeGatherIndices[i] !== NEW_AXIS);\n    return {\n        finalShapeSparse,\n        finalShape,\n        isIdentity,\n        sliceDim0,\n        isSimpleSlice,\n        begin: denseSpec.begin,\n        end: denseSpec.end,\n        strides: denseSpec.strides\n    };\n}\nfunction buildDenseSpec(sparse, dense) {\n    dense.beginMask = 0;\n    dense.endMask = 0;\n    dense.shrinkAxisMask = 0;\n    let fullIndex = 0;\n    dense.beginValid = sparse.begin != null;\n    dense.endValid = sparse.end != null;\n    dense.begin = new Array(dense.dims);\n    dense.end = new Array(dense.dims);\n    dense.strides = new Array(dense.dims);\n    dense.finalShapeGatherIndices = [];\n    dense.finalShapeGatherIndicesSparse = [];\n    dense.inputShapeGatherIndicesSparse = new Array(dense.dims);\n    for (let i = 0; i < sparse.dims; i++) {\n        if ((1 << i) & sparse.ellipsisMask) {\n            // Only the bit that has ellipsis will fall in this condition.\n            // Expand the ellipsis into the appropriate indices\n            // Note: this only works because we guaranteed one ellipsis.\n            const nextIndex = Math.min(dense.dims - (sparse.dims - i) + 1 + sparse.numAddAxisAfterEllipsis, dense.dims);\n            for (; fullIndex < nextIndex; fullIndex++) {\n                // newAxis aren't real axis so you have to skip.\n                dense.begin[fullIndex] = 0;\n                dense.end[fullIndex] = 0;\n                dense.strides[fullIndex] = 1;\n                dense.beginMask |= (1 << fullIndex);\n                dense.endMask |= (1 << fullIndex);\n                dense.finalShapeGatherIndices.push(fullIndex);\n                dense.finalShapeGatherIndicesSparse.push(-1);\n                dense.inputShapeGatherIndicesSparse[fullIndex] = i;\n            }\n        }\n        else if ((1 << i) & sparse.newAxisMask) {\n            // Only the bit that has newAxis will fall in this condition.\n            dense.finalShapeGatherIndices.push(NEW_AXIS);\n            dense.finalShapeGatherIndicesSparse.push(-1);\n        }\n        else {\n            if (fullIndex === dense.begin.length) {\n                throw Error(`Index out of range using input dim ${fullIndex}; input ` +\n                    `has only ${dense.dims} dims, ${dense.begin.length}.`);\n            }\n            // Gather slicing spec into appropriate index.\n            if (sparse.begin != null) {\n                dense.begin[fullIndex] = sparse.begin[i];\n            }\n            if (sparse.end != null) {\n                dense.end[fullIndex] = sparse.end[i];\n            }\n            dense.strides[fullIndex] = sparse.strides[i];\n            if (sparse.beginMask & (1 << i)) {\n                dense.beginMask |= (1 << fullIndex);\n            }\n            if (sparse.endMask & (1 << i)) {\n                dense.endMask |= (1 << fullIndex);\n            }\n            // If shrink, record where to get the dimensionality from (i.e. newAxis)\n            // creates a fake 1 size dimension. Also remember shrink axis (now in\n            // dense form) so we can ignore dense.end below.\n            if (sparse.shrinkAxisMask & (1 << i)) {\n                dense.finalShapeGatherIndices.push(SHRINK_AXIS);\n                dense.finalShapeGatherIndicesSparse.push(-1);\n                dense.shrinkAxisMask |= (1 << fullIndex);\n            }\n            else {\n                dense.finalShapeGatherIndices.push(fullIndex);\n                // Remember that where in the sparse shape the dense dim comes from.\n                dense.finalShapeGatherIndicesSparse.push(i);\n            }\n            dense.inputShapeGatherIndicesSparse[fullIndex] = i;\n            fullIndex++;\n        }\n    }\n}\nfunction canonical(x, c, strideI, dimI, masks, validRange) {\n    if (masks[c]) {\n        return strideI > 0 ? validRange[c] : validRange[(c + 1) & 1];\n    }\n    else {\n        const xFwd = x < 0 ? dimI + x : x; // make negative indices positive\n        return xFwd < validRange[0] ? validRange[0] :\n            xFwd > validRange[1] ? validRange[1] : xFwd;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpY2VfdXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtY29yZS9zcmMvb3BzL3NsaWNlX3V0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBR0gsT0FBTyxLQUFLLElBQUksTUFBTSxTQUFTLENBQUM7QUFFaEMsTUFBTSxRQUFRLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDcEIsTUFBTSxXQUFXLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUE2RHZCLE1BQU0sVUFBVSxpQkFBaUIsQ0FDN0IsS0FBaUIsRUFBRSxLQUFlLEVBQUUsSUFBYztJQUNwRCxNQUFNLFNBQVMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQztJQUNyQyxJQUFJLENBQUMsTUFBTSxDQUNQLFNBQVMsS0FBSyxLQUFLLENBQUMsTUFBTSxFQUMxQixHQUFHLEVBQUUsQ0FBQyxpQkFBaUIsU0FBUyxzQkFBc0IsS0FBSyxRQUFRO1FBQy9ELGdDQUFnQyxTQUFTLElBQUksQ0FBQyxDQUFDO0lBQ3ZELElBQUksQ0FBQyxNQUFNLENBQ1AsU0FBUyxLQUFLLElBQUksQ0FBQyxNQUFNLEVBQ3pCLEdBQUcsRUFBRSxDQUFDLGlCQUFpQixTQUFTLHFCQUFxQixJQUFJLFFBQVE7UUFDN0QsZ0NBQWdDLFNBQVMsSUFBSSxDQUFDLENBQUM7SUFFdkQsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFNBQVMsRUFBRSxFQUFFLENBQUMsRUFBRTtRQUNsQyxJQUFJLENBQUMsTUFBTSxDQUNQLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFDcEMsR0FBRyxFQUFFLENBQUMsaUJBQWlCLFNBQVMsWUFBWSxDQUFDLFlBQVksQ0FBQyxJQUFJO1lBQzFELElBQUksS0FBSyxDQUFD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UyxDQUFDLENBQUM7Z0JBQzlDLG9FQUFvRTtnQkFDcEUsS0FBSyxDQUFDLDZCQUE2QixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUM3QztZQUNELEtBQUssQ0FBQyw2QkFBNkIsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDbkQsU0FBUyxFQUFFLENBQUM7U0FDYjtLQUNGO0FBQ0gsQ0FBQztBQUVELFNBQVMsU0FBUyxDQUNkLENBQVMsRUFBRSxDQUFTLEVBQUUsT0FBZSxFQUFFLElBQVksRUFBRSxLQUFlLEVBQ3BFLFVBQW9CO0lBQ3RCLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQ1osT0FBTyxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztLQUM5RDtTQUFNO1FBQ0wsTUFBTSxJQUFJLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUUsaUNBQWlDO1FBQ3JFLE9BQU8sSUFBSSxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDZixJQUFJLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztLQUMzRTtBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7IFRlbnNvckluZm8gfSBmcm9tICcuLi90ZW5zb3JfaW5mbyc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwnO1xuXG5jb25zdCBORVdfQVhJUyA9IC0yO1xuY29uc3QgU0hSSU5LX0FYSVMgPSAtMTtcblxuLy8gU3BhcnNlIHNsaWNpbmcgc3BlY2lmaWNhdGlvblxuLy8gaWYgb25lIGRvZXMgZm9vWzM6NSwgLi4uLCAtM10sIHRoZSBiZWdpbiwgZW5kIGFuZCBzdHJpZGVzIHdpbGwgaGF2ZSBsZW5ndGhcbi8vIG9mIDMuXG5pbnRlcmZhY2UgU3RyaWRlZFNsaWNlU3BhcnNlU3BlYyB7XG4gIGRpbXM6IG51bWJlcjtcbiAgbnVtQWRkQXhpc0FmdGVyRWxsaXBzaXM6IG51bWJlcjtcbiAgYmVnaW46IG51bWJlcltdO1xuICBlbmQ6IG51bWJlcltdO1xuICBzdHJpZGVzOiBudW1iZXJbXTtcbiAgYmVnaW5NYXNrOiBudW1iZXI7XG4gIGVuZE1hc2s6IG51bWJlcjtcbiAgZWxsaXBzaXNNYXNrOiBudW1iZXI7XG4gIG5ld0F4aXNNYXNrOiBudW1iZXI7XG4gIHNocmlua0F4aXNNYXNrOiBudW1iZXI7XG59XG5cbi8vIERlbnNlIHNsaWNpbmcgc3BlY2lmaWNhdGlvblxuLy8gYWxsIGVsbGlwc2VzIGFuZCBuZXdheGlzIGFyZSBleHBhbmRlZCBvdXQuIFNvIGlmIGZvb1szOjUsIC4uLiwgLTNdIHdoZXJlIGZvb1xuLy8gaXMgMTAgZGltZW5zaW9uYWwsIGVhY2ggYXJyYXkgb2YgYmVnaW4sIGVuZCwgc3RyaWRlcyB3aWxsIGhhdmUgMTAgZW50cmllc1xuLy8gd2hlcmUgYXMgdGhlIHNwYXJzZSBjYW4gaGF2ZSBsZW5ndGggbGVzcyB0aGFuIHRoZSByYW5rIG9mIGZvby5cbmludGVyZmFjZSBTdHJpZGVkU2xpY2VEZW5zZVNwZWMge1xuICBkaW1zOiBudW1iZXI7XG4gIGJlZ2luTWFzaz86IG51bWJlcjtcbiAgZW5kTWFzaz86IG51bWJlcjtcbiAgYmVnaW5WYWxpZDogYm9vbGVhbjtcbiAgZW5kVmFsaWQ6IGJvb2xlYW47XG4gIGJlZ2luPzogbnVtYmVyW107XG4gIGVuZD86IG51bWJlcltdO1xuICBzdHJpZGVzPzogbnVtYmVyW107XG4gIC8vIFRoaXMgYXJyYXkgaGVscHMgY29uc3RydWN0IHRoZSBmaW5hbCBzaGFwZSBvZiB0aGUgc2xpY2UuXG4gIC8vIFRoZSBmaW5hbCB0ZW5zb3IgaXMgcmVkdWNlZCBpbiByYW5rIHdoZW5ldmVyIGEgc2luZ2xlIGluZGV4IGUuZy4gZm9vWzNdXG4gIC8vIGlzIGNhbGxlZCBmb3IuIFRoZSBmaW5hbCB0ZW5zb3IgaW5jcmVhc2VzIGluIHJhbmsgd2l0aCBuZXdBeGlzIGVudHJpZXMuXG4gIC8vIElmIGFuIGluZGV4IGluIHRoaXMgYXJyYXkgaXMgcG9zaXRpdmUsIHRoZSBzaXplIG9mIHRoZSBkaW1lbnNpb24gaXNcbiAgLy8gb2J0YWluZWQgZnJvbSBjYW5vbmljYWwgZW5kLWJlZ2luLiAgT3RoZXJ3aXNlLCBpZiBpdCBpcyBhIE5FV19BWElTLCBpdCB3aWxsXG4gIC8vIGJlIDEuIEEgc2hydW5rIGRpbWVuc2lvbiBpcyBza2lwcGVkLlxuICBmaW5hbFNoYXBlR2F0aGVySW5kaWNlcz86IG51bWJlcltdO1xuICAvLyBUaGlzIGFycmF5IGhhcyB0aGUgc2FtZSBzaXplIGFzIGZpbmFsU2hhcGVHYXRoZXJJbmRpY2VzLCBidXQgaXQgcmVtZW1iZXJzXG4gIC8vIHRoZSBzcGFyc2UgaW5kZXggdGhhdCBhIGRpbWVuc2lvbiBjb21lcyBmcm9tLCBpbnN0ZWFkIG9mIGRlbnNlIGluZGV4LlxuICAvLyBBIC0xIGluIHRoaXMgdmVjdG9yIG1lYW5zIHRoZSBpbmRleCBpcyBub3QgZnJvbSB0aGUgc3BhcnNlIGlucHV0LlxuICBmaW5hbFNoYXBlR2F0aGVySW5kaWNlc1NwYXJzZT86IG51bWJlcltdO1xuICBpbnB1dFNoYXBlR2F0aGVySW5kaWNlc1NwYXJzZT86IG51bWJlcltdO1xuICAvLyBUaGUgZGVuc2UgaW5kZXhlZCBzaHJpbmsgbWFzayBpcyB3aGljaCBwcm9jZXNzaW5nIGRpbWVuc2lvbnMgc2hvdWxkIGJlXG4gIC8vIHNocnVuay4gRm9yIGV4YW1wbGUsIGlmIGZvby5zaGFwZSA9IFsxMCwgMTAsIDEwLCAxMF0sIGZvb1szLCAuLi4sIDVdIGhhc1xuICAvLyBzcGFyc2VTaHJpbmtBeGlzTWFzayBvZiA1ICgwMTAxKSBhbmQgZGVuc2VTaHJpbmtBeGlzTWFzayBvZiA5ICgxMDAxKSxcbiAgLy8geWllbGRpbmcgYSBmaW5hbCBzaGFwZSBbMTAsIDEwXS5cbiAgc2hyaW5rQXhpc01hc2s/OiBudW1iZXI7XG59XG5cbmV4cG9ydCB0eXBlIFNsaWNlSW5mbyA9IHtcbiAgZmluYWxTaGFwZVNwYXJzZTogbnVtYmVyW10sXG4gIGZpbmFsU2hhcGU6IG51bWJlcltdLFxuICBpc0lkZW50aXR5OiBib29sZWFuLFxuICBzbGljZURpbTA6IGJvb2xlYW4sXG4gIGlzU2ltcGxlU2xpY2U6IGJvb2xlYW4sXG4gIGJlZ2luOiBudW1iZXJbXSxcbiAgZW5kOiBudW1iZXJbXSxcbiAgc3RyaWRlczogbnVtYmVyW11cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRQYXJhbXNWYWxpZChcbiAgICBpbnB1dDogVGVuc29ySW5mbywgYmVnaW46IG51bWJlcltdLCBzaXplOiBudW1iZXJbXSk6IHZvaWQge1xuICBjb25zdCBpbnB1dFJhbmsgPSBpbnB1dC5zaGFwZS5sZW5ndGg7XG4gIHV0aWwuYXNzZXJ0KFxuICAgICAgaW5wdXRSYW5rID09PSBiZWdpbi5sZW5ndGgsXG4gICAgICAoKSA9PiBgRXJyb3IgaW4gc2xpY2Uke2lucHV0UmFua31EOiBMZW5ndGggb2YgYmVnaW4gJHtiZWdpbn0gbXVzdCBgICtcbiAgICAgICAgICBgbWF0Y2ggdGhlIHJhbmsgb2YgdGhlIGFycmF5ICgke2lucHV0UmFua30pLmApO1xuICB1dGlsLmFzc2VydChcbiAgICAgIGlucHV0UmFuayA9PT0gc2l6ZS5sZW5ndGgsXG4gICAgICAoKSA9PiBgRXJyb3IgaW4gc2xpY2Uke2lucHV0UmFua31EOiBMZW5ndGggb2Ygc2l6ZSAke3NpemV9IG11c3QgYCArXG4gICAgICAgICAgYG1hdGNoIHRoZSByYW5rIG9mIHRoZSBhcnJheSAoJHtpbnB1dFJhbmt9KS5gKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0UmFuazsgKytpKSB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIGJlZ2luW2ldICsgc2l6ZVtpXSA8PSBpbnB1dC5zaGFwZVtpXSxcbiAgICAgICAgKCkgPT4gYEVycm9yIGluIHNsaWNlJHtpbnB1dFJhbmt9RDogYmVnaW5bJHtpfV0gKyBzaXplWyR7aX1dIGAgK1xuICAgICAgICAgICAgYCgke2JlZ2luW2ldICsgc2l6ZVtpXX0pIHdvdWxkIG92ZXJmbG93IGlucHV0LnNoYXBlWyR7aX1dICgke1xuICAgICAgICAgICAgICAgICAgaW5wdXQuc2hhcGVbaV19KWApO1xuICB9XG59XG5cbi8qKiBDb252ZXJ0cyBhIGJpbmFyeSBtYXNrIHRvIGFuIGFycmF5IG9mIGF4ZXMuIFVzZWQgaW4gc3RyaWRlZFNsaWNlKCkuICovXG5leHBvcnQgZnVuY3Rpb24gbWFza1RvQXhlcyhtYXNrOiBudW1iZXIpOiBudW1iZXJbXSB7XG4gIGNvbnN0IGF4ZXMgPSBbXTtcbiAgbGV0IGF4aXMgPSAwO1xuICB3aGlsZSAobWFzayA+IDApIHtcbiAgICBpZiAobWFzayAmIDEpIHtcbiAgICAgIGF4ZXMucHVzaChheGlzKTtcbiAgICB9XG4gICAgbWFzayAvPSAyO1xuICAgIGF4aXMrKztcbiAgfVxuICByZXR1cm4gYXhlcztcbn1cblxuLyoqIENvbXB1dGVzIHRoZSBvdXRwdXQgc2hhcGUgZ2l2ZW4gdGhlIHN0cmlkZWQgc2xpY2UgcGFyYW1zLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVPdXRTaGFwZShcbiAgICBiZWdpbjogbnVtYmVyW10sIGVuZDogbnVtYmVyW10sIHN0cmlkZXM6IG51bWJlcltdKTogbnVtYmVyW10ge1xuICBjb25zdCBzaXplID0gW107XG4gIGZvciAobGV0IGF4aXMgPSAwOyBheGlzIDwgYmVnaW4ubGVuZ3RoOyBheGlzKyspIHtcbiAgICBzaXplW2F4aXNdID0gTWF0aC5jZWlsKChlbmRbYXhpc10gLSBiZWdpbltheGlzXSkgLyBzdHJpZGVzW2F4aXNdKTtcbiAgfVxuICByZXR1cm4gc2l6ZTtcbn1cblxuLy8gQ3JlYXRlcyBmdWxsIHNlbGVjdGlvbiBhdCB0aGUgZWxpZGVkIGRpbWVuc2lvbnMuIElmIHRoZSBkaW1lbnNpb24gbWF0Y2hlc1xuLy8gdGhlIGVsbGlwc2lzIG1hc2ssIG92ZXJyaWRlIHRoZSBjdXJyZW50IHN0cmlkZSB2YWx1ZS4gT3RoZXJ3aXNlLCBpbnNlcnQuXG5leHBvcnQgZnVuY3Rpb24gc3RyaWRlc1dpdGhFbGlkZWREaW1zKFxuICAgIHN0cmlkZXM6IG51bWJlcltdLCBlbGxpcHNpc0luc2VydGlvbkluZGV4OiBudW1iZXIsIG51bUVsaWRlZEF4ZXM6IG51bWJlcixcbiAgICBpbnB1dFNoYXBlOiBudW1iZXJbXSk6IG51bWJlcltdIHtcbiAgY29uc3QgbmV3U3RyaWRlcyA9IFsuLi5zdHJpZGVzXTtcbiAgZm9yIChsZXQgaSA9IG5ld1N0cmlkZXMubGVuZ3RoOyBpIDwgaW5wdXRTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgIG5ld1N0cmlkZXMucHVzaCgxKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUVsaWRlZEF4ZXM7IGkrKykge1xuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBuZXdTdHJpZGVzW2VsbGlwc2lzSW5zZXJ0aW9uSW5kZXhdID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U3RyaWRlcy5zcGxpY2UoXG4gICAgICAgICAgZWxsaXBzaXNJbnNlcnRpb25JbmRleCwgMCAvKiBudW0gZWxlbWVudHMgdG8gZGVsZXRlICovLFxuICAgICAgICAgIDEgLyogZWxlbWVudCB0byBhZGQgKi8pO1xuICAgICAgbmV3U3RyaWRlcy5wb3AoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld1N0cmlkZXM7XG59XG5cbmZ1bmN0aW9uIHVubm9ybWFsaXplQXhpcyhcbiAgICBlbGxpcHNpc0luc2VydGlvbkluZGV4OiBudW1iZXIsIG51bUVsaWRlZEF4ZXM6IG51bWJlcixcbiAgICBub3JtYWxpemVkQXhpczogbnVtYmVyKTogbnVtYmVyIHtcbiAgaWYgKG5vcm1hbGl6ZWRBeGlzIDw9IGVsbGlwc2lzSW5zZXJ0aW9uSW5kZXgpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplZEF4aXM7XG4gIH1cblxuICByZXR1cm4gbm9ybWFsaXplZEF4aXMgLSAobnVtRWxpZGVkQXhlcyAtIDEpO1xufVxuXG5mdW5jdGlvbiBnZXRFbGlkZWRBeGVzKG51bUVsaWRlZEF4ZXM6IG51bWJlciwgZWxsaXBzaXNJbnNlcnRpb25JbmRleDogbnVtYmVyKSB7XG4gIGNvbnN0IGVsaWRlZEF4ZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1FbGlkZWRBeGVzOyBpKyspIHtcbiAgICBlbGlkZWRBeGVzLnB1c2goZWxsaXBzaXNJbnNlcnRpb25JbmRleCArIGkpO1xuICB9XG4gIHJldHVybiBlbGlkZWRBeGVzO1xufVxuXG4vLyBOb3JtYWxpemUgdGhlIHN0YXJ0LCBlbmQgYW5kIHN0cmlkZXMuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZEF4ZXMoXG4gICAgaW5wdXRTaGFwZTogbnVtYmVyW10sIGVsbGlwc2lzQXhlczogbnVtYmVyW10sIG51bUludGVycG9sYXRlZEF4ZXM6IG51bWJlcixcbiAgICBiZWdpbjogbnVtYmVyW10sIGVuZDogbnVtYmVyW10sIHN0cmlkZXM6IG51bWJlcltdLCBiZWdpbk1hc2s6IG51bWJlcixcbiAgICBlbmRNYXNrOiBudW1iZXIsXG4gICAgZWxsaXBzaXNNYXNrOiBudW1iZXIpOiB7YmVnaW46IG51bWJlcltdLCBlbmQ6IG51bWJlcltdLCBzdHJpZGVzOiBudW1iZXJbXX0ge1xuICBjb25zdCBpbnB1dFJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcbiAgbGV0IG5vcm1hbGl6ZWRCZWdpbiA9IG5ldyBBcnJheShpbnB1dFJhbmspLFxuICAgICAgbm9ybWFsaXplZEVuZCA9IG5ldyBBcnJheShpbnB1dFJhbmspLFxuICAgICAgbm9ybWFsaXplZFN0cmlkZXMgPSBuZXcgQXJyYXkoaW5wdXRSYW5rKTtcbiAgaWYgKGVsbGlwc2lzQXhlcy5sZW5ndGggJiYgbnVtSW50ZXJwb2xhdGVkQXhlcyA+IDApIHtcbiAgICBjb25zdCBmdWxsSW5kZXggPSBlbGxpcHNpc0F4ZXNbMF07XG5cbiAgICAvLyBUaGUgZWxsaXBzaXMgYXBwbGllcyB0byB0aGUgbWFza2VkIGluZGV4IGFzIHdlbGwgYXMgYW55IGRpbWVuc2lvbnNcbiAgICAvLyB0aGF0IGFyZSBpbnRlcnBvbGF0ZWQuXG4gICAgY29uc3QgbnVtRWxpZGVkQXhlcyA9IG51bUludGVycG9sYXRlZEF4ZXMgKyAxO1xuICAgIG5vcm1hbGl6ZWRCZWdpbiA9IHN0YXJ0SW5kaWNlc1dpdGhFbGlkZWREaW1zKFxuICAgICAgICBiZWdpbk1hc2ssIGZ1bGxJbmRleCwgbnVtRWxpZGVkQXhlcywgYmVnaW4sIGlucHV0U2hhcGUpO1xuICAgIG5vcm1hbGl6ZWRFbmQgPSBzdG9wSW5kaWNlc1dpdGhFbGlkZWREaW1zKFxuICAgICAgICBlbmRNYXNrLCBmdWxsSW5kZXgsIG51bUVsaWRlZEF4ZXMsIGVuZCwgaW5wdXRTaGFwZSk7XG4gICAgbm9ybWFsaXplZFN0cmlkZXMgPVxuICAgICAgICBzdHJpZGVzV2l0aEVsaWRlZERpbXMoc3RyaWRlcywgZnVsbEluZGV4LCBudW1FbGlkZWRBeGVzLCBpbnB1dFNoYXBlKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCBheGlzID0gMDsgYXhpcyA8IGlucHV0UmFuazsgYXhpcysrKSB7XG4gICAgICBub3JtYWxpemVkQmVnaW5bYXhpc10gPSBzdGFydEZvckF4aXMoXG4gICAgICAgICAgYmVnaW5NYXNrLCBiZWdpbiwgc3RyaWRlcywgaW5wdXRTaGFwZSwgYXhpcywgZWxsaXBzaXNNYXNrKTtcbiAgICAgIG5vcm1hbGl6ZWRFbmRbYXhpc10gPVxuICAgICAgICAgIHN0b3BGb3JBeGlzKGVuZE1hc2ssIGVuZCwgc3RyaWRlcywgaW5wdXRTaGFwZSwgYXhpcywgZWxsaXBzaXNNYXNrKTtcbiAgICAgIG5vcm1hbGl6ZWRTdHJpZGVzW2F4aXNdID0gc3RyaWRlc0ZvckF4aXMoc3RyaWRlcywgYXhpcywgZWxsaXBzaXNNYXNrKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJlZ2luOiBub3JtYWxpemVkQmVnaW4sXG4gICAgZW5kOiBub3JtYWxpemVkRW5kLFxuICAgIHN0cmlkZXM6IG5vcm1hbGl6ZWRTdHJpZGVzXG4gIH07XG59XG5cbi8vIENyZWF0ZXMgZnVsbCBzZWxlY3Rpb24gYXQgdGhlIGVsaWRlZCBkaW1lbnNpb25zLiBJZiB0aGUgZGltZW5zaW9uIG1hdGNoZXNcbi8vIHRoZSBlbGxpcHNpcyBtYXNrLCBvdmVycmlkZSB0aGUgY3VycmVudCBzdGFydCB2YWx1ZS4gT3RoZXJ3aXNlLCBpbnNlcnQuXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRJbmRpY2VzV2l0aEVsaWRlZERpbXMoXG4gICAgYmVnaW5NYXNrOiBudW1iZXIsIGVsbGlwc2lzSW5zZXJ0aW9uSW5kZXg6IG51bWJlciwgbnVtRWxpZGVkQXhlczogbnVtYmVyLFxuICAgIG9yaWdpbmFsQmVnaW46IG51bWJlcltdLCBpbnB1dFNoYXBlOiBudW1iZXJbXSk6IG51bWJlcltdIHtcbiAgY29uc3QgbmV3SW5kaWNlcyA9IFsuLi5pbnB1dFNoYXBlXTtcbiAgY29uc3QgZWxpZGVkQXhlcyA9IGdldEVsaWRlZEF4ZXMobnVtRWxpZGVkQXhlcywgZWxsaXBzaXNJbnNlcnRpb25JbmRleCk7XG5cbiAgZm9yIChsZXQgYXhpcyA9IDA7IGF4aXMgPCBuZXdJbmRpY2VzLmxlbmd0aDsgYXhpcysrKSB7XG4gICAgaWYgKGVsaWRlZEF4ZXMuaW5kZXhPZihheGlzKSA+IC0xKSB7XG4gICAgICBuZXdJbmRpY2VzW2F4aXNdID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3JpZ2luYWxBeGlzID1cbiAgICAgICAgICB1bm5vcm1hbGl6ZUF4aXMoZWxsaXBzaXNJbnNlcnRpb25JbmRleCwgbnVtRWxpZGVkQXhlcywgYXhpcyk7XG4gICAgICBsZXQgb3JpZ2luYWxWYWx1ZSA9IG9yaWdpbmFsQmVnaW5bb3JpZ2luYWxBeGlzXTtcbiAgICAgIGlmIChiZWdpbk1hc2sgJiAxIDw8IG9yaWdpbmFsQXhpcykge1xuICAgICAgICBvcmlnaW5hbFZhbHVlID0gMDtcbiAgICAgIH1cblxuICAgICAgbmV3SW5kaWNlc1theGlzXSA9IG9yaWdpbmFsVmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdJbmRpY2VzO1xufVxuXG4vLyBDcmVhdGVzIGZ1bGwgc2VsZWN0aW9uIGF0IHRoZSBlbGlkZWQgZGltZW5zaW9ucy4gSWYgdGhlIGRpbWVuc2lvbiBtYXRjaGVzXG4vLyB0aGUgZWxsaXBzaXMgbWFzaywgb3ZlcnJpZGUgdGhlIGN1cnJlbnQgc3RvcCB2YWx1ZS4gT3RoZXJ3aXNlLCBpbnNlcnQuXG5leHBvcnQgZnVuY3Rpb24gc3RvcEluZGljZXNXaXRoRWxpZGVkRGltcyhcbiAgICBlbmRNYXNrOiBudW1iZXIsIGVsbGlwc2lzSW5zZXJ0aW9uSW5kZXg6IG51bWJlciwgbnVtRWxpZGVkQXhlczogbnVtYmVyLFxuICAgIG9yaWdpbmFsRW5kOiBudW1iZXJbXSwgaW5wdXRTaGFwZTogbnVtYmVyW10pOiBudW1iZXJbXSB7XG4gIGNvbnN0IG5ld0luZGljZXMgPSBbLi4uaW5wdXRTaGFwZV07XG4gIGNvbnN0IGVsaWRlZEF4ZXMgPSBnZXRFbGlkZWRBeGVzKG51bUVsaWRlZEF4ZXMsIGVsbGlwc2lzSW5zZXJ0aW9uSW5kZXgpO1xuXG4gIGZvciAobGV0IGF4aXMgPSAwOyBheGlzIDwgbmV3SW5kaWNlcy5sZW5ndGg7IGF4aXMrKykge1xuICAgIGlmIChlbGlkZWRBeGVzLmluZGV4T2YoYXhpcykgPiAtMSkge1xuICAgICAgbmV3SW5kaWNlc1theGlzXSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvcmlnaW5hbEF4aXMgPVxuICAgICAgICAgIHVubm9ybWFsaXplQXhpcyhlbGxpcHNpc0luc2VydGlvbkluZGV4LCBudW1FbGlkZWRBeGVzLCBheGlzKTtcbiAgICAgIGxldCBvcmlnaW5hbFZhbHVlID0gb3JpZ2luYWxFbmRbb3JpZ2luYWxBeGlzXTtcbiAgICAgIGlmIChlbmRNYXNrICYgMSA8PCBvcmlnaW5hbEF4aXMpIHtcbiAgICAgICAgb3JpZ2luYWxWYWx1ZSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgfVxuICAgICAgbmV3SW5kaWNlc1theGlzXSA9IG9yaWdpbmFsVmFsdWU7XG4gICAgfVxuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gSGFuZGxlIG5lZ2F0aXZlIGluZGljZXNcbiAgICBjb25zdCBheGlzU2l6ZSA9IGlucHV0U2hhcGVbaV07XG4gICAgaWYgKG5ld0luZGljZXNbaV0gPCAwKSB7XG4gICAgICBuZXdJbmRpY2VzW2ldICs9IGF4aXNTaXplO1xuICAgIH1cbiAgICBuZXdJbmRpY2VzW2ldID0gdXRpbC5jbGFtcCgwLCBuZXdJbmRpY2VzW2ldLCBpbnB1dFNoYXBlW2ldKTtcbiAgfVxuICByZXR1cm4gbmV3SW5kaWNlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmlkZXNGb3JBeGlzKFxuICAgIHN0cmlkZXM6IG51bWJlcltdLCBheGlzOiBudW1iZXIsIGVsbGlwc2lzTWFzazogbnVtYmVyKTogbnVtYmVyIHtcbiAgbGV0IHN0cmlkZSA9IHN0cmlkZXNbYXhpc107XG4gIGlmIChlbGxpcHNpc01hc2sgJiAoMSA8PCBheGlzKSB8fCBzdHJpZGUgPT0gbnVsbCkge1xuICAgIHN0cmlkZSA9IDE7XG4gIH1cblxuICByZXR1cm4gc3RyaWRlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRGb3JBeGlzKFxuICAgIGJlZ2luTWFzazogbnVtYmVyLCBzdGFydEluZGljZXM6IG51bWJlcltdLCBzdHJpZGVzOiBudW1iZXJbXSxcbiAgICBpbnB1dFNoYXBlOiBudW1iZXJbXSwgYXhpczogbnVtYmVyLCBlbGxpcHNpc01hc2s6IG51bWJlcik6IG51bWJlciB7XG4gIC8vIEJlZ2luIHdpdGggdGhlIHNwZWNpZmllZCBpbmRleFxuICBsZXQgc3RhcnQgPSBzdGFydEluZGljZXNbYXhpc107XG4gIGNvbnN0IHN0cmlkZSA9IHN0cmlkZXNbYXhpc10gfHwgMTtcblxuICAvLyBDaGVjayB0aGUgYXhpcyBiaXQgZnJvbSByaWdodCBvZiBtYXNrZWQgYXhlcywgb3IgdGhlIGJlZ2luIGluZGV4IGlzIG5vdCBzZXRcbiAgLy8gZm9yIHRoZSBheGlzLlxuICBpZiAoYmVnaW5NYXNrICYgMSA8PCBheGlzIHx8IGVsbGlwc2lzTWFzayAmIDEgPDwgYXhpcyB8fCBzdGFydCA9PSBudWxsKSB7XG4gICAgaWYgKHN0cmlkZSA+IDApIHtcbiAgICAgIC8vIEZvcndhcmQgaXRlcmF0aW9uIC0gdXNlIHRoZSBmaXJzdCBlbGVtZW50LiBUaGVzZSB2YWx1ZXMgd2lsbCBnZXRcbiAgICAgIC8vIGNsYW1wZWQgYmVsb3cgKE5vdGU6IFdlIGNvdWxkIGhhdmUgc2V0IHRoZW0gdG8gMCBhbmQgYXhpc19zaXplLTEsIGJ1dFxuICAgICAgLy8gdXNlIGxvd2VzdCgpIGFuZCBtYXgoKSB0byBtYWludGFpbiBzeW1tZXRyeSB3aXRoIFN0b3BGb3JBeGlzKCkpXG4gICAgICBzdGFydCA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCYWNrd2FyZCBpdGVyYXRpb24gLSB1c2UgdGhlIGxhc3QgZWxlbWVudC5cbiAgICAgIHN0YXJ0ID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgfVxuICB9XG5cbiAgLy8gSGFuZGxlIG5lZ2F0aXZlIGluZGljZXNcbiAgY29uc3QgYXhpc1NpemUgPSBpbnB1dFNoYXBlW2F4aXNdO1xuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gYXhpc1NpemU7XG4gIH1cblxuICAvLyBDbGFtcGluZ1xuICBzdGFydCA9IHV0aWwuY2xhbXAoMCwgc3RhcnQsIGF4aXNTaXplIC0gMSk7XG5cbiAgcmV0dXJuIHN0YXJ0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RvcEZvckF4aXMoXG4gICAgZW5kTWFzazogbnVtYmVyLCBzdG9wSW5kaWNlczogbnVtYmVyW10sIHN0cmlkZXM6IG51bWJlcltdLFxuICAgIGlucHV0U2hhcGU6IG51bWJlcltdLCBheGlzOiBudW1iZXIsIGVsbGlwc2lzTWFzazogbnVtYmVyKTogbnVtYmVyIHtcbiAgLy8gQmVnaW4gd2l0aCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gIGxldCBzdG9wID0gc3RvcEluZGljZXNbYXhpc107XG4gIGNvbnN0IHN0cmlkZSA9IHN0cmlkZXNbYXhpc10gfHwgMTtcblxuICAvLyBDaGVjayB0aGUgYXhpcyBiaXQgZnJvbSByaWdodCBvZiBtYXNrZWQgYXhlcywgb3IgaWYgdGhlIHN0b3AgaW5kZXggaXMgbm90XG4gIC8vIHNldCBmb3IgdGhpcyBheGlzLlxuICBpZiAoZW5kTWFzayAmICgxIDw8IGF4aXMpIHx8IGVsbGlwc2lzTWFzayAmICgxIDw8IGF4aXMpIHx8IHN0b3AgPT0gbnVsbCkge1xuICAgIGlmIChzdHJpZGUgPiAwKSB7XG4gICAgICAvLyBGb3J3YXJkIGl0ZXJhdGlvbiAtIHVzZSB0aGUgbGFzdCBlbGVtZW50LiBUaGVzZSB2YWx1ZXMgd2lsbCBnZXRcbiAgICAgIC8vIGNsYW1wZWQgYmVsb3dcbiAgICAgIHN0b3AgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQmFja3dhcmQgaXRlcmF0aW9uIC0gdXNlIHRoZSBmaXJzdCBlbGVtZW50LlxuICAgICAgc3RvcCA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICAgIH1cbiAgfVxuXG4gIC8vIEhhbmRsZSBuZWdhdGl2ZSBpbmRpY2VzXG4gIGNvbnN0IGF4aXNTaXplID0gaW5wdXRTaGFwZVtheGlzXTtcbiAgaWYgKHN0b3AgPCAwKSB7XG4gICAgc3RvcCArPSBheGlzU2l6ZTtcbiAgfVxuXG4gIC8vIENsYW1waW5nXG4gIC8vIEJlY2F1c2UgdGhlIGVuZCBpbmRleCBwb2ludHMgb25lIHBhc3QgdGhlIGxhc3QgZWxlbWVudCwgd2UgbmVlZCBzbGlnaHRseVxuICAvLyBkaWZmZXJlbnQgY2xhbXBpbmcgcmFuZ2VzIGRlcGVuZGluZyBvbiB0aGUgZGlyZWN0aW9uLlxuICBpZiAoc3RyaWRlID4gMCkge1xuICAgIC8vIEZvcndhcmQgaXRlcmF0aW9uXG4gICAgc3RvcCA9IHV0aWwuY2xhbXAoMCwgc3RvcCwgYXhpc1NpemUpO1xuICB9IGVsc2Uge1xuICAgIC8vIEJhY2t3YXJkIGl0ZXJhdGlvblxuICAgIHN0b3AgPSB1dGlsLmNsYW1wKC0xLCBzdG9wLCBheGlzU2l6ZSAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIHN0b3A7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzbGljZSBvY2N1cGllcyBhIGNvbnRpbm91cyBzZXQgb2YgZWxlbWVudHMgaW4gdGhlXG4gKiAnZmxhdCcgc3BhY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NsaWNlQ29udGlub3VzKFxuICAgIHNoYXBlOiBudW1iZXJbXSwgYmVnaW46IG51bWJlcltdLCBzaXplOiBudW1iZXJbXSkge1xuICAvLyBJbmRleCBvZiB0aGUgZmlyc3QgYXhpcyB0aGF0IGhhcyBzaXplID4gMS5cbiAgbGV0IGZpcnN0Tm9uT25lQXhpcyA9IHNpemUubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemUubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc2l6ZVtpXSA+IDEpIHtcbiAgICAgIGZpcnN0Tm9uT25lQXhpcyA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmb3IgKGxldCBpID0gZmlyc3ROb25PbmVBeGlzICsgMTsgaSA8IHNpemUubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYmVnaW5baV0gPiAwIHx8IHNpemVbaV0gIT09IHNoYXBlW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUZsYXRPZmZzZXQoYmVnaW46IG51bWJlcltdLCBzdHJpZGVzOiBudW1iZXJbXSk6IG51bWJlciB7XG4gIGxldCBmbGF0T2Zmc2V0ID0gYmVnaW4ubGVuZ3RoID4gMCA/IGJlZ2luW2JlZ2luLmxlbmd0aCAtIDFdIDogMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiZWdpbi5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBmbGF0T2Zmc2V0ICs9IGJlZ2luW2ldICogc3RyaWRlc1tpXTtcbiAgfVxuICByZXR1cm4gZmxhdE9mZnNldDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU2xpY2VQYXJhbXMoXG4gICAgeDogVGVuc29ySW5mbywgYmVnaW46IG51bWJlcnxudW1iZXJbXSwgc2l6ZT86IG51bWJlcnxudW1iZXJbXSkge1xuICAvLyBUaGUgZm9sbG93aW5nIGxvZ2ljIGFsbG93cyBmb3IgbW9yZSBlcmdvbm9taWMgY2FsbHMuXG4gIGxldCBiZWdpbl86IG51bWJlcltdO1xuICBjb25zdCB4UmFuayA9IHguc2hhcGUubGVuZ3RoO1xuICBpZiAodHlwZW9mIGJlZ2luID09PSAnbnVtYmVyJykge1xuICAgIGJlZ2luXyA9IFtiZWdpbiwgLi4ubmV3IEFycmF5KHhSYW5rIC0gMSkuZmlsbCgwKV07XG4gIH0gZWxzZSBpZiAoYmVnaW4ubGVuZ3RoIDwgeFJhbmspIHtcbiAgICBiZWdpbl8gPSBiZWdpbi5jb25jYXQobmV3IEFycmF5KHhSYW5rIC0gYmVnaW4ubGVuZ3RoKS5maWxsKDApKTtcbiAgfSBlbHNlIHtcbiAgICBiZWdpbl8gPSBiZWdpbi5zbGljZSgpO1xuICB9XG4gIGJlZ2luXy5mb3JFYWNoKGQgPT4ge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICBkICE9PSAtMSwgKCkgPT4gJ3NsaWNlKCkgZG9lcyBub3Qgc3VwcG9ydCBuZWdhdGl2ZSBiZWdpbiBpbmRleGluZy4nKTtcbiAgfSk7XG4gIGxldCBzaXplXzogbnVtYmVyW107XG4gIGlmIChzaXplID09IG51bGwpIHtcbiAgICBzaXplXyA9IG5ldyBBcnJheSh4UmFuaykuZmlsbCgtMSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNpemUgPT09ICdudW1iZXInKSB7XG4gICAgc2l6ZV8gPSBbc2l6ZSwgLi4ubmV3IEFycmF5KHhSYW5rIC0gMSkuZmlsbCgtMSldO1xuICB9IGVsc2UgaWYgKHNpemUubGVuZ3RoIDwgeFJhbmspIHtcbiAgICBzaXplXyA9IHNpemUuY29uY2F0KG5ldyBBcnJheSh4UmFuayAtIHNpemUubGVuZ3RoKS5maWxsKC0xKSk7XG4gIH0gZWxzZSB7XG4gICAgc2l6ZV8gPSBzaXplO1xuICB9XG4gIHNpemVfID0gc2l6ZV8ubWFwKChkLCBpKSA9PiB7XG4gICAgaWYgKGQgPj0gMCkge1xuICAgICAgcmV0dXJuIGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICAgIGQgPT09IC0xLFxuICAgICAgICAgICgpID0+IGBOZWdhdGl2ZSBzaXplIHZhbHVlcyBzaG91bGQgYmUgZXhhY3RseSAtMSBidXQgZ290IGAgK1xuICAgICAgICAgICAgICBgJHtkfSBmb3IgdGhlIHNsaWNlKCkgc2l6ZSBhdCBpbmRleCAke2l9LmApO1xuICAgICAgcmV0dXJuIHguc2hhcGVbaV0gLSBiZWdpbl9baV07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIFtiZWdpbl8sIHNpemVfXTtcbn1cblxuLy8gQ29udmVydCB0aGUgc2xpY2luZyBzcGVjaWZpY2F0aW9uIGZyb20gYSBzcGFyc2UgcmVwcmVzZW50YXRpb24gdG8gYSBkZW5zZVxuLy8gcmVwcmVzZW50YXRpb24uIFRoaXMgbWVhbnMgdGhhdCBhbGwgZWxsaXBzZXMgYW5kIG5ld2F4aXMgYXJlIGV4cGFuZGVkIG91dC5cbmV4cG9ydCBmdW5jdGlvbiBzbGljZUluZm8oXG4gICAgeFNoYXBlOiBudW1iZXJbXSwgYmVnaW46IG51bWJlcltdLCBlbmQ6IG51bWJlcltdLCBzdHJpZGVzOiBudW1iZXJbXSxcbiAgICBiZWdpbk1hc2s6IG51bWJlciwgZW5kTWFzazogbnVtYmVyLCBlbGxpcHNpc01hc2s6IG51bWJlcixcbiAgICBuZXdBeGlzTWFzazogbnVtYmVyLCBzaHJpbmtBeGlzTWFzazogbnVtYmVyKTogU2xpY2VJbmZvIHtcbiAgbGV0IHN0cmlkZXNOb25OdWxsO1xuICBpZiAoc3RyaWRlcyA9PSBudWxsKSB7XG4gICAgc3RyaWRlc05vbk51bGwgPSBuZXcgQXJyYXkoYmVnaW4ubGVuZ3RoKTtcbiAgICBzdHJpZGVzTm9uTnVsbC5maWxsKDEpO1xuICB9IGVsc2Uge1xuICAgIHN0cmlkZXNOb25OdWxsID0gc3RyaWRlcztcbiAgfVxuXG4gIC8vIE9ubHkgb25lIG5vbi16ZXJvIGJpdCBpcyBhbGxvd2VkIGluIGVsbGlwc2lzTWFzaywgd2hpY2ggbWVhbnMgZWxsaXBzaXNNYXNrXG4gIC8vIGlzIGEgcG93ZXIgb2YgMi4gVXNlIGJpdCBjb21wYXJlcyB0byBlbnN1cmUgZWxsaXBzaXNNYXNrIGlzIDAgb3IgYSBwb3dlclxuICAvLyBvZiAyLiBXaGVuIGkgaXMgYSBwb3dlciBvZiAyLCBpICYgKGkgLSAxKSBpcyBhbHdheXMgMC5cbiAgLy8gQWxzbyByZWY6XG4gIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzYwMDI5My9ob3ctdG8tY2hlY2staWYtYS1udW1iZXItaXMtYS1wb3dlci1vZi0yXG4gIGlmIChlbGxpcHNpc01hc2sgIT0gbnVsbCAmJiAoZWxsaXBzaXNNYXNrICYgKGVsbGlwc2lzTWFzayAtIDEpKSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTXVsdGlwbGUgZWxsaXBzZXMgaW4gc2xpY2UgaXMgbm90IGFsbG93ZWQuJyk7XG4gIH1cblxuICAvLyBTdGVwIDE6IEFjY291bnQgZm9yIGVsbGlwc2lzIGFuZCBuZXcgYXhpcy5cbiAgLy8gQ2hlY2sgZm9yIGVsbGlwc2lzIGFuZCBjb3VudCBob3cgbWFueSBub24tbmV3YXhpcyB0aGVyZSBhcmUgYWZ0ZXIuXG4gIGxldCBlbGxpcHNpc1NlZW4gPSBmYWxzZTtcblxuICBjb25zdCBzcGFyc2VTcGVjOiBTdHJpZGVkU2xpY2VTcGFyc2VTcGVjID0ge1xuICAgIGRpbXM6IHN0cmlkZXNOb25OdWxsLmxlbmd0aCxcbiAgICBudW1BZGRBeGlzQWZ0ZXJFbGxpcHNpczogMCxcbiAgICBiZWdpbjogYmVnaW4uc2xpY2UoKSxcbiAgICBlbmQ6IGVuZC5zbGljZSgpLFxuICAgIHN0cmlkZXM6IHN0cmlkZXNOb25OdWxsLnNsaWNlKCksXG4gICAgYmVnaW5NYXNrLFxuICAgIGVuZE1hc2ssXG4gICAgZWxsaXBzaXNNYXNrLFxuICAgIG5ld0F4aXNNYXNrLFxuICAgIHNocmlua0F4aXNNYXNrXG4gIH07XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGFyc2VTcGVjLmRpbXM7IGkrKykge1xuICAgIGlmIChlbGxpcHNpc1NlZW4gJiYgKCgxIDw8IGkpICYgbmV3QXhpc01hc2spICE9PSAwKSB7XG4gICAgICBzcGFyc2VTcGVjLm51bUFkZEF4aXNBZnRlckVsbGlwc2lzKys7XG4gICAgfVxuICAgIGlmICgoMSA8PCBpKSAmIGVsbGlwc2lzTWFzaykge1xuICAgICAgZWxsaXBzaXNTZWVuID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLy8gSWYgbm8gZWxsaXBzaXMgaW5zZXJ0IG9uZSBhdCB0aGUgZW5kLlxuICBpZiAoIWVsbGlwc2lzU2Vlbikge1xuICAgIHNwYXJzZVNwZWMuZWxsaXBzaXNNYXNrIHw9ICgxIDw8IHNwYXJzZVNwZWMuZGltcyk7XG4gICAgc3BhcnNlU3BlYy5kaW1zKys7ICAvLyB0aGlzIGVmZmVjdHMgbG9vcCBpdGVyYXRpb24gYmVsb3dcbiAgfVxuXG4gIC8vIFN0ZXAgMjogTWFrZSBhIHNwYXJzZSBzcGVjIGludG8gYSBmdWxsIGluZGV4IHNwZWMuXG4gIC8vXG4gIC8vIFRoZSBzcGFyc2Ugc3BlYyBkZW9zIG5vdCBjb3JyZXNwb25kIHRvIHRoZSBudW1iZXIgb2YgZGltZW5zaW9ucy5cbiAgLy8gTWFrZSBhIGRlbnNlIHNwZWMgdGhhdCBjb29yZXNwb25kcyB0byB0aGUgbnVtYmVyIG9mIGRpbWVuc2lvbnMuXG4gIC8vXG4gIC8vIEZvciBleGFtcGxlIHN1cHBvc2UgZm9vWy4uLiwzOl0gb24gZm9vLnNoYXBlID0gWzIsIDIsIDNdIHRoZW4gd2UgbmVlZCB0b1xuICAvLyBwcm9kdWNlIHRoZSBtaXNzaW5nIGJlZ2luTWFzayBmb3IgdGhlIGZpcnN0IHR3byBkaW1lbnNpb25zIGkuZS4gZnJvbVxuICAvLyBiZWdpbk1hc2tTcGVjID0gMCwgZW5kTWFza1NwZWMgPSAyLCB3ZSBhY2hpZXZlIGJlZ2luTWFzayA9IDYgKDExMCksXG4gIC8vIGVuZE1hc2sgPSA3ICgxMTEpLlxuICBjb25zdCBkZW5zZVNwZWM6IFN0cmlkZWRTbGljZURlbnNlU3BlYyA9IHtcbiAgICBkaW1zOiB4U2hhcGUubGVuZ3RoLFxuICAgIGJlZ2luTWFzazogMCxcbiAgICBlbmRNYXNrOiAwLFxuICAgIGJlZ2luVmFsaWQ6IGZhbHNlLFxuICAgIGVuZFZhbGlkOiBmYWxzZVxuICB9O1xuXG4gIGJ1aWxkRGVuc2VTcGVjKHNwYXJzZVNwZWMsIGRlbnNlU3BlYyk7XG5cbiAgLy8gU3RlcCAzOiBNYWtlIGltcGxpY2l0IHJhbmdlcyAobm9uLXplcm8gYmVnaW5NYXNrcyBhbmQgZW5kTWFza3MpIGV4cGxpY2l0XG4gIC8vIGFuZCBib3VuZHMgY2hlY2suXG4gIGxldCBpc0lkZW50aXR5ID0gdHJ1ZTtcbiAgbGV0IHNsaWNlRGltMCA9IHRydWU7XG4gIGxldCBpc1NpbXBsZVNsaWNlID0gdHJ1ZTtcbiAgY29uc3QgcHJvY2Vzc2luZ1NoYXBlID0gW107XG4gIGNvbnN0IGZpbmFsU2hhcGUgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHhTaGFwZS5sZW5ndGg7ICsraSkge1xuICAgIGlmIChkZW5zZVNwZWMuc3RyaWRlc1tpXSA9PT0gMCkge1xuICAgICAgdGhyb3cgRXJyb3IoYHN0cmlkZXNbJHtpfV0gbXVzdCBiZSBub24temVyb2ApO1xuICAgIH1cbiAgICBjb25zdCBzaHJpbmtJID0gISEoZGVuc2VTcGVjLnNocmlua0F4aXNNYXNrICYgKDEgPDwgaSkpO1xuICAgIGNvbnN0IGRpbUkgPSB4U2hhcGVbaV07XG4gICAgaWYgKGRpbUkgPT09IC0xKSB7XG4gICAgICBwcm9jZXNzaW5nU2hhcGUucHVzaChzaHJpbmtJID8gMSA6IC0xKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IG1hc2tzID1cbiAgICAgICAgW2RlbnNlU3BlYy5iZWdpbk1hc2sgJiAoMSA8PCBpKSwgZGVuc2VTcGVjLmVuZE1hc2sgJiAoMSA8PCBpKV07XG4gICAgY29uc3QgdmFsaWRSYW5nZSA9IFtcbiAgICAgIGRlbnNlU3BlYy5zdHJpZGVzW2ldID4gMCA/IDAgOiAtMSxcbiAgICAgIGRlbnNlU3BlYy5zdHJpZGVzW2ldID4gMCA/IGRpbUkgOiBkaW1JIC0gMVxuICAgIF07XG5cbiAgICBpZiAoc2hyaW5rSSAmJiBkZW5zZVNwZWMuc3RyaWRlc1tpXSA8PSAwKSB7XG4gICAgICB0aHJvdyBFcnJvcignb25seSBzdHJpZGUgMSBhbGxvd2VkIG9uIG5vbi1yYW5nZSBpbmRleGluZy4nKTtcbiAgICB9XG5cbiAgICBpc1NpbXBsZVNsaWNlID0gaXNTaW1wbGVTbGljZSAmJiAoZGVuc2VTcGVjLnN0cmlkZXNbaV0gPT09IDEpO1xuXG4gICAgY29uc3QgYmVnaW5BbmRFbmRNYXNrZWQgPVxuICAgICAgICAhISgoZGVuc2VTcGVjLmJlZ2luTWFzayAmICgxIDw8IGkpKSAmJiAoZGVuc2VTcGVjLmVuZE1hc2sgJiAoMSA8PCBpKSkpO1xuXG4gICAgaWYgKGRlbnNlU3BlYy5iZWdpblZhbGlkICYmIGRlbnNlU3BlYy5lbmRWYWxpZCkge1xuICAgICAgaWYgKHNocmlua0kpIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlIHNocmlua2luZywgdGhlIGVuZCBpbmRleCBpcyBub3cgcG9zc2libHkgaW5jb3JyZWN0LiBJblxuICAgICAgICAvLyBwYXJ0aWN1bGFyIGZvb1stMV0gcHJvZHVjZXMgc3BhcnNlQmVnaW4gPSAtMSwgc3BhcnNlRW5kID0gMC5cbiAgICAgICAgLy8gYW5kIGNhbm9uaWNhbCBwdXRzIHRoZXNlIHRvIG4tMSBhbmQgMCwgd2hpY2ggaW1wbGllcyBhIGRlZ2VuZXJhdGVcbiAgICAgICAgLy8gaW50ZXJ2YWwuIEZvcnR1bmF0ZWx5LCBpdCBpcyBub3cgc2FmZSB0byByZS1jcmVhdGUgZW5kIGFzIGJlZ2luICsgMS5cbiAgICAgICAgY29uc3QgeEZ3ZCA9IGRlbnNlU3BlYy5iZWdpbltpXSA8IDAgPyBkaW1JICsgZGVuc2VTcGVjLmJlZ2luW2ldIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZW5zZVNwZWMuYmVnaW5baV07XG4gICAgICAgIGRlbnNlU3BlYy5iZWdpbltpXSA9IHhGd2Q7XG4gICAgICAgIGRlbnNlU3BlYy5lbmRbaV0gPSBkZW5zZVNwZWMuYmVnaW5baV0gKyAxO1xuICAgICAgICBpZiAoeEZ3ZCA8IDAgfHwgeEZ3ZCA+PSBkaW1JKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYHNsaWNlIGluZGV4ICR7ZGVuc2VTcGVjLmJlZ2luW2ldfSBvZiBkaW1lbnNpb24gJHtcbiAgICAgICAgICAgICAgaX0gb3V0IG9mIGJvdW5kcy5gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVuc2VTcGVjLmJlZ2luW2ldID0gY2Fub25pY2FsKFxuICAgICAgICAgICAgZGVuc2VTcGVjLmJlZ2luW2ldLCAwLCBkZW5zZVNwZWMuc3RyaWRlc1tpXSwgZGltSSwgbWFza3MsXG4gICAgICAgICAgICB2YWxpZFJhbmdlKTtcbiAgICAgICAgZGVuc2VTcGVjLmVuZFtpXSA9IGNhbm9uaWNhbChcbiAgICAgICAgICAgIGRlbnNlU3BlYy5lbmRbaV0sIDEsIGRlbnNlU3BlYy5zdHJpZGVzW2ldLCBkaW1JLCBtYXNrcywgdmFsaWRSYW5nZSk7XG4gICAgICB9XG4gICAgICAvLyBVcGRhdGUgb3B0aW1pemF0aW9uIHZhbHVlc1xuICAgICAgY29uc3QgdGFrZUFsbEluRGltZW5zaW9uID0gZGVuc2VTcGVjLnN0cmlkZXNbaV0gPT09IDEgJiZcbiAgICAgICAgICBkZW5zZVNwZWMuYmVnaW5baV0gPT09IDAgJiYgZGVuc2VTcGVjLmVuZFtpXSA9PT0gZGltSTtcbiAgICAgIGlzSWRlbnRpdHkgPSBpc0lkZW50aXR5ICYmIHRha2VBbGxJbkRpbWVuc2lvbjtcbiAgICAgIHNsaWNlRGltMCA9IHNsaWNlRGltMCAmJlxuICAgICAgICAgICgoaSA9PT0gMCAmJiBkZW5zZVNwZWMuc3RyaWRlc1tpXSA9PT0gMSkgfHwgdGFrZUFsbEluRGltZW5zaW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNJZGVudGl0eSA9XG4gICAgICAgICAgaXNJZGVudGl0eSAmJiAoKGRlbnNlU3BlYy5zdHJpZGVzW2ldID09PSAxKSAmJiBiZWdpbkFuZEVuZE1hc2tlZCk7XG4gICAgICBzbGljZURpbTAgPSBzbGljZURpbTAgJiZcbiAgICAgICAgICAoKGkgPT09IDAgJiYgZGVuc2VTcGVjLnN0cmlkZXNbaV0gPT09IDEpIHx8IGJlZ2luQW5kRW5kTWFza2VkKTtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZSB0aGUgcHJvY2Vzc2luZyBzaGFwZSAodGhlIGludGVybWVkaWF0ZSBFaWdlbiB3aWxsIHByb2R1Y2UpXG4gICAgbGV0IGludGVydmFsTGVuZ3RoO1xuICAgIGxldCBrbm93bkludGVydmFsID0gZmFsc2U7XG4gICAgaWYgKGRlbnNlU3BlYy5iZWdpblZhbGlkICYmIGRlbnNlU3BlYy5lbmRWYWxpZCkge1xuICAgICAgaW50ZXJ2YWxMZW5ndGggPSBkZW5zZVNwZWMuZW5kW2ldIC0gZGVuc2VTcGVjLmJlZ2luW2ldO1xuICAgICAga25vd25JbnRlcnZhbCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChzaHJpbmtJKSB7XG4gICAgICAvLyBUaGUgZGltZW5zaW9uIGlzIHN0aWxsIGtub3duIGFzIDEgZm9yIHRoZSBwcm9jZXNzaW5nU2hhcGUsIGJ1dCB3aWxsIGJlXG4gICAgICAvLyBkaXNjYXJkZWQgZm9yIHRoZSBmaW5hbCBzaGFwZS5cbiAgICAgIGludGVydmFsTGVuZ3RoID0gMTtcbiAgICAgIGtub3duSW50ZXJ2YWwgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoYmVnaW5BbmRFbmRNYXNrZWQpIHtcbiAgICAgIC8vIEV2ZW4gaWYgd2UgZG9uJ3QgaGF2ZSB2YWx1ZXMgZm9yIGJlZ2luIG9yIGVuZCwgd2UgZG8ga25vdyB0aGF0IHRoaXNcbiAgICAgIC8vIGRpbWVuc2lvbiBjb3ZlcnMgdGhlIHdob2xlIGludGVydmFsLiBJZiB3ZSBoYXZlIHNoYXBlIGluZm9ybWF0aW9uIGZvclxuICAgICAgLy8gdGhpcyBkaW1lbnNpb24sIHRoYXQgdGVsbHMgdXMgdGhlIGludGVydmFsIGxlbmd0aC5cbiAgICAgIGlmIChkaW1JID49IDApIHtcbiAgICAgICAgaWYgKGRlbnNlU3BlYy5zdHJpZGVzW2ldIDwgMCkge1xuICAgICAgICAgIGludGVydmFsTGVuZ3RoID0gLWRpbUk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW50ZXJ2YWxMZW5ndGggPSBkaW1JO1xuICAgICAgICB9XG4gICAgICAgIGtub3duSW50ZXJ2YWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa25vd25JbnRlcnZhbCkge1xuICAgICAgbGV0IHNpemVJO1xuICAgICAgLy8gSG9sZCB6ZXJvIGlmIHRoZSBpbnRlcnZhbCBpcyBkZWdlbmVyYXRlLCBvdGhlcndpc2UgYWNjb3VudCBmb3JcbiAgICAgIC8vIHJlbWFpbmRlclxuICAgICAgaWYgKGludGVydmFsTGVuZ3RoID09PSAwIHx8XG4gICAgICAgICAgKChpbnRlcnZhbExlbmd0aCA8IDApICE9PSAoZGVuc2VTcGVjLnN0cmlkZXNbaV0gPCAwKSkpIHtcbiAgICAgICAgc2l6ZUkgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2l6ZUkgPSBNYXRoLnRydW5jKGludGVydmFsTGVuZ3RoIC8gZGVuc2VTcGVjLnN0cmlkZXNbaV0pICtcbiAgICAgICAgICAgIChpbnRlcnZhbExlbmd0aCAlIGRlbnNlU3BlYy5zdHJpZGVzW2ldICE9PSAwID8gMSA6IDApO1xuICAgICAgfVxuICAgICAgcHJvY2Vzc2luZ1NoYXBlLnB1c2goc2l6ZUkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzaW5nU2hhcGUucHVzaCgtMSk7XG4gICAgfVxuICB9XG5cbiAgLy8gU3RlcCA0OiBDb21wdXRlIHRoZSBmaW5hbCBzaGFwZVxuICAvL1xuICAvLyBuZXdBeGlzIHdpbGwgaW5jcmVhc2UgZGltZW5zaW9uIGJ5IDEgKHdpdGggYSBvbmUtc2l6ZSBkaW1lbnNpb24pXG4gIC8vIHNsaWNlcyBsaWtlIGZvb1szLCAuLi5dIHdpbGwgcmVkdWNlIGRpbWVuc2lvbiBieSAxLlxuICAvLyBUaGlzIGNhbm5vdCBiZSBkb25lIGVhcmxpZXIsIGJlY2F1c2UgaXQgZGVwZW5kcyBvbiBTdGVwIDMuXG4gIGZvciAobGV0IGRlbnNlRGltID0gMDsgZGVuc2VEaW0gPCBkZW5zZVNwZWMuZmluYWxTaGFwZUdhdGhlckluZGljZXMubGVuZ3RoO1xuICAgICAgICsrZGVuc2VEaW0pIHtcbiAgICBjb25zdCBnYXRoZXJJbmRleCA9IGRlbnNlU3BlYy5maW5hbFNoYXBlR2F0aGVySW5kaWNlc1tkZW5zZURpbV07XG4gICAgaWYgKGdhdGhlckluZGV4ID49IDApIHtcbiAgICAgIGZpbmFsU2hhcGUucHVzaChwcm9jZXNzaW5nU2hhcGVbZ2F0aGVySW5kZXhdKTtcbiAgICB9IGVsc2UgaWYgKGdhdGhlckluZGV4ID09PSBORVdfQVhJUykge1xuICAgICAgZmluYWxTaGFwZS5wdXNoKDEpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGZpbmFsU2hhcGVTcGFyc2UgPSBmaW5hbFNoYXBlLmZpbHRlcihcbiAgICAgIChkaW0sIGkpID0+IGRlbnNlU3BlYy5maW5hbFNoYXBlR2F0aGVySW5kaWNlc1tpXSAhPT0gTkVXX0FYSVMpO1xuXG4gIHJldHVybiB7XG4gICAgZmluYWxTaGFwZVNwYXJzZSxcbiAgICBmaW5hbFNoYXBlLFxuICAgIGlzSWRlbnRpdHksXG4gICAgc2xpY2VEaW0wLFxuICAgIGlzU2ltcGxlU2xpY2UsXG4gICAgYmVnaW46IGRlbnNlU3BlYy5iZWdpbixcbiAgICBlbmQ6IGRlbnNlU3BlYy5lbmQsXG4gICAgc3RyaWRlczogZGVuc2VTcGVjLnN0cmlkZXNcbiAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGREZW5zZVNwZWMoXG4gICAgc3BhcnNlOiBTdHJpZGVkU2xpY2VTcGFyc2VTcGVjLCBkZW5zZTogU3RyaWRlZFNsaWNlRGVuc2VTcGVjKSB7XG4gIGRlbnNlLmJlZ2luTWFzayA9IDA7XG4gIGRlbnNlLmVuZE1hc2sgPSAwO1xuICBkZW5zZS5zaHJpbmtBeGlzTWFzayA9IDA7XG5cbiAgbGV0IGZ1bGxJbmRleCA9IDA7XG4gIGRlbnNlLmJlZ2luVmFsaWQgPSBzcGFyc2UuYmVnaW4gIT0gbnVsbDtcbiAgZGVuc2UuZW5kVmFsaWQgPSBzcGFyc2UuZW5kICE9IG51bGw7XG5cbiAgZGVuc2UuYmVnaW4gPSBuZXcgQXJyYXkoZGVuc2UuZGltcyk7XG4gIGRlbnNlLmVuZCA9IG5ldyBBcnJheShkZW5zZS5kaW1zKTtcbiAgZGVuc2Uuc3RyaWRlcyA9IG5ldyBBcnJheShkZW5zZS5kaW1zKTtcbiAgZGVuc2UuZmluYWxTaGFwZUdhdGhlckluZGljZXMgPSBbXTtcbiAgZGVuc2UuZmluYWxTaGFwZUdhdGhlckluZGljZXNTcGFyc2UgPSBbXTtcbiAgZGVuc2UuaW5wdXRTaGFwZUdhdGhlckluZGljZXNTcGFyc2UgPSBuZXcgQXJyYXkoZGVuc2UuZGltcyk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGFyc2UuZGltczsgaSsrKSB7XG4gICAgaWYgKCgxIDw8IGkpICYgc3BhcnNlLmVsbGlwc2lzTWFzaykge1xuICAgICAgLy8gT25seSB0aGUgYml0IHRoYXQgaGFzIGVsbGlwc2lzIHdpbGwgZmFsbCBpbiB0aGlzIGNvbmRpdGlvbi5cbiAgICAgIC8vIEV4cGFuZCB0aGUgZWxsaXBzaXMgaW50byB0aGUgYXBwcm9wcmlhdGUgaW5kaWNlc1xuICAgICAgLy8gTm90ZTogdGhpcyBvbmx5IHdvcmtzIGJlY2F1c2Ugd2UgZ3VhcmFudGVlZCBvbmUgZWxsaXBzaXMuXG4gICAgICBjb25zdCBuZXh0SW5kZXggPSBNYXRoLm1pbihcbiAgICAgICAgICBkZW5zZS5kaW1zIC0gKHNwYXJzZS5kaW1zIC0gaSkgKyAxICsgc3BhcnNlLm51bUFkZEF4aXNBZnRlckVsbGlwc2lzLFxuICAgICAgICAgIGRlbnNlLmRpbXMpO1xuICAgICAgZm9yICg7IGZ1bGxJbmRleCA8IG5leHRJbmRleDsgZnVsbEluZGV4KyspIHtcbiAgICAgICAgLy8gbmV3QXhpcyBhcmVuJ3QgcmVhbCBheGlzIHNvIHlvdSBoYXZlIHRvIHNraXAuXG4gICAgICAgIGRlbnNlLmJlZ2luW2Z1bGxJbmRleF0gPSAwO1xuICAgICAgICBkZW5zZS5lbmRbZnVsbEluZGV4XSA9IDA7XG4gICAgICAgIGRlbnNlLnN0cmlkZXNbZnVsbEluZGV4XSA9IDE7XG4gICAgICAgIGRlbnNlLmJlZ2luTWFzayB8PSAoMSA8PCBmdWxsSW5kZXgpO1xuICAgICAgICBkZW5zZS5lbmRNYXNrIHw9ICgxIDw8IGZ1bGxJbmRleCk7XG4gICAgICAgIGRlbnNlLmZpbmFsU2hhcGVHYXRoZXJJbmRpY2VzLnB1c2goZnVsbEluZGV4KTtcbiAgICAgICAgZGVuc2UuZmluYWxTaGFwZUdhdGhlckluZGljZXNTcGFyc2UucHVzaCgtMSk7XG4gICAgICAgIGRlbnNlLmlucHV0U2hhcGVHYXRoZXJJbmRpY2VzU3BhcnNlW2Z1bGxJbmRleF0gPSBpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKDEgPDwgaSkgJiBzcGFyc2UubmV3QXhpc01hc2spIHtcbiAgICAgIC8vIE9ubHkgdGhlIGJpdCB0aGF0IGhhcyBuZXdBeGlzIHdpbGwgZmFsbCBpbiB0aGlzIGNvbmRpdGlvbi5cbiAgICAgIGRlbnNlLmZpbmFsU2hhcGVHYXRoZXJJbmRpY2VzLnB1c2goTkVXX0FYSVMpO1xuICAgICAgZGVuc2UuZmluYWxTaGFwZUdhdGhlckluZGljZXNTcGFyc2UucHVzaCgtMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChmdWxsSW5kZXggPT09IGRlbnNlLmJlZ2luLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIGBJbmRleCBvdXQgb2YgcmFuZ2UgdXNpbmcgaW5wdXQgZGltICR7ZnVsbEluZGV4fTsgaW5wdXQgYCArXG4gICAgICAgICAgICBgaGFzIG9ubHkgJHtkZW5zZS5kaW1zfSBkaW1zLCAke2RlbnNlLmJlZ2luLmxlbmd0aH0uYCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEdhdGhlciBzbGljaW5nIHNwZWMgaW50byBhcHByb3ByaWF0ZSBpbmRleC5cbiAgICAgIGlmIChzcGFyc2UuYmVnaW4gIT0gbnVsbCkge1xuICAgICAgICBkZW5zZS5iZWdpbltmdWxsSW5kZXhdID0gc3BhcnNlLmJlZ2luW2ldO1xuICAgICAgfVxuICAgICAgaWYgKHNwYXJzZS5lbmQgIT0gbnVsbCkge1xuICAgICAgICBkZW5zZS5lbmRbZnVsbEluZGV4XSA9IHNwYXJzZS5lbmRbaV07XG4gICAgICB9XG4gICAgICBkZW5zZS5zdHJpZGVzW2Z1bGxJbmRleF0gPSBzcGFyc2Uuc3RyaWRlc1tpXTtcbiAgICAgIGlmIChzcGFyc2UuYmVnaW5NYXNrICYgKDEgPDwgaSkpIHtcbiAgICAgICAgZGVuc2UuYmVnaW5NYXNrIHw9ICgxIDw8IGZ1bGxJbmRleCk7XG4gICAgICB9XG4gICAgICBpZiAoc3BhcnNlLmVuZE1hc2sgJiAoMSA8PCBpKSkge1xuICAgICAgICBkZW5zZS5lbmRNYXNrIHw9ICgxIDw8IGZ1bGxJbmRleCk7XG4gICAgICB9XG4gICAgICAvLyBJZiBzaHJpbmssIHJlY29yZCB3aGVyZSB0byBnZXQgdGhlIGRpbWVuc2lvbmFsaXR5IGZyb20gKGkuZS4gbmV3QXhpcylcbiAgICAgIC8vIGNyZWF0ZXMgYSBmYWtlIDEgc2l6ZSBkaW1lbnNpb24uIEFsc28gcmVtZW1iZXIgc2hyaW5rIGF4aXMgKG5vdyBpblxuICAgICAgLy8gZGVuc2UgZm9ybSkgc28gd2UgY2FuIGlnbm9yZSBkZW5zZS5lbmQgYmVsb3cuXG4gICAgICBpZiAoc3BhcnNlLnNocmlua0F4aXNNYXNrICYgKDEgPDwgaSkpIHtcbiAgICAgICAgZGVuc2UuZmluYWxTaGFwZUdhdGhlckluZGljZXMucHVzaChTSFJJTktfQVhJUyk7XG4gICAgICAgIGRlbnNlLmZpbmFsU2hhcGVHYXRoZXJJbmRpY2VzU3BhcnNlLnB1c2goLTEpO1xuICAgICAgICBkZW5zZS5zaHJpbmtBeGlzTWFzayB8PSAoMSA8PCBmdWxsSW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVuc2UuZmluYWxTaGFwZUdhdGhlckluZGljZXMucHVzaChmdWxsSW5kZXgpO1xuICAgICAgICAvLyBSZW1lbWJlciB0aGF0IHdoZXJlIGluIHRoZSBzcGFyc2Ugc2hhcGUgdGhlIGRlbnNlIGRpbSBjb21lcyBmcm9tLlxuICAgICAgICBkZW5zZS5maW5hbFNoYXBlR2F0aGVySW5kaWNlc1NwYXJzZS5wdXNoKGkpO1xuICAgICAgfVxuICAgICAgZGVuc2UuaW5wdXRTaGFwZUdhdGhlckluZGljZXNTcGFyc2VbZnVsbEluZGV4XSA9IGk7XG4gICAgICBmdWxsSW5kZXgrKztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2Fub25pY2FsKFxuICAgIHg6IG51bWJlciwgYzogbnVtYmVyLCBzdHJpZGVJOiBudW1iZXIsIGRpbUk6IG51bWJlciwgbWFza3M6IG51bWJlcltdLFxuICAgIHZhbGlkUmFuZ2U6IG51bWJlcltdKSB7XG4gIGlmIChtYXNrc1tjXSkge1xuICAgIHJldHVybiBzdHJpZGVJID4gMCA/IHZhbGlkUmFuZ2VbY10gOiB2YWxpZFJhbmdlWyhjICsgMSkgJiAxXTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB4RndkID0geCA8IDAgPyBkaW1JICsgeCA6IHg7ICAvLyBtYWtlIG5lZ2F0aXZlIGluZGljZXMgcG9zaXRpdmVcbiAgICByZXR1cm4geEZ3ZCA8IHZhbGlkUmFuZ2VbMF0gPyB2YWxpZFJhbmdlWzBdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4RndkID4gdmFsaWRSYW5nZVsxXSA/IHZhbGlkUmFuZ2VbMV0gOiB4RndkO1xuICB9XG59XG4iXX0="],"names":["round_","x","$x","inputs","runKernel","round","op","scalar","value","dtype","isTypedArray","Array","isArray","Error","Uint8Array","shape","inferredShape","validateUpdateShape","indices","updates","sliceDim","rank","batchDim","shapeError","length","d","validateInput","size","calculateShapes","indicesRank","sliceRank","totalNd","sliceSize","i","safeSliceDim","numUpdates","strides","slice","outputSize","segOpComputeOptimalWindowSize","inSize","numSegments","res","done","Math","floor","sqrt","computeOutShape","aShape","axis","outShape","dim","push","collectGatherOpShapeInfo","batchDims","xRank","dimSize","outputShape","batchSize","outerSize","SELU_SCALEALPHA","SELU_SCALE","sigmoid_","sigmoid","frame_","signal","frameLength","frameStep","padEnd","padValue","start","output","padLen","pad","frame","hammingWindow_","windowLength","hammingWindow","hannWindow_","hannWindow","stft_","fftLength","windowFn","framedSignal","windowedSignal","stft","enclosingPowerOfTwo","pow","ceil","log","cosineWindow","a","b","even","newValues","Float32Array","cosArg","PI","cos","t","slice_","begin","attrs","NEW_AXIS","SHRINK_AXIS","assertParamsValid","input","inputRank","maskToAxes","mask","axes","end","stridesWithElidedDims","ellipsisInsertionIndex","numElidedAxes","inputShape","newStrides","splice","pop","unnormalizeAxis","normalizedAxis","getElidedAxes","elidedAxes","getNormalizedAxes","ellipsisAxes","numInterpolatedAxes","beginMask","endMask","ellipsisMask","normalizedBegin","normalizedEnd","normalizedStrides","fullIndex","startIndicesWithElidedDims","stopIndicesWithElidedDims","startForAxis","stopForAxis","stridesForAxis","originalBegin","newIndices","indexOf","originalAxis","originalValue","originalEnd","Number","MAX_SAFE_INTEGER","axisSize","stride","startIndices","MIN_SAFE_INTEGER","stopIndices","stop","isSliceContinous","firstNonOneAxis","computeFlatOffset","flatOffset","parseSliceParams","begin_","size_","fill","concat","forEach","map","sliceInfo","xShape","newAxisMask","shrinkAxisMask","stridesNonNull","ellipsisSeen","sparseSpec","dims","numAddAxisAfterEllipsis","denseSpec","beginValid","endValid","buildDenseSpec","isIdentity","sliceDim0","isSimpleSlice","processingShape","finalShape","shrinkI","dimI","masks","validRange","beginAndEndMasked","xFwd","canonical","takeAllInDimension","intervalLength","knownInterval","sizeI","trunc","denseDim","finalShapeGatherIndices","gatherIndex","finalShapeSparse","filter","sparse","dense","finalShapeGatherIndicesSparse","inputShapeGatherIndicesSparse","nextIndex","min","c","strideI"],"sourceRoot":""}