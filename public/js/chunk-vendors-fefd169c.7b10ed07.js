"use strict";(self["webpackChunkbenefit"]=self["webpackChunkbenefit"]||[]).push([[7097],{60432:function(e,t,n){n.d(t,{u:function(){return i}});var r=n(27575);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class i{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=(0,r.bf)(this.rank),i=o(e,2);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${i}));\n      }\n    `}}function o(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let i=0;i<e.length;i++)2===i?r.push("index"):r.push(`${n[i]}`);return r.join()}},96911:function(e,t,n){n.d(t,{g:function(){return i}});var r=n(27575);class i{constructor(e,t,n,i){this.sliceDim=e,this.strides=t,this.paramsShape=i,this.variableNames=["x","indices"],this.outputShape=n;const o=(0,r.bf)(n.length);let s="\n    int index;";for(let r=0;r<this.sliceDim;r++)s+=`\n          index = round(getIndices(coords[0], ${r}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[r]};\n          flattenIndex += index * ${this.strides[r]};`;this.userCode=`\n         void main() {\n          ${o} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${s}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}},18765:function(e,t,n){n.d(t,{B:function(){return i}});var r=n(9495);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i(){let e,t,n,i,o,s,a,u,l,f;return 2===(0,r._K2)().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",i="in",o="texture",s="outputColor",a="out vec4 outputColor;",u=(0,r._K2)().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",f="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",i="varying",o="texture2D",s="gl_FragColor",a="",u="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",f="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:i,texture2D:o,output:s,defineOutput:a,defineSpecialNaN:u,defineSpecialInf:l,defineRound:f}}},63839:function(e,t,n){n.d(t,{n:function(){return u}});var r=n(9495),i=n(597),o=n(47646),s=n(28560),a=n(88380);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class u{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=(0,r._K2)().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,(0,i.lj)(t,e)):this.gl=(0,i.bU)(t),e=this.gl,2===(0,r._K2)().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>a.ul(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>a.ul(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>a.ul(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>a.ul(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>a.ul(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>a.ul(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>a.ul(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>a.ul(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float";const u="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===(0,r._K2)().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=a.HM(this.gl,e),a.Ql(this.gl,t))this.textureHalfFloatExtension=a.HM(this.gl,t);else if((0,r._K2)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),a.Ql(this.gl,u))this.colorBufferHalfFloatExtension=a.HM(this.gl,u);else if((0,r._K2)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",a.Ql(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!a.Ql(this.gl,u))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(u)}this.vertexBuffer=o.b1(this.gl),this.indexBuffer=o.Ng(this.gl),this.framebuffer=a.oN(this.gl),this.textureConfig=s.EZ(this.gl,this.textureHalfFloatExtension)}get debug(){return(0,r._K2)().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;a.ul(e,(()=>e.finish())),a.ul(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),a.ul(e,(()=>e.deleteFramebuffer(this.framebuffer))),a.ul(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),a.ul(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),a.ul(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),o.cD(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),o.WH(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),o.Hw(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),o.qg(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),o.y7(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),o.Me(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),o.bG(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(a.sA(this.gl,this.framebuffer),this.outputTexture=null),a.ul(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>o.ir(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,i,s){return o.SD(this.gl,e,t,n,r,i,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return o.$k(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=o.zP(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if((0,r._K2)().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,i=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(i,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=i}else(0,r._K2)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,(0,r._K2)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>o.uS(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=o.yr(t));const n=a.rC(t);a.ul(t,(()=>t.attachShader(n,this.vertexShader))),a.ul(t,(()=>t.attachShader(n,e))),a.R7(t,n);const r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&a.bz(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;a.ul(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),o.Z(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(a.ul(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&a.bz(this.gl,this.program),a.ul(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?a.Rh(this.gl,e,t):a.Yn(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),a.ul(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),a.y_(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,i]=s.NO(t,n);this.setOutputMatrixTextureDriver(e,r,i)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&a.bz(this.gl,this.program),a.s6(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}a.ul(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),a.ul(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=a.HM(this.gl,2===(0,r._K2)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===(0,r._K2)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===(0,r._K2)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await r.ZSL.repeatedTry((()=>this.disposed||this.isQueryAvailable(e,(0,r._K2)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,(0,r._K2)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl,n=t.getQueryParameter(e,t.QUERY_RESULT);return n/1e6}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT);return n/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=l(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in(0,r._K2)().platform&&(n=(0,r._K2)().platform.setTimeoutCustom.bind((0,r._K2)().platform)),r.ZSL.repeatedTry((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),a.SO(this.gl,e,this.framebuffer),this.debug&&a.s6(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(a.SO(this.gl,this.outputTexture,this.framebuffer),this.debug&&a.s6(this.gl)):a.sA(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;a.SO(r,e,this.framebuffer),this.debug&&a.s6(r),this.outputTexture=e,a.ul(r,(()=>r.viewport(0,0,t,n))),a.ul(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),a.ul(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}function l(e){let t=0;for(;t<e.length;++t){const n=e[t]();if(!n)break}return t-1}},22792:function(e,t,n){n.d(t,{Kz:function(){return s},Tb:function(){return f},Tw:function(){return a},ik:function(){return h},mB:function(){return l}});var r=n(9495),i=n(27575),o=n(88380);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function s(e,t,n,s){const u=n.map(((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),l=u.map((e=>e.shapeInfo)),f={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},h=i.yr(u,f,t),c=(0,o.yG)(e.gl,h),d=e.createProgram(c);return(0,r._K2)().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:c,source:h,webGLProgram:d,inShapeInfos:l,outShapeInfo:f,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(d),Object.assign({program:t,fragmentShader:c,source:h,webGLProgram:d,inShapeInfos:l,outShapeInfo:f},a(e,t,d)))}function a(e,t,n){const i=[],o=[];let s,a,u,l=null,f=null;f=e.getUniformLocation(n,"NAN",!1),1===(0,r._K2)().getNumber("WEBGL_VERSION")&&(l=e.getUniformLocation(n,"INFINITY",!1));const h=!1;for(const r of t.variableNames){const o={name:r,uniform:e.getUniformLocation(n,r,h),offset:e.getUniformLocation(n,`offset${r}`,h)};t.enableShapeUniforms&&(o.shape=e.getUniformLocation(n,`${r}Shape`,h),o.texShape=e.getUniformLocation(n,`${r}TexShape`,h)),i.push(o)}if(t.enableShapeUniforms&&(s=e.getUniformLocation(n,"outShape",h),u=e.getUniformLocation(n,"outShapeStrides",h),a=e.getUniformLocation(n,"outTexShape",h)),t.customUniforms)for(const r of t.customUniforms)o.push(e.getUniformLocation(n,r.name,h));return{variablesLocations:i,customUniformLocations:o,infLoc:l,nanLoc:f,outShapeLocation:s,outShapeStridesLocation:u,outTexShapeLocation:a}}function u(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{const i=e.logicalShape,o=t[n],s=o.shape;if(!r.ZSL.arraysEqual(i,s))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${i} and ${s} must match`);if(e.isUniform&&o.isUniform)return;const a=e.texShape,u=o.isUniform?null:o.texData.texShape;if(!r.ZSL.arraysEqual(a,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${u} must match`)}))}function l(e,t,n,o,s){t.program.enableShapeUniforms||(u(t.inShapeInfos,n),u([t.outShapeInfo],[o]));const a=o.texData.texture,l=o.texData.texShape;o.texData.isPacked?e.setOutputPackedMatrixTexture(a.texture,l[0],l[1]):e.setOutputMatrixTexture(a.texture,l[0],l[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===(0,r._K2)().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let u=0;u<n.length;++u){const o=n[u],{uniform:s,offset:a,shape:l,texShape:f}=t.variablesLocations[u];if(l){const{uniformShape:n}=i.YE(t.program.packedInputs,o.shape,o.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(l,new Int32Array(n));break;case 2:e.gl.uniform2iv(l,new Int32Array(n));break;case 3:e.gl.uniform3iv(l,new Int32Array(n));break;case 4:e.gl.uniform4iv(l,new Int32Array(n));break;default:break}}if(f&&e.gl.uniform2i(f,o.texData.texShape[0],o.texData.texShape[1]),null!=s)if(o.isUniform)if(r.ZSL.sizeFromShape(o.shape)<2)e.gl.uniform1f(s,o.uniformValues[0]);else{let t=o.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(s,t)}else null!=o.texData.slice&&null!=a&&e.gl.uniform1i(a,o.texData.slice.flatOffset),e.setInputMatrixTexture(o.texData.texture.texture,s,u)}const f=t.outShapeLocation;if(f)switch(o.shape.length){case 1:e.gl.uniform1iv(f,new Int32Array(o.shape));break;case 2:e.gl.uniform2iv(f,new Int32Array(o.shape));break;case 3:e.gl.uniform3iv(f,new Int32Array(o.shape));break;case 4:e.gl.uniform4iv(f,new Int32Array(o.shape));break;default:break}if(t.outShapeStridesLocation){const n=r.ZSL.computeStrides(o.shape);switch(o.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n));break;default:break}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,o.texData.texShape[0],o.texData.texShape[1]),t.program.customUniforms&&s)for(let r=0;r<t.program.customUniforms.length;++r){const n=t.program.customUniforms[r],i=t.customUniformLocations[r],o=s[r];if("float"===n.type)e.gl.uniform1fv(i,o);else if("vec2"===n.type)e.gl.uniform2fv(i,o);else if("vec3"===n.type)e.gl.uniform3fv(i,o);else if("vec4"===n.type)e.gl.uniform4fv(i,o);else if("int"===n.type)e.gl.uniform1iv(i,o);else if("ivec2"===n.type)e.gl.uniform2iv(i,o);else if("ivec3"===n.type)e.gl.uniform3iv(i,o);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(i,o)}}e.executeProgram()}function f(e,t,n){let o="";t.concat(n).forEach((t=>{const s=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const a=t.texData.texShape,{useSqueezeShape:u,uniformShape:l,keptDims:f}=i.YE(e.packedInputs,t.shape,a);let h="",c="",d="";if(1===l.length&&e.packedInputs){const e=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];h=`${e[0]>1}_${e[1]>1}`}else if(2!==l.length||e.packedInputs){if(l.length>2&&!e.packedInputs){const e=r.ZSL.computeStrides(l);d=`${e[0]===a[1]}_${e[e.length-1]===a[1]}`}}else c=`${l[0]>1}_${l[1]>1}`;const g=t.shape.length,m=2===l.length&&r.ZSL.arraysEqual(t.shape,a),p=1===r.ZSL.sizeFromShape(t.shape),E=r.C0T.getBroadcastDims(t.shape,n.shape),x=!e.packedInputs&&g===n.shape.length&&r.ZSL.arraysEqual(a,n.texData.texShape),_=e.packedInputs||l.length>2?"":`${a[0]>1}_${a[1]>1}`;o+=`${g}_${x}_${u?f:""}_${l.length}_${p}_${E}_${m}_${h}_${c}_${d}_${_}_${s}`}else{const e=t.isUniform?"uniform":t.texData.texShape;o+=`${t.shape}_${e}_${s}`}}));const s=e.userCode;let a=e.constructor.name;return a+="_"+o+"_"+s+`${(0,r._K2)().getNumber("WEBGL_VERSION")}`,a}function h(e){return(0,r._K2)().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}},47646:function(e,t,n){n.d(t,{$k:function(){return y},Hw:function(){return p},Ij:function(){return E},J$:function(){return d},Me:function(){return T},Ng:function(){return l},SD:function(){return D},WH:function(){return g},Z:function(){return S},b1:function(){return u},bG:function(){return x},cD:function(){return c},fj:function(){return h},ir:function(){return R},qg:function(){return I},uS:function(){return L},wM:function(){return m},y7:function(){return b},yr:function(){return a},z8:function(){return _},zP:function(){return v}});var r=n(9495),i=n(18765),o=n(28560),s=n(88380);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function a(e){const t=(0,i.B)(),n=`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`;return s.yr(e,n)}function u(e){const t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return s.HW(e,t)}function l(e){const t=new Uint16Array([0,1,2,2,1,3]);return s.$e(e,t)}function f(e,t,n,i,o,a){s.ph(t,n);const u=s.sZ(e),l=e.TEXTURE_2D;return s.ul(e,(()=>e.bindTexture(l,u))),s.ul(e,(()=>e.texParameteri(l,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),s.ul(e,(()=>e.texParameteri(l,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),s.ul(e,(()=>e.texParameteri(l,e.TEXTURE_MIN_FILTER,e.NEAREST))),s.ul(e,(()=>e.texParameteri(l,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===(0,r._K2)().getNumber("WEBGL_VERSION")?s.ul(e,(()=>e.texImage2D(l,0,i,t,n,0,o,a,null))):s.ul(e,(()=>e.texStorage2D(l,1,i,t,n))),s.ul(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:u,texShape:[n,t]}}function h(e){return e.internalFormatFloat}function c(e,t,n,r){const[i,s]=o.Qn(t,n);return f(e,i,s,h(r),r.textureFormatFloat,e.FLOAT)}function d(e){return e.internalFormatHalfFloat}function g(e,t,n,r){const[i,s]=o.Qn(t,n);return f(e,i,s,d(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function m(e){return e.downloadTextureFormat}function p(e,t,n,r){const[i,s]=o.Qn(t,n);return f(e,i,s,m(r),e.RGBA,e.UNSIGNED_BYTE)}function E(e){return e.internalFormatPackedFloat}function x(e,t,n,r){const[i,s]=o.NO(t,n);return f(e,i,s,E(r),e.RGBA,e.FLOAT)}function _(e){return e.internalFormatPackedHalfFloat}function T(e,t,n,r){const[i,s]=o.NO(t,n);return f(e,i,s,_(r),e.RGBA,r.textureTypeHalfFloat)}function S(e,t,n){const r=0,i=12,o=20;s.ul(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n)));const a=s.rw(e,t,"clipSpacePos",n,3,o,r);return a&&s.rw(e,t,"uv",n,2,o,i)}function b(e,t,n,i,o,a){let u,l,f;s.ul(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),o instanceof Uint8Array?(u=new Uint8Array(n*i*4),l=e.UNSIGNED_BYTE,f=e.RGBA):(u=new Float32Array(n*i*4),l=e.FLOAT,f=a.internalFormatPackedFloat),u.set(o),2===(0,r._K2)().getNumber("WEBGL_VERSION")?s.ul(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,i,e.RGBA,l,u))):s.ul(e,(()=>e.texImage2D(e.TEXTURE_2D,0,f,n,i,0,e.RGBA,l,u))),s.ul(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function I(e,t,n){s.ul(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===(0,r._K2)().getNumber("WEBGL_VERSION")?s.ul(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):s.ul(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===(0,r._K2)().getNumber("WEBGL_VERSION")?s.ul(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):s.ul(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),s.ul(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function v(e,t,n,r){const i=e.createBuffer();s.ul(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,i)));const o=4,a=4,u=o*a*t*n;return s.ul(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,u,e.STREAM_READ))),s.ul(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),s.ul(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),i}function y(e,t,n){const r=e,i=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,i),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),i}function R(e,t,n,r){const[i,a]=o.Qn(t,n),u=4,l=new Uint8Array(o.EX(t*n,u));return s.ul(e,(()=>e.readPixels(0,0,i,a,r.downloadTextureFormat,e.UNSIGNED_BYTE,l))),new Float32Array(l.buffer)}function D(e,t,n,r,i,s,a,u){const l=e,f=new Float32Array(o.PM(s,a));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,f),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),f}function L(e,t,n){const r=new Float32Array(t*n*4);return s.ul(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}},58638:function(e,t,n){n.d(t,{D:function(){return o}});var r=n(18765),i=n(22792);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class o{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=(0,i.ik)(this.outputShape.length);const{dataFormat:n}=t,o=(0,r.B)(),s="channelsLast"===n,a=s?1:2,u=s?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let f="";for(let r=0;r<=1;r++)for(let e=0;e<=1;e++)f+=`\n          blockIndex = rc.z + ${e};\n          pos = rc.y + ${r};\n\n          ${l}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${a}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${u}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${s}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*r+e}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*r+e}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${f}\n\n        ${o.output} = result;\n      }\n    `}}},58044:function(e,t,n){n(86819),n(76202)}}]);
//# sourceMappingURL=chunk-vendors-fefd169c.7b10ed07.js.map