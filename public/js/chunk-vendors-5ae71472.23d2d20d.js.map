{"version":3,"file":"js/chunk-vendors-5ae71472.23d2d20d.js","mappings":"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","sources":["webpack://benefit/./node_modules/@tensorflow/tfjs-backend-webgl/dist/pack_gpu.js","webpack://benefit/./node_modules/@tensorflow/tfjs-backend-webgl/dist/packing_util.js","webpack://benefit/./node_modules/@tensorflow/tfjs-backend-webgl/dist/pad_gpu.js","webpack://benefit/./node_modules/@tensorflow/tfjs-backend-webgl/dist/pad_packed_gpu.js","webpack://benefit/./node_modules/@tensorflow/tfjs-backend-webgl/dist/pool_gpu.js","webpack://benefit/./node_modules/@tensorflow/tfjs-backend-webgl/dist/reduce_gpu.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { useShapeUniforms } from './gpgpu_math';\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class PackProgram {\n    constructor(outputShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = false;\n        this.packedOutput = true;\n        // Only input / output 3D tensors.\n        this.outputShape = outputShape;\n        this.rank = outputShape.length;\n        this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);\n        if (this.rank === 0) {\n            this.userCode = `\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      `;\n        }\n        else {\n            const channels = getChannels('rc', this.rank);\n            const dtype = getCoordsDataType(this.rank);\n            const outOfBoundsCondition = this.getOutOfBoundsCondition(channels);\n            const setup = this.getSetup(channels);\n            const output = this.getOutput(channels);\n            this.userCode = `\n        void main() {\n          ${dtype} rc = getOutputCoords();\n\n          if(${outOfBoundsCondition}) {\n            setOutput(vec4(0));\n          } else {\n            ${setup}\n\n            setOutput(vec4(${output}));\n          }\n        }\n      `;\n        }\n    }\n    getSourceCoordsArr(dims) {\n        const coords = [];\n        for (let row = 0; row <= 1; row++) {\n            for (let col = 0; col <= 1; col++) {\n                let coord = `${row === 0 ? 'r' : 'rp1'}, ${col === 0 ? 'c' : 'cp1'}`;\n                for (let d = 2; d < this.rank; d++) {\n                    coord = `${dims[dims.length - 1 - d]},` + coord;\n                }\n                coords.push(coord);\n            }\n        }\n        return coords;\n    }\n    getOutOfBoundsCondition(dims) {\n        if (this.rank === 1) {\n            return `rc > ${this.enableShapeUniforms ? 'outShape' : this.outputShape[0]}`;\n        }\n        let cond = '';\n        for (let i = this.rank - 2; i < this.rank; i++) {\n            cond += `${dims[i]} >= ${this.enableShapeUniforms ? `outShape[${i}]` : this.outputShape[i]}`;\n            if (i < this.rank - 1) {\n                cond += '||';\n            }\n        }\n        return cond;\n    }\n    getSetup(dims) {\n        if (this.rank === 1) {\n            return '';\n        }\n        const innerDims = dims.slice(-2);\n        const col = this.enableShapeUniforms ? `outShape[${this.rank} - 1]` :\n            this.outputShape[this.rank - 1];\n        const row = this.enableShapeUniforms ? `outShape[${this.rank} - 2]` :\n            this.outputShape[this.rank - 2];\n        return `\n      int r = ${innerDims[0]};\n      int c = ${innerDims[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${col};\n      bool rEdge = rp1 >= ${row};\n    `;\n    }\n    getOutput(dims) {\n        const sourceCoords = this.getSourceCoordsArr(dims);\n        if (this.rank === 1) {\n            const outShape = this.enableShapeUniforms ? 'outShape' : this.outputShape[0];\n            return `getA(rc), (rc + 1 >= ${outShape} ? 0. : getA(rc + 1)), 0, 0`;\n        }\n        return `getA(${sourceCoords[0]}),\n            cEdge ? 0. : getA(${sourceCoords[1]}),\n            rEdge ? 0. : getA(${sourceCoords[2]}),\n            rEdge || cEdge ? 0. : getA(${sourceCoords[3]})`;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFja19ncHUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtd2ViZ2wvc3JjL3BhY2tfZ3B1LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUVILE9BQU8sRUFBZSxnQkFBZ0IsRUFBQyxNQUFNLGNBQWMsQ0FBQztBQUM1RCxPQUFPLEVBQUMsV0FBVyxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFDM0MsT0FBTyxFQUFDLGlCQUFpQixFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFFcEQsTUFBTSxPQUFPLFdBQVc7SUFTdEIsWUFDSSxXQUNZO1FBVmhCLGtCQUFhLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUd0QixpQkFBWSxHQUFHLEtBQUssQ0FBQztRQUNyQixpQkFBWSxHQUFHLElBQUksQ0FBQztRQU9DLGtDQUFrQztRQUNyRCxJQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQztRQUMvQixJQUFJLENBQUMsSUFBSSxHQUFHLFdBQVcsQ0FBQyxNQUFNLENBQUM7UUFDL0IsSUFBSSxDQUFDLG1CQUFtQixHQUFHLGdCQUFnQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFckUsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBRTtZQUNuQixJQUFJLENBQUMsUUFBUSxHQUFHOzs7O09BSWYsQ0FBQztTQUNIO2FBQU07WUFDTCxNQUFNLFFBQVEsR0FBRyxXQUFXLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUM5QyxNQUFNLEtBQUssR0FBRyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDM0MsTUFBTSxvQkFBb0IsR0FBRyxJQUFJLENBQUMsdUJBQXVCLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDcEUsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUN0QyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRXhDLElBQUksQ0FBQyxRQUFRLEdBQUc7O1lBRVYsS0FBSzs7ZUFFRixvQkFBb0I7OztjQUdyQixLQUFLOzs2QkFFVSxNQUFNOzs7T0FHNUIsQ0FBQztTQUNIO0lBQ0gsQ0FBQztJQUVPLGtCQUFrQixDQUFDLElBQWM7UUFDdkMsTUFBTSxNQUFNLEdBQUcsRUFBRSxDQUFDO1FBRWxCLEtBQUssSUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUU7WUFDakMsS0FBSyxJQUFJLEdBQUcsR0FBRyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsRUFBRTtnQkFDakMsSUFBSSxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssS0FBSyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDO2dCQUVyRSxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRTtvQkFDbEMsS0FBSyxHQUFHLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDO2lCQUNqRDtnQkFFRCxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQ3BCO1NBQ0Y7UUFDRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRU8sdUJBQXVCLENBQUMsSUFBYztRQUM1QyxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFFO1lBQ25CLE9BQU8sUUFDSCxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1NBQ25FO1FBRUQsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDO1FBQ2QsS0FBSyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUM5QyxJQUFJLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQ2QsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDeEUsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLEVBQUU7Z0JBQ3JCLElBQUksSUFBSSxJQUFJLENBQUM7YUFDZDtTQUNGO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRU8sUUFBUSxDQUFDLElBQWM7UUFDN0IsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBRTtZQUNuQixPQUFPLEVBQUUsQ0FBQztTQUNYO1FBRUQsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2pDLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsWUFBWSxJQUFJLENBQUMsSUFBSSxPQUFPLENBQUMsQ0FBQztZQUM5QixJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDdkUsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxZQUFZLElBQUksQ0FBQyxJQUFJLE9BQU8sQ0FBQyxDQUFDO1lBQzlCLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQztRQUV2RSxPQUFPO2dCQUNLLFNBQVMsQ0FBQyxDQUFDLENBQUM7Z0JBQ1osU0FBUyxDQUFDLENBQUMsQ0FBQzs7Ozs0QkFJQSxHQUFHOzRCQUNILEdBQUc7S0FDMUIsQ0FBQztJQUNKLENBQUM7SUFFTyxTQUFTLENBQUMsSUFBYztRQUM5QixNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDbkQsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBRTtZQUNuQixNQUFNLFFBQVEsR0FDVixJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNoRSxPQUFPLHdCQUF3QixRQUFRLDZCQUE2QixDQUFDO1NBQ3RFO1FBRUQsT0FBTyxRQUFRLFlBQVksQ0FBQyxDQUFDLENBQUM7Z0NBQ0YsWUFBWSxDQUFDLENBQUMsQ0FBQztnQ0FDZixZQUFZLENBQUMsQ0FBQyxDQUFDO3lDQUNOLFlBQVksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO0lBQzFELENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtHUEdQVVByb2dyYW0sIHVzZVNoYXBlVW5pZm9ybXN9IGZyb20gJy4vZ3BncHVfbWF0aCc7XG5pbXBvcnQge2dldENoYW5uZWxzfSBmcm9tICcuL3BhY2tpbmdfdXRpbCc7XG5pbXBvcnQge2dldENvb3Jkc0RhdGFUeXBlfSBmcm9tICcuL3NoYWRlcl9jb21waWxlcic7XG5cbmV4cG9ydCBjbGFzcyBQYWNrUHJvZ3JhbSBpbXBsZW1lbnRzIEdQR1BVUHJvZ3JhbSB7XG4gIHZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgb3V0cHV0U2hhcGU6IG51bWJlcltdO1xuICB1c2VyQ29kZTogc3RyaW5nO1xuICBwYWNrZWRJbnB1dHMgPSBmYWxzZTtcbiAgcGFja2VkT3V0cHV0ID0gdHJ1ZTtcbiAgZW5hYmxlU2hhcGVVbmlmb3JtczogYm9vbGVhbjtcbiAgcmFuazogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgb3V0cHV0U2hhcGU6XG4gICAgICAgICAgbnVtYmVyW10pIHsgIC8vIFRPRE8oaHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGZqcy9pc3N1ZXMvODkzKTpcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBpbnB1dCAvIG91dHB1dCAzRCB0ZW5zb3JzLlxuICAgIHRoaXMub3V0cHV0U2hhcGUgPSBvdXRwdXRTaGFwZTtcbiAgICB0aGlzLnJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gICAgdGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zID0gdXNlU2hhcGVVbmlmb3Jtcyh0aGlzLm91dHB1dFNoYXBlLmxlbmd0aCk7XG5cbiAgICBpZiAodGhpcy5yYW5rID09PSAwKSB7XG4gICAgICB0aGlzLnVzZXJDb2RlID0gYFxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgc2V0T3V0cHV0KHZlYzQoZ2V0QSgpLCAwLiwgMC4sIDAuKSk7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNoYW5uZWxzID0gZ2V0Q2hhbm5lbHMoJ3JjJywgdGhpcy5yYW5rKTtcbiAgICAgIGNvbnN0IGR0eXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUodGhpcy5yYW5rKTtcbiAgICAgIGNvbnN0IG91dE9mQm91bmRzQ29uZGl0aW9uID0gdGhpcy5nZXRPdXRPZkJvdW5kc0NvbmRpdGlvbihjaGFubmVscyk7XG4gICAgICBjb25zdCBzZXR1cCA9IHRoaXMuZ2V0U2V0dXAoY2hhbm5lbHMpO1xuICAgICAgY29uc3Qgb3V0cHV0ID0gdGhpcy5nZXRPdXRwdXQoY2hhbm5lbHMpO1xuXG4gICAgICB0aGlzLnVzZXJDb2RlID0gYFxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgJHtkdHlwZX0gcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcblxuICAgICAgICAgIGlmKCR7b3V0T2ZCb3VuZHNDb25kaXRpb259KSB7XG4gICAgICAgICAgICBzZXRPdXRwdXQodmVjNCgwKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICR7c2V0dXB9XG5cbiAgICAgICAgICAgIHNldE91dHB1dCh2ZWM0KCR7b3V0cHV0fSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgYDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldFNvdXJjZUNvb3Jkc0FycihkaW1zOiBzdHJpbmdbXSk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCBjb29yZHMgPSBbXTtcblxuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8PSAxOyByb3crKykge1xuICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDw9IDE7IGNvbCsrKSB7XG4gICAgICAgIGxldCBjb29yZCA9IGAke3JvdyA9PT0gMCA/ICdyJyA6ICdycDEnfSwgJHtjb2wgPT09IDAgPyAnYycgOiAnY3AxJ31gO1xuXG4gICAgICAgIGZvciAobGV0IGQgPSAyOyBkIDwgdGhpcy5yYW5rOyBkKyspIHtcbiAgICAgICAgICBjb29yZCA9IGAke2RpbXNbZGltcy5sZW5ndGggLSAxIC0gZF19LGAgKyBjb29yZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvb3Jkcy5wdXNoKGNvb3JkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvb3JkcztcbiAgfVxuXG4gIHByaXZhdGUgZ2V0T3V0T2ZCb3VuZHNDb25kaXRpb24oZGltczogc3RyaW5nW10pOiBzdHJpbmcge1xuICAgIGlmICh0aGlzLnJhbmsgPT09IDEpIHtcbiAgICAgIHJldHVybiBgcmMgPiAke1xuICAgICAgICAgIHRoaXMuZW5hYmxlU2hhcGVVbmlmb3JtcyA/ICdvdXRTaGFwZScgOiB0aGlzLm91dHB1dFNoYXBlWzBdfWA7XG4gICAgfVxuXG4gICAgbGV0IGNvbmQgPSAnJztcbiAgICBmb3IgKGxldCBpID0gdGhpcy5yYW5rIC0gMjsgaSA8IHRoaXMucmFuazsgaSsrKSB7XG4gICAgICBjb25kICs9IGAke2RpbXNbaV19ID49ICR7XG4gICAgICAgICAgdGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zID8gYG91dFNoYXBlWyR7aX1dYCA6IHRoaXMub3V0cHV0U2hhcGVbaV19YDtcbiAgICAgIGlmIChpIDwgdGhpcy5yYW5rIC0gMSkge1xuICAgICAgICBjb25kICs9ICd8fCc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmQ7XG4gIH1cblxuICBwcml2YXRlIGdldFNldHVwKGRpbXM6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgICBpZiAodGhpcy5yYW5rID09PSAxKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgY29uc3QgaW5uZXJEaW1zID0gZGltcy5zbGljZSgtMik7XG4gICAgY29uc3QgY29sID0gdGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zID8gYG91dFNoYXBlWyR7dGhpcy5yYW5rfSAtIDFdYCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTaGFwZVt0aGlzLnJhbmsgLSAxXTtcbiAgICBjb25zdCByb3cgPSB0aGlzLmVuYWJsZVNoYXBlVW5pZm9ybXMgPyBgb3V0U2hhcGVbJHt0aGlzLnJhbmt9IC0gMl1gIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFNoYXBlW3RoaXMucmFuayAtIDJdO1xuXG4gICAgcmV0dXJuIGBcbiAgICAgIGludCByID0gJHtpbm5lckRpbXNbMF19O1xuICAgICAgaW50IGMgPSAke2lubmVyRGltc1sxXX07XG4gICAgICBpbnQgcnAxID0gciArIDE7XG4gICAgICBpbnQgY3AxID0gYyArIDE7XG5cbiAgICAgIGJvb2wgY0VkZ2UgPSBjcDEgPj0gJHtjb2x9O1xuICAgICAgYm9vbCByRWRnZSA9IHJwMSA+PSAke3Jvd307XG4gICAgYDtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0T3V0cHV0KGRpbXM6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgICBjb25zdCBzb3VyY2VDb29yZHMgPSB0aGlzLmdldFNvdXJjZUNvb3Jkc0FycihkaW1zKTtcbiAgICBpZiAodGhpcy5yYW5rID09PSAxKSB7XG4gICAgICBjb25zdCBvdXRTaGFwZSA9XG4gICAgICAgICAgdGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zID8gJ291dFNoYXBlJyA6IHRoaXMub3V0cHV0U2hhcGVbMF07XG4gICAgICByZXR1cm4gYGdldEEocmMpLCAocmMgKyAxID49ICR7b3V0U2hhcGV9ID8gMC4gOiBnZXRBKHJjICsgMSkpLCAwLCAwYDtcbiAgICB9XG5cbiAgICByZXR1cm4gYGdldEEoJHtzb3VyY2VDb29yZHNbMF19KSxcbiAgICAgICAgICAgIGNFZGdlID8gMC4gOiBnZXRBKCR7c291cmNlQ29vcmRzWzFdfSksXG4gICAgICAgICAgICByRWRnZSA/IDAuIDogZ2V0QSgke3NvdXJjZUNvb3Jkc1syXX0pLFxuICAgICAgICAgICAgckVkZ2UgfHwgY0VkZ2UgPyAwLiA6IGdldEEoJHtzb3VyY2VDb29yZHNbM119KWA7XG4gIH1cbn1cbiJdfQ==","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport function getVecChannels(name, rank) {\n    return ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank).map(d => `${name}.${d}`);\n}\nexport function getChannels(name, rank) {\n    if (rank === 1) {\n        return [name];\n    }\n    return getVecChannels(name, rank);\n}\nexport function getSourceCoords(rank, dims) {\n    if (rank === 1) {\n        return 'rc';\n    }\n    let coords = '';\n    for (let i = 0; i < rank; i++) {\n        coords += dims[i];\n        if (i < rank - 1) {\n            coords += ',';\n        }\n    }\n    return coords;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFja2luZ191dGlsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vdGZqcy1iYWNrZW5kLXdlYmdsL3NyYy9wYWNraW5nX3V0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsTUFBTSxVQUFVLGNBQWMsQ0FBQyxJQUFZLEVBQUUsSUFBWTtJQUN2RCxPQUFPLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDaEYsQ0FBQztBQUVELE1BQU0sVUFBVSxXQUFXLENBQUMsSUFBWSxFQUFFLElBQVk7SUFDcEQsSUFBSSxJQUFJLEtBQUssQ0FBQyxFQUFFO1FBQ2QsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ2Y7SUFDRCxPQUFPLGNBQWMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDcEMsQ0FBQztBQUVELE1BQU0sVUFBVSxlQUFlLENBQUMsSUFBWSxFQUFFLElBQWM7SUFDMUQsSUFBSSxJQUFJLEtBQUssQ0FBQyxFQUFFO1FBQ2QsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUVELElBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQztJQUNoQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQzdCLE1BQU0sSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbEIsSUFBSSxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsRUFBRTtZQUNoQixNQUFNLElBQUksR0FBRyxDQUFDO1NBQ2Y7S0FDRjtJQUNELE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRWZWNDaGFubmVscyhuYW1lOiBzdHJpbmcsIHJhbms6IG51bWJlcik6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIFsneCcsICd5JywgJ3onLCAndycsICd1JywgJ3YnXS5zbGljZSgwLCByYW5rKS5tYXAoZCA9PiBgJHtuYW1lfS4ke2R9YCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaGFubmVscyhuYW1lOiBzdHJpbmcsIHJhbms6IG51bWJlcik6IHN0cmluZ1tdIHtcbiAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICByZXR1cm4gW25hbWVdO1xuICB9XG4gIHJldHVybiBnZXRWZWNDaGFubmVscyhuYW1lLCByYW5rKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNvdXJjZUNvb3JkcyhyYW5rOiBudW1iZXIsIGRpbXM6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICByZXR1cm4gJ3JjJztcbiAgfVxuXG4gIGxldCBjb29yZHMgPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rOyBpKyspIHtcbiAgICBjb29yZHMgKz0gZGltc1tpXTtcbiAgICBpZiAoaSA8IHJhbmsgLSAxKSB7XG4gICAgICBjb29yZHMgKz0gJywnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29vcmRzO1xufSJdfQ==","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class PadProgram {\n    constructor(xShape, paddings, constantValue) {\n        this.variableNames = ['x'];\n        this.customUniforms = [{ name: 'value', type: 'float' }];\n        this.outputShape = paddings.map((p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);\n        const rank = xShape.length;\n        const type = getCoordsDataType(rank);\n        const start = paddings.map(p => p[0]).join(',');\n        const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');\n        const unpackedCoords = ['coords[0]', 'coords[1]', 'coords[2]', 'coords[3]'].slice(0, rank);\n        if (rank === 1) {\n            this.userCode = `\n        int start = ${start};\n        int end = ${end};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `;\n            return;\n        }\n        this.userCode = `\n      ${type} start = ${type}(${start});\n      ${type} end = ${type}(${end});\n\n      void main() {\n        ${type} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${type} coords = outC - start;\n          setOutput(getX(${unpackedCoords}));\n        }\n      }\n    `;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFkX2dwdS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RmanMtYmFja2VuZC13ZWJnbC9zcmMvcGFkX2dwdS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFHSCxPQUFPLEVBQUMsaUJBQWlCLEVBQWMsTUFBTSxtQkFBbUIsQ0FBQztBQUVqRSxNQUFNLE9BQU8sVUFBVTtJQU1yQixZQUNJLE1BQWdCLEVBQUUsUUFBaUMsRUFDbkQsYUFBcUI7UUFQekIsa0JBQWEsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBR3RCLG1CQUFjLEdBQUcsQ0FBQyxFQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE9BQXNCLEVBQUMsQ0FBQyxDQUFDO1FBSy9ELElBQUksQ0FBQyxXQUFXLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FDM0IsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsZUFBZSxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDdEUsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztRQUMzQixNQUFNLElBQUksR0FBRyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUVyQyxNQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2hELE1BQU0sR0FBRyxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQy9ELE1BQU0sY0FBYyxHQUNoQixDQUFDLFdBQVcsRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFLFdBQVcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFFeEUsSUFBSSxJQUFJLEtBQUssQ0FBQyxFQUFFO1lBQ2QsSUFBSSxDQUFDLFFBQVEsR0FBRztzQkFDQSxLQUFLO29CQUNQLEdBQUc7Ozs7Ozs7Ozs7T0FVaEIsQ0FBQztZQUNGLE9BQU87U0FDUjtRQUNELElBQUksQ0FBQyxRQUFRLEdBQUc7UUFDWixJQUFJLFlBQVksSUFBSSxJQUFJLEtBQUs7UUFDN0IsSUFBSSxVQUFVLElBQUksSUFBSSxHQUFHOzs7VUFHdkIsSUFBSTs7OztZQUlGLElBQUk7MkJBQ1csY0FBYzs7O0tBR3BDLENBQUM7SUFDSixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7R1BHUFVQcm9ncmFtfSBmcm9tICcuL2dwZ3B1X21hdGgnO1xuaW1wb3J0IHtnZXRDb29yZHNEYXRhVHlwZSwgVW5pZm9ybVR5cGV9IGZyb20gJy4vc2hhZGVyX2NvbXBpbGVyJztcblxuZXhwb3J0IGNsYXNzIFBhZFByb2dyYW0gaW1wbGVtZW50cyBHUEdQVVByb2dyYW0ge1xuICB2YXJpYWJsZU5hbWVzID0gWyd4J107XG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXTtcbiAgdXNlckNvZGU6IHN0cmluZztcbiAgY3VzdG9tVW5pZm9ybXMgPSBbe25hbWU6ICd2YWx1ZScsIHR5cGU6ICdmbG9hdCcgYXMgVW5pZm9ybVR5cGV9XTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICAgIHhTaGFwZTogbnVtYmVyW10sIHBhZGRpbmdzOiBBcnJheTxbbnVtYmVyLCBudW1iZXJdPixcbiAgICAgIGNvbnN0YW50VmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMub3V0cHV0U2hhcGUgPSBwYWRkaW5ncy5tYXAoXG4gICAgICAgIChwLCBpKSA9PiBwWzBdIC8qIGJlZm9yZVBhZCAqLyArIHhTaGFwZVtpXSArIHBbMV0gLyogYWZ0ZXJQYWQgKi8pO1xuICAgIGNvbnN0IHJhbmsgPSB4U2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IHR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShyYW5rKTtcblxuICAgIGNvbnN0IHN0YXJ0ID0gcGFkZGluZ3MubWFwKHAgPT4gcFswXSkuam9pbignLCcpO1xuICAgIGNvbnN0IGVuZCA9IHBhZGRpbmdzLm1hcCgocCwgaSkgPT4gcFswXSArIHhTaGFwZVtpXSkuam9pbignLCcpO1xuICAgIGNvbnN0IHVucGFja2VkQ29vcmRzID1cbiAgICAgICAgWydjb29yZHNbMF0nLCAnY29vcmRzWzFdJywgJ2Nvb3Jkc1syXScsICdjb29yZHNbM10nXS5zbGljZSgwLCByYW5rKTtcblxuICAgIGlmIChyYW5rID09PSAxKSB7XG4gICAgICB0aGlzLnVzZXJDb2RlID0gYFxuICAgICAgICBpbnQgc3RhcnQgPSAke3N0YXJ0fTtcbiAgICAgICAgaW50IGVuZCA9ICR7ZW5kfTtcblxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgaW50IG91dEMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgICBpZiAob3V0QyA8IHN0YXJ0IHx8IG91dEMgPj0gZW5kKSB7XG4gICAgICAgICAgICBzZXRPdXRwdXQodmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRPdXRwdXQoZ2V0WChvdXRDIC0gc3RhcnQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudXNlckNvZGUgPSBgXG4gICAgICAke3R5cGV9IHN0YXJ0ID0gJHt0eXBlfSgke3N0YXJ0fSk7XG4gICAgICAke3R5cGV9IGVuZCA9ICR7dHlwZX0oJHtlbmR9KTtcblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAke3R5cGV9IG91dEMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaWYgKGFueShsZXNzVGhhbihvdXRDLCBzdGFydCkpIHx8IGFueShncmVhdGVyVGhhbkVxdWFsKG91dEMsIGVuZCkpKSB7XG4gICAgICAgICAgc2V0T3V0cHV0KHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAke3R5cGV9IGNvb3JkcyA9IG91dEMgLSBzdGFydDtcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0WCgke3VucGFja2VkQ29vcmRzfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgYDtcbiAgfVxufVxuIl19","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class PadPackedProgram {\n    constructor(xShape, paddings, constantValue) {\n        this.variableNames = ['x'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.customUniforms = [{ name: 'value', type: 'float' }];\n        this.outputShape = paddings.map((p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);\n        const rank = xShape.length;\n        const dtype = getCoordsDataType(rank);\n        const start = paddings.map(p => p[0]).join(',');\n        const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');\n        const coords = getChannels('rc', rank);\n        const source = getChannels('source', rank);\n        const cLimit = `${coords[rank - 1]} < ${this.outputShape[rank - 1]}`;\n        const innerDims = rank === 1 ? 'source' : `vec2(${source.slice(-2).join()})`;\n        const componentSetup = [\n            `${dtype} rc = outputLoc;`, `${coords[rank - 1]} += 1;\n       if(${cLimit}) {\n      `,\n            rank === 1 ? '' : `}\n       rc = outputLoc;\n       ${coords[rank - 2]} += 1;\n       if(${coords[rank - 2]} < ${this.outputShape[rank - 2]}) {`,\n            rank === 1 ? '' : `  ${coords[rank - 1]} += 1;\n         if(${cLimit}) {`\n        ];\n        const paddingArea = rank === 1 ?\n            'rc < start || rc >= end' :\n            'any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))';\n        let mainLoop = '';\n        for (let i = 0, j = rank === 1 ? 2 : 4; i < j; i++) {\n            mainLoop += `\n        ${componentSetup[i]}\n        if (${paddingArea}) {\n          result[${i}] = float(value);\n        } else {\n          ${dtype} source = rc - start;\n          result[${i}] = getChannel(getX(${source.join()}), ${innerDims});\n        }\n      `;\n        }\n        mainLoop += (rank === 1 ? `} ` : `}}`);\n        this.userCode = `\n      const ${dtype} start = ${dtype}(${start});\n      const ${dtype} end = ${dtype}(${end});\n\n      void main() {\n        ${dtype} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${mainLoop}\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFkX3BhY2tlZF9ncHUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtd2ViZ2wvc3JjL3BhZF9wYWNrZWRfZ3B1LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUdILE9BQU8sRUFBQyxXQUFXLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUMzQyxPQUFPLEVBQUMsaUJBQWlCLEVBQWMsTUFBTSxtQkFBbUIsQ0FBQztBQUVqRSxNQUFNLE9BQU8sZ0JBQWdCO0lBUTNCLFlBQ0ksTUFBZ0IsRUFBRSxRQUFpQyxFQUNuRCxhQUFxQjtRQVR6QixrQkFBYSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDdEIsaUJBQVksR0FBRyxJQUFJLENBQUM7UUFDcEIsaUJBQVksR0FBRyxJQUFJLENBQUM7UUFHcEIsbUJBQWMsR0FBRyxDQUFDLEVBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsT0FBc0IsRUFBQyxDQUFDLENBQUM7UUFLL0QsSUFBSSxDQUFDLFdBQVcsR0FBRyxRQUFRLENBQUMsR0FBRyxDQUMzQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxlQUFlLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUN0RSxNQUFNLElBQUksR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO1FBQzNCLE1BQU0sS0FBSyxHQUFHLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXRDLE1BQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDaEQsTUFBTSxHQUFHLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDL0QsTUFBTSxNQUFNLEdBQUcsV0FBVyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztRQUN2QyxNQUFNLE1BQU0sR0FBRyxXQUFXLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzNDLE1BQU0sTUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsTUFBTSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ3JFLE1BQU0sU0FBUyxHQUNYLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsUUFBUSxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQztRQUUvRCxNQUFNLGNBQWMsR0FBRztZQUNyQixHQUFHLEtBQUssa0JBQWtCLEVBQUUsR0FBRyxNQUFNLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztZQUN6QyxNQUFNO09BQ1g7WUFDRCxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDOztTQUVmLE1BQU0sQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO1lBQ2IsTUFBTSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsTUFBTSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsS0FBSztZQUMzRCxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssTUFBTSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7Y0FDL0IsTUFBTSxLQUFLO1NBQ3BCLENBQUM7UUFFRixNQUFNLFdBQVcsR0FBRyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFDNUIseUJBQXlCLENBQUMsQ0FBQztZQUMzQiw0REFBNEQsQ0FBQztRQUNqRSxJQUFJLFFBQVEsR0FBRyxFQUFFLENBQUM7UUFDbEIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDbEQsUUFBUSxJQUFJO1VBQ1IsY0FBYyxDQUFDLENBQUMsQ0FBQztjQUNiLFdBQVc7bUJBQ04sQ0FBQzs7WUFFUixLQUFLO21CQUNFLENBQUMsdUJBQXVCLE1BQU0sQ0FBQyxJQUFJLEVBQUUsTUFBTSxTQUFTOztPQUVoRSxDQUFDO1NBQ0g7UUFDRCxRQUFRLElBQUksQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXZDLElBQUksQ0FBQyxRQUFRLEdBQUc7Y0FDTixLQUFLLFlBQVksS0FBSyxJQUFJLEtBQUs7Y0FDL0IsS0FBSyxVQUFVLEtBQUssSUFBSSxHQUFHOzs7VUFHL0IsS0FBSzs7VUFFTCxRQUFROzs7S0FHYixDQUFDO0lBQ0osQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge0dQR1BVUHJvZ3JhbX0gZnJvbSAnLi9ncGdwdV9tYXRoJztcbmltcG9ydCB7Z2V0Q2hhbm5lbHN9IGZyb20gJy4vcGFja2luZ191dGlsJztcbmltcG9ydCB7Z2V0Q29vcmRzRGF0YVR5cGUsIFVuaWZvcm1UeXBlfSBmcm9tICcuL3NoYWRlcl9jb21waWxlcic7XG5cbmV4cG9ydCBjbGFzcyBQYWRQYWNrZWRQcm9ncmFtIGltcGxlbWVudHMgR1BHUFVQcm9ncmFtIHtcbiAgdmFyaWFibGVOYW1lcyA9IFsneCddO1xuICBwYWNrZWRJbnB1dHMgPSB0cnVlO1xuICBwYWNrZWRPdXRwdXQgPSB0cnVlO1xuICBvdXRwdXRTaGFwZTogbnVtYmVyW107XG4gIHVzZXJDb2RlOiBzdHJpbmc7XG4gIGN1c3RvbVVuaWZvcm1zID0gW3tuYW1lOiAndmFsdWUnLCB0eXBlOiAnZmxvYXQnIGFzIFVuaWZvcm1UeXBlfV07XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICB4U2hhcGU6IG51bWJlcltdLCBwYWRkaW5nczogQXJyYXk8W251bWJlciwgbnVtYmVyXT4sXG4gICAgICBjb25zdGFudFZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLm91dHB1dFNoYXBlID0gcGFkZGluZ3MubWFwKFxuICAgICAgICAocCwgaSkgPT4gcFswXSAvKiBiZWZvcmVQYWQgKi8gKyB4U2hhcGVbaV0gKyBwWzFdIC8qIGFmdGVyUGFkICovKTtcbiAgICBjb25zdCByYW5rID0geFNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBkdHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKHJhbmspO1xuXG4gICAgY29uc3Qgc3RhcnQgPSBwYWRkaW5ncy5tYXAocCA9PiBwWzBdKS5qb2luKCcsJyk7XG4gICAgY29uc3QgZW5kID0gcGFkZGluZ3MubWFwKChwLCBpKSA9PiBwWzBdICsgeFNoYXBlW2ldKS5qb2luKCcsJyk7XG4gICAgY29uc3QgY29vcmRzID0gZ2V0Q2hhbm5lbHMoJ3JjJywgcmFuayk7XG4gICAgY29uc3Qgc291cmNlID0gZ2V0Q2hhbm5lbHMoJ3NvdXJjZScsIHJhbmspO1xuICAgIGNvbnN0IGNMaW1pdCA9IGAke2Nvb3Jkc1tyYW5rIC0gMV19IDwgJHt0aGlzLm91dHB1dFNoYXBlW3JhbmsgLSAxXX1gO1xuICAgIGNvbnN0IGlubmVyRGltcyA9XG4gICAgICAgIHJhbmsgPT09IDEgPyAnc291cmNlJyA6IGB2ZWMyKCR7c291cmNlLnNsaWNlKC0yKS5qb2luKCl9KWA7XG5cbiAgICBjb25zdCBjb21wb25lbnRTZXR1cCA9IFtcbiAgICAgIGAke2R0eXBlfSByYyA9IG91dHB1dExvYztgLCBgJHtjb29yZHNbcmFuayAtIDFdfSArPSAxO1xuICAgICAgIGlmKCR7Y0xpbWl0fSkge1xuICAgICAgYCxcbiAgICAgIHJhbmsgPT09IDEgPyAnJyA6IGB9XG4gICAgICAgcmMgPSBvdXRwdXRMb2M7XG4gICAgICAgJHtjb29yZHNbcmFuayAtIDJdfSArPSAxO1xuICAgICAgIGlmKCR7Y29vcmRzW3JhbmsgLSAyXX0gPCAke3RoaXMub3V0cHV0U2hhcGVbcmFuayAtIDJdfSkge2AsXG4gICAgICByYW5rID09PSAxID8gJycgOiBgICAke2Nvb3Jkc1tyYW5rIC0gMV19ICs9IDE7XG4gICAgICAgICBpZigke2NMaW1pdH0pIHtgXG4gICAgXTtcblxuICAgIGNvbnN0IHBhZGRpbmdBcmVhID0gcmFuayA9PT0gMSA/XG4gICAgICAgICdyYyA8IHN0YXJ0IHx8IHJjID49IGVuZCcgOlxuICAgICAgICAnYW55KGxlc3NUaGFuKHJjLCBzdGFydCkpIHx8IGFueShncmVhdGVyVGhhbkVxdWFsKHJjLCBlbmQpKSc7XG4gICAgbGV0IG1haW5Mb29wID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSByYW5rID09PSAxID8gMiA6IDQ7IGkgPCBqOyBpKyspIHtcbiAgICAgIG1haW5Mb29wICs9IGBcbiAgICAgICAgJHtjb21wb25lbnRTZXR1cFtpXX1cbiAgICAgICAgaWYgKCR7cGFkZGluZ0FyZWF9KSB7XG4gICAgICAgICAgcmVzdWx0WyR7aX1dID0gZmxvYXQodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICR7ZHR5cGV9IHNvdXJjZSA9IHJjIC0gc3RhcnQ7XG4gICAgICAgICAgcmVzdWx0WyR7aX1dID0gZ2V0Q2hhbm5lbChnZXRYKCR7c291cmNlLmpvaW4oKX0pLCAke2lubmVyRGltc30pO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIH1cbiAgICBtYWluTG9vcCArPSAocmFuayA9PT0gMSA/IGB9IGAgOiBgfX1gKTtcblxuICAgIHRoaXMudXNlckNvZGUgPSBgXG4gICAgICBjb25zdCAke2R0eXBlfSBzdGFydCA9ICR7ZHR5cGV9KCR7c3RhcnR9KTtcbiAgICAgIGNvbnN0ICR7ZHR5cGV9IGVuZCA9ICR7ZHR5cGV9KCR7ZW5kfSk7XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgJHtkdHlwZX0gb3V0cHV0TG9jID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XG4gICAgICAgICR7bWFpbkxvb3B9XG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xuICAgICAgfVxuICAgIGA7XG4gIH1cbn1cbiJdfQ==","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class Pool2DProgram {\n    constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {\n        this.variableNames = ['x'];\n        if (poolType === 'avg' && computePositions) {\n            throw new Error('Cannot compute positions for average pool.');\n        }\n        const filterWidth = convInfo.filterWidth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        this.outputShape = convInfo.outShape;\n        const isAvgPool = poolType === 'avg';\n        const batchFlattenPositionStr = `((batch  * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;\n        const flattenPositionStr = `(xR * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;\n        let initializationValue = '0.0';\n        if (!isAvgPool) {\n            // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n            initializationValue = '-1.0 / 1e-20';\n        }\n        if (computePositions) {\n            const compareOp = '>=';\n            this.userCode = `\n        const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n        const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n              wR += ${dilationHeight}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${effectiveFilterWidth};\n                wC += ${dilationWidth}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${compareOp} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${flattenPositions ? (includeBatchInIndex ? batchFlattenPositionStr :\n                flattenPositionStr) :\n                `wR * ${effectiveFilterWidth} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;\n            return;\n        }\n        const compareOp = 'max';\n        let returnValue = `${poolType}(${poolType}(${poolType}(` +\n            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n        if (poolType === 'avg') {\n            returnValue = `avgValue / max(count, 1.0)`;\n        }\n        const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n        const filterWidthVec4Remainder = filterWidth % 4;\n        const updateSnippet = `\n      if (${isAvgPool}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n      }\n    `;\n        this.userCode = `\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${convInfo.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${initializationValue});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${effectiveFilterHeight};\n            wR += ${dilationHeight}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${convInfo.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {\n            int xC = xCCorner + wC * ${dilationWidth};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),\n              getValue(batch, xR, xC + 3 * ${dilationWidth}, d)\n            );\n\n            ${updateSnippet}\n          }\n\n          int xC = xCCorner + ${filterWidthNearestVec4};\n          if (${filterWidthVec4Remainder === 1}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${updateSnippet}\n          } else if (${filterWidthVec4Remainder === 2}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${updateSnippet}\n          } else if (${filterWidthVec4Remainder === 3}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),\n              initializationValue\n            );\n\n            ${updateSnippet}\n          }\n        }\n        setOutput(${returnValue});\n      }\n    `;\n    }\n}\nexport class Pool3DProgram {\n    constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {\n        this.variableNames = ['x'];\n        if (poolType === 'avg' && computePositions) {\n            throw new Error('Cannot compute positions for average pool.');\n        }\n        const filterWidth = convInfo.filterWidth;\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationDepth = convInfo.dilationDepth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padFront = convInfo.padInfo.front;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        this.outputShape = convInfo.outShape;\n        const isAvgPool = poolType === 'avg';\n        let initializationValue = '0.0';\n        if (!isAvgPool) {\n            // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n            initializationValue = '-1.0 / 1e-20';\n        }\n        if (computePositions) {\n            const compareOp = '>=';\n            this.userCode = `\n        const ivec3 strides =\n            ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\n        const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${effectiveFilterDepth};\n              wD += ${dilationDepth}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${convInfo.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${effectiveFilterHeight};\n                wR += ${dilationHeight}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${convInfo.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${effectiveFilterWidth};\n                  wC += ${dilationWidth}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${compareOp} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${flattenPositions ?\n                (includeBatchInIndex ?\n                    `(((batch * ${convInfo.inDepth} + xD) * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch` :\n                    `((xD * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch`) :\n                `wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +\n                      wR * ${effectiveFilterWidth} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;\n            return;\n        }\n        const compareOp = 'max';\n        let returnValue = `${poolType}(${poolType}(${poolType}(` +\n            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n        if (poolType === 'avg') {\n            // Use `max(count, 1.0)` instead of `count` in case count === 0.0.\n            // If count === 0.0, `avgValue` is always 0.0 and we change `count`'s\n            // value to avoid dividing zero.\n            returnValue = `avgValue / max(count, 1.0)`;\n        }\n        const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n        const filterWidthVec4Remainder = filterWidth % 4;\n        const updateSnippet = `\n      if (${isAvgPool}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n      }\n    `;\n        this.userCode = `\n      const ivec3 strides =\n        ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${convInfo.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${initializationValue});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${effectiveFilterDepth};\n            wD += ${dilationDepth}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${convInfo.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n            wR += ${dilationHeight}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {\n              int xC = xCCorner + wC * ${dilationWidth};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${dilationWidth}, ch)\n              );\n\n              ${updateSnippet}\n            }\n\n            int xC = xCCorner + ${filterWidthNearestVec4};\n            if (${filterWidthVec4Remainder === 1}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${updateSnippet}\n            } else if (${filterWidthVec4Remainder === 2}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${updateSnippet}\n            } else if (${filterWidthVec4Remainder === 3}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),\n                initializationValue\n              );\n\n              ${updateSnippet}\n            }\n          }\n        }\n        setOutput(${returnValue});\n      }\n    `;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9vbF9ncHUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtd2ViZ2wvc3JjL3Bvb2xfZ3B1LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUtILE1BQU0sT0FBTyxhQUFhO0lBS3hCLFlBQ0ksUUFBaUMsRUFBRSxRQUFxQixFQUN4RCxnQkFBeUIsRUFBRSxnQkFBZ0IsR0FBRyxLQUFLLEVBQ25ELG1CQUFtQixHQUFHLEtBQUs7UUFQL0Isa0JBQWEsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBUXBCLElBQUksUUFBUSxLQUFLLEtBQUssSUFBSSxnQkFBZ0IsRUFBRTtZQUMxQyxNQUFNLElBQUksS0FBSyxDQUFDLDRDQUE0QyxDQUFDLENBQUM7U0FDL0Q7UUFFRCxNQUFNLFdBQVcsR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDO1FBQ3pDLE1BQU0sWUFBWSxHQUFHLFFBQVEsQ0FBQyxZQUFZLENBQUM7UUFDM0MsTUFBTSxXQUFXLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQztRQUN6QyxNQUFNLGNBQWMsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDO1FBQy9DLE1BQU0sYUFBYSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUM7UUFDN0MsTUFBTSxxQkFBcUIsR0FBRyxRQUFRLENBQUMscUJBQXFCLENBQUM7UUFDN0QsTUFBTSxvQkFBb0IsR0FBRyxRQUFRLENBQUMsb0JBQW9CLENBQUM7UUFFM0QsTUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUM7UUFDcEMsTUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUM7UUFDdEMsSUFBSSxDQUFDLFdBQVcsR0FBRyxRQUFRLENBQUMsUUFBUSxDQUFDO1FBRXJDLE1BQU0sU0FBUyxHQUFHLFFBQVEsS0FBSyxLQUFLLENBQUM7UUFDckMsTUFBTSx1QkFBdUIsR0FB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Q0FDM0IsUUFBUSxLQUFLLE1BQU0sS0FBSyxPQUFPOzBDQUN0QixtQkFBbUI7Ozs7Ozs4QkFNL0IsUUFBUSxDQUFDLE9BQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0NBbUJaLG1CQUFtQjs7OztnQ0FJckIsb0JBQW9CO29CQUNoQyxhQUFhOzs7Z0NBR0QsUUFBUSxDQUFDLE9BQU87Ozs7a0NBSWQscUJBQXFCO29CQUNuQyxjQUFjOzs7a0NBR0EsUUFBUSxDQUFDLFFBQVE7Ozs7b0NBSWYsc0JBQXNCO3lDQUNqQixhQUFhOzs7OytDQUlQLGFBQWE7bURBQ1QsYUFBYTttREFDYixhQUFhOzs7Z0JBR2hELGFBQWE7OztrQ0FHSyxzQkFBc0I7a0JBQ3RDLHdCQUF3QixLQUFLLENBQUM7Ozs7Ozs7O2dCQVFoQyxhQUFhO3lCQUNKLHdCQUF3QixLQUFLLENBQUM7OzsrQ0FHUixhQUFhOzs7OztnQkFLNUMsYUFBYTt5QkFDSix3QkFBd0IsS0FBSyxDQUFDOzs7K0NBR1IsYUFBYTttREFDVCxhQUFhOzs7O2dCQUloRCxhQUFhOzs7O29CQUlULFdBQVc7O0tBRTFCLENBQUM7SUFDSixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7YmFja2VuZF91dGlsfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuaW1wb3J0IHtHUEdQVVByb2dyYW19IGZyb20gJy4vZ3BncHVfbWF0aCc7XG5cbmV4cG9ydCBjbGFzcyBQb29sMkRQcm9ncmFtIGltcGxlbWVudHMgR1BHUFVQcm9ncmFtIHtcbiAgdmFyaWFibGVOYW1lcyA9IFsneCddO1xuICBvdXRwdXRTaGFwZTogbnVtYmVyW107XG4gIHVzZXJDb2RlOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBjb252SW5mbzogYmFja2VuZF91dGlsLkNvbnYyREluZm8sIHBvb2xUeXBlOiAnbWF4J3wnYXZnJyxcbiAgICAgIGNvbXB1dGVQb3NpdGlvbnM6IGJvb2xlYW4sIGZsYXR0ZW5Qb3NpdGlvbnMgPSBmYWxzZSxcbiAgICAgIGluY2x1ZGVCYXRjaEluSW5kZXggPSBmYWxzZSkge1xuICAgIGlmIChwb29sVHlwZSA9PT0gJ2F2ZycgJiYgY29tcHV0ZVBvc2l0aW9ucykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tcHV0ZSBwb3NpdGlvbnMgZm9yIGF2ZXJhZ2UgcG9vbC4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgIGNvbnN0IHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICBjb25zdCBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgIGNvbnN0IGRpbGF0aW9uSGVpZ2h0ID0gY29udkluZm8uZGlsYXRpb25IZWlnaHQ7XG4gICAgY29uc3QgZGlsYXRpb25XaWR0aCA9IGNvbnZJbmZvLmRpbGF0aW9uV2lkdGg7XG4gICAgY29uc3QgZWZmZWN0aXZlRmlsdGVySGVpZ2h0ID0gY29udkluZm8uZWZmZWN0aXZlRmlsdGVySGVpZ2h0O1xuICAgIGNvbnN0IGVmZmVjdGl2ZUZpbHRlcldpZHRoID0gY29udkluZm8uZWZmZWN0aXZlRmlsdGVyV2lkdGg7XG5cbiAgICBjb25zdCBwYWRUb3AgPSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICBjb25zdCBwYWRMZWZ0ID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5vdXRTaGFwZTtcblxuICAgIGNvbnN0IGlzQXZnUG9vbCA9IHBvb2xUeXBlID09PSAnYXZnJztcbiAgICBjb25zdCBiYXRjaEZsYXR0ZW5Qb3NpdGlvblN0ciA9IGAoKGJhdGNoICAqICR7Y29udkluZm8uaW5IZWlnaHR9ICsgeFIpICogJHtcbiAgICAgICAgY29udkluZm8uaW5XaWR0aH0gKyB4QykgKiAke2NvbnZJbmZvLmluQ2hhbm5lbHN9ICsgZGA7XG4gICAgY29uc3QgZmxhdHRlblBvc2l0aW9uU3RyID1cbiAgICAgICAgYCh4UiAqICR7Y29udkluZm8uaW5XaWR0aH0gKyB4QykgKiAke2NvbnZJbmZvLmluQ2hhbm5lbHN9ICsgZGA7XG5cbiAgICBsZXQgaW5pdGlhbGl6YXRpb25WYWx1ZSA9ICcwLjAnO1xuICAgIGlmICghaXNBdmdQb29sKSB7XG4gICAgICAvLyBXZWJHTCBvbiBGaXJlZm94IExpbnV4IGNhbid0IGNvbXBpbGUgMS8wIHNvIHdlIGRvIDEvZXBzLlxuICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSA9ICctMS4wIC8gMWUtMjAnO1xuICAgIH1cblxuICAgIGlmIChjb21wdXRlUG9zaXRpb25zKSB7XG4gICAgICBjb25zdCBjb21wYXJlT3AgPSAnPj0nO1xuXG4gICAgICB0aGlzLnVzZXJDb2RlID0gYFxuICAgICAgICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoJHtzdHJpZGVIZWlnaHR9LCAke3N0cmlkZVdpZHRofSk7XG4gICAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke3BhZFRvcH0sICR7cGFkTGVmdH0pO1xuXG4gICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XG4gICAgICAgICAgaW50IGQgPSBjb29yZHNbM107XG5cbiAgICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMueXogKiBzdHJpZGVzIC0gcGFkcztcbiAgICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcbiAgICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcblxuICAgICAgICAgIC8vIG1heC9taW4geCg/LCA/LCBkKSB0byBnZXQgeSh5UiwgeUMsIGQpLlxuICAgICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkXG4gICAgICAgICAgZmxvYXQgbWluTWF4VmFsdWUgPSAwLjA7XG4gICAgICAgICAgZmxvYXQgbWluTWF4VmFsdWVGb3VuZCA9IDAuMDtcbiAgICAgICAgICBpbnQgbWluTWF4UG9zaXRpb24gPSAwO1xuICAgICAgICAgIGZsb2F0IGF2Z1ZhbHVlID0gMC4wO1xuXG4gICAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8ICR7ZWZmZWN0aXZlRmlsdGVySGVpZ2h0fTtcbiAgICAgICAgICAgICAgd1IgKz0gJHtkaWxhdGlvbkhlaWdodH0pIHtcbiAgICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1I7XG5cbiAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gJHtjb252SW5mby5pbkhlaWdodH0pIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCAke2VmZmVjdGl2ZUZpbHRlcldpZHRofTtcbiAgICAgICAgICAgICAgICB3QyArPSAke2RpbGF0aW9uV2lkdGh9KSB7XG4gICAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0M7XG5cbiAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSAke2NvbnZJbmZvLmluV2lkdGh9KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldFgoYmF0Y2gsIHhSLCB4QywgZCk7XG5cbiAgICAgICAgICAgICAgLy8gSWYgYSBtaW4gLyBtYXggdmFsdWUgaGFzIGFscmVhZHkgYmVlbiBmb3VuZCwgdXNlIGl0LiBJZiBub3QsXG4gICAgICAgICAgICAgIC8vIHVzZSB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAgICAgICAgICAgZmxvYXQgY3Vyck1pbk1heFZhbHVlID0gbWl4KFxuICAgICAgICAgICAgICAgICAgdmFsdWUsIG1pbk1heFZhbHVlLCBtaW5NYXhWYWx1ZUZvdW5kKTtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlICR7Y29tcGFyZU9wfSBjdXJyTWluTWF4VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBtaW5NYXhWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIG1pbk1heFZhbHVlRm91bmQgPSAxLjA7XG4gICAgICAgICAgICAgICAgbWluTWF4UG9zaXRpb24gPSAke1xuICAgICAgICAgIGZsYXR0ZW5Qb3NpdGlvbnMgPyAoaW5jbHVkZUJhdGNoSW5JbmRleCA/IGJhdGNoRmxhdHRlblBvc2l0aW9uU3RyIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGF0dGVuUG9zaXRpb25TdHIpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYHdSICogJHtlZmZlY3RpdmVGaWx0ZXJXaWR0aH0gKyB3Q2B9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldE91dHB1dChmbG9hdChtaW5NYXhQb3NpdGlvbikpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbXBhcmVPcCA9ICdtYXgnO1xuXG4gICAgbGV0IHJldHVyblZhbHVlID0gYCR7cG9vbFR5cGV9KCR7cG9vbFR5cGV9KCR7cG9vbFR5cGV9KGAgK1xuICAgICAgICAnbWluTWF4VmFsdWVbMF0sIG1pbk1heFZhbHVlWzFdKSwgbWluTWF4VmFsdWVbMl0pLCBtaW5NYXhWYWx1ZVszXSknO1xuICAgIGlmIChwb29sVHlwZSA9PT0gJ2F2ZycpIHtcbiAgICAgIHJldHVyblZhbHVlID0gYGF2Z1ZhbHVlIC8gbWF4KGNvdW50LCAxLjApYDtcbiAgICB9XG5cbiAgICBjb25zdCBmaWx0ZXJXaWR0aE5lYXJlc3RWZWM0ID0gTWF0aC5mbG9vcihmaWx0ZXJXaWR0aCAvIDQpICogNDtcbiAgICBjb25zdCBmaWx0ZXJXaWR0aFZlYzRSZW1haW5kZXIgPSBmaWx0ZXJXaWR0aCAlIDQ7XG5cbiAgICBjb25zdCB1cGRhdGVTbmlwcGV0ID0gYFxuICAgICAgaWYgKCR7aXNBdmdQb29sfSkge1xuICAgICAgICBhdmdWYWx1ZSArPSBkb3QodmFsdWVzLCBvbmVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pbk1heFZhbHVlID0gJHtjb21wYXJlT3B9KHZhbHVlcywgbWluTWF4VmFsdWUpO1xuICAgICAgfVxuICAgIGA7XG5cbiAgICB0aGlzLnVzZXJDb2RlID0gYFxuICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKCR7c3RyaWRlSGVpZ2h0fSwgJHtzdHJpZGVXaWR0aH0pO1xuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKCR7cGFkVG9wfSwgJHtwYWRMZWZ0fSk7XG4gICAgICBjb25zdCBmbG9hdCBpbml0aWFsaXphdGlvblZhbHVlID0gJHtpbml0aWFsaXphdGlvblZhbHVlfTtcbiAgICAgIGNvbnN0IHZlYzQgb25lcyA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgMS4wKTtcblxuICAgICAgZmxvYXQgY291bnQgPSAwLjA7XG5cbiAgICAgIGZsb2F0IGdldFZhbHVlKGludCBiYXRjaCwgaW50IHhSLCBpbnQgeEMsIGludCBkKSB7XG4gICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gJHtjb252SW5mby5pbldpZHRofSkge1xuICAgICAgICAgIHJldHVybiBpbml0aWFsaXphdGlvblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50ICs9IDEuMDtcbiAgICAgICAgcmV0dXJuIGdldFgoYmF0Y2gsIHhSLCB4QywgZCk7XG4gICAgICB9XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XG5cbiAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XG4gICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xuICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcblxuICAgICAgICAvLyBtYXgvbWluIHgoPywgPywgZCkgdG8gZ2V0IHkoeVIsIHlDLCBkKS5cbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWRcbiAgICAgICAgdmVjNCBtaW5NYXhWYWx1ZSA9IHZlYzQoJHtpbml0aWFsaXphdGlvblZhbHVlfSk7XG4gICAgICAgIGZsb2F0IGF2Z1ZhbHVlID0gMC4wO1xuICAgICAgICBjb3VudCA9IDAuMDtcblxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgJHtlZmZlY3RpdmVGaWx0ZXJIZWlnaHR9O1xuICAgICAgICAgICAgd1IgKz0gJHtkaWxhdGlvbkhlaWdodH0pIHtcbiAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSO1xuXG4gICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSAke2NvbnZJbmZvLmluSGVpZ2h0fSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8ICR7ZmlsdGVyV2lkdGhOZWFyZXN0VmVjNH07IHdDICs9IDQpIHtcbiAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0MgKiAke2RpbGF0aW9uV2lkdGh9O1xuXG4gICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMsIGQpLFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgJHtkaWxhdGlvbldpZHRofSwgZCksXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyAyICogJHtkaWxhdGlvbldpZHRofSwgZCksXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyAzICogJHtkaWxhdGlvbldpZHRofSwgZClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICR7dXBkYXRlU25pcHBldH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArICR7ZmlsdGVyV2lkdGhOZWFyZXN0VmVjNH07XG4gICAgICAgICAgaWYgKCR7ZmlsdGVyV2lkdGhWZWM0UmVtYWluZGVyID09PSAxfSkge1xuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDLCBkKSxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgJHt1cGRhdGVTbmlwcGV0fVxuICAgICAgICAgIH0gZWxzZSBpZiAoJHtmaWx0ZXJXaWR0aFZlYzRSZW1haW5kZXIgPT09IDJ9KSB7XG4gICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMsIGQpLFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgJHtkaWxhdGlvbldpZHRofSwgZCksXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICR7dXBkYXRlU25pcHBldH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCR7ZmlsdGVyV2lkdGhWZWM0UmVtYWluZGVyID09PSAzfSkge1xuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDLCBkKSxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QyArICR7ZGlsYXRpb25XaWR0aH0sIGQpLFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgMiAqICR7ZGlsYXRpb25XaWR0aH0sIGQpLFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAke3VwZGF0ZVNuaXBwZXR9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldE91dHB1dCgke3JldHVyblZhbHVlfSk7XG4gICAgICB9XG4gICAgYDtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUG9vbDNEUHJvZ3JhbSBpbXBsZW1lbnRzIEdQR1BVUHJvZ3JhbSB7XG4gIHZhcmlhYmxlTmFtZXMgPSBbJ3gnXTtcbiAgb3V0cHV0U2hhcGU6IG51bWJlcltdO1xuICB1c2VyQ29kZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgY29udkluZm86IGJhY2tlbmRfdXRpbC5Db252M0RJbmZvLCBwb29sVHlwZTogJ21heCd8J2F2ZycsXG4gICAgICBjb21wdXRlUG9zaXRpb25zOiBib29sZWFuLCBmbGF0dGVuUG9zaXRpb25zID0gZmFsc2UsXG4gICAgICBpbmNsdWRlQmF0Y2hJbkluZGV4ID0gZmFsc2UpIHtcbiAgICBpZiAocG9vbFR5cGUgPT09ICdhdmcnICYmIGNvbXB1dGVQb3NpdGlvbnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbXB1dGUgcG9zaXRpb25zIGZvciBhdmVyYWdlIHBvb2wuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICBjb25zdCBzdHJpZGVEZXB0aCA9IGNvbnZJbmZvLnN0cmlkZURlcHRoO1xuICAgIGNvbnN0IHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICBjb25zdCBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgIGNvbnN0IGRpbGF0aW9uRGVwdGggPSBjb252SW5mby5kaWxhdGlvbkRlcHRoO1xuICAgIGNvbnN0IGRpbGF0aW9uSGVpZ2h0ID0gY29udkluZm8uZGlsYXRpb25IZWlnaHQ7XG4gICAgY29uc3QgZGlsYXRpb25XaWR0aCA9IGNvbnZJbmZvLmRpbGF0aW9uV2lkdGg7XG4gICAgY29uc3QgZWZmZWN0aXZlRmlsdGVyRGVwdGggPSBjb252SW5mby5lZmZlY3RpdmVGaWx0ZXJEZXB0aDtcbiAgICBjb25zdCBlZmZlY3RpdmVGaWx0ZXJIZWlnaHQgPSBjb252SW5mby5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQ7XG4gICAgY29uc3QgZWZmZWN0aXZlRmlsdGVyV2lkdGggPSBjb252SW5mby5lZmZlY3RpdmVGaWx0ZXJXaWR0aDtcblxuICAgIGNvbnN0IHBhZEZyb250ID0gY29udkluZm8ucGFkSW5mby5mcm9udDtcbiAgICBjb25zdCBwYWRUb3AgPSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICBjb25zdCBwYWRMZWZ0ID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5vdXRTaGFwZTtcblxuICAgIGNvbnN0IGlzQXZnUG9vbCA9IHBvb2xUeXBlID09PSAnYXZnJztcblxuICAgIGxldCBpbml0aWFsaXphdGlvblZhbHVlID0gJzAuMCc7XG4gICAgaWYgKCFpc0F2Z1Bvb2wpIHtcbiAgICAgIC8vIFdlYkdMIG9uIEZpcmVmb3ggTGludXggY2FuJ3QgY29tcGlsZSAxLzAgc28gd2UgZG8gMS9lcHMuXG4gICAgICBpbml0aWFsaXphdGlvblZhbHVlID0gJy0xLjAgLyAxZS0yMCc7XG4gICAgfVxuXG4gICAgaWYgKGNvbXB1dGVQb3NpdGlvbnMpIHtcbiAgICAgIGNvbnN0IGNvbXBhcmVPcCA9ICc+PSc7XG5cbiAgICAgIHRoaXMudXNlckNvZGUgPSBgXG4gICAgICAgIGNvbnN0IGl2ZWMzIHN0cmlkZXMgPVxuICAgICAgICAgICAgaXZlYzMoJHtzdHJpZGVEZXB0aH0sICR7c3RyaWRlSGVpZ2h0fSwgJHtzdHJpZGVXaWR0aH0pO1xuICAgICAgICBjb25zdCBpdmVjMyBwYWRzID0gaXZlYzMoJHtwYWRGcm9udH0sICR7cGFkVG9wfSwgJHtwYWRMZWZ0fSk7XG5cbiAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgIGl2ZWM1IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xuICAgICAgICAgIGludCBjaCA9IGNvb3Jkcy51O1xuXG4gICAgICAgICAgaXZlYzMgeENvcm5lciA9IGl2ZWMzKGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLncpICogc3RyaWRlcyAtIHBhZHM7XG4gICAgICAgICAgaW50IHhEQ29ybmVyID0geENvcm5lci54O1xuICAgICAgICAgIGludCB4UkNvcm5lciA9IHhDb3JuZXIueTtcbiAgICAgICAgICBpbnQgeENDb3JuZXIgPSB4Q29ybmVyLno7XG5cbiAgICAgICAgICAvLyBtYXgvbWluIHgoPywgPywgPywgY2gpIHRvIGdldCB5KHlELCB5UiwgeUMsIGNoKS5cbiAgICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZFxuICAgICAgICAgIGZsb2F0IG1pbk1heFZhbHVlID0gMC4wO1xuICAgICAgICAgIGZsb2F0IG1pbk1heFZhbHVlRm91bmQgPSAwLjA7XG4gICAgICAgICAgaW50IG1pbk1heFBvc2l0aW9uID0gMDtcblxuICAgICAgICAgIGZvciAoaW50IHdEID0gMDsgd0QgPCAke2VmZmVjdGl2ZUZpbHRlckRlcHRofTtcbiAgICAgICAgICAgICAgd0QgKz0gJHtkaWxhdGlvbkRlcHRofSkge1xuICAgICAgICAgICAgaW50IHhEID0geERDb3JuZXIgKyB3RDtcblxuICAgICAgICAgICAgaWYgKHhEIDwgMCB8fCB4RCA+PSAke2NvbnZJbmZvLmluRGVwdGh9KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgJHtlZmZlY3RpdmVGaWx0ZXJIZWlnaHR9O1xuICAgICAgICAgICAgICAgIHdSICs9ICR7ZGlsYXRpb25IZWlnaHR9KSB7XG4gICAgICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1I7XG5cbiAgICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSAke2NvbnZJbmZvLmluSGVpZ2h0fSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8ICR7ZWZmZWN0aXZlRmlsdGVyV2lkdGh9O1xuICAgICAgICAgICAgICAgICAgd0MgKz0gJHtkaWxhdGlvbldpZHRofSkge1xuICAgICAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0M7XG5cbiAgICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49ICR7Y29udkluZm8uaW5XaWR0aH0pIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0WChiYXRjaCwgeEQsIHhSLCB4QywgY2gpO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgYSBtaW4gLyBtYXggdmFsdWUgaGFzIGFscmVhZHkgYmVlbiBmb3VuZCwgdXNlIGl0LiBJZiBub3QsXG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBjdXJyZW50IHZhbHVlLlxuICAgICAgICAgICAgICAgIGZsb2F0IGN1cnJNaW5NYXhWYWx1ZSA9IG1peChcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsIG1pbk1heFZhbHVlLCBtaW5NYXhWYWx1ZUZvdW5kKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgJHtjb21wYXJlT3B9IGN1cnJNaW5NYXhWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgbWluTWF4VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgIG1pbk1heFZhbHVlRm91bmQgPSAxLjA7XG4gICAgICAgICAgICAgICAgICBtaW5NYXhQb3NpdGlvbiA9ICR7XG4gICAgICAgICAgZmxhdHRlblBvc2l0aW9ucyA/XG4gICAgICAgICAgICAgIChpbmNsdWRlQmF0Y2hJbkluZGV4ID9cbiAgICAgICAgICAgICAgICAgICBgKCgoYmF0Y2ggKiAke2NvbnZJbmZvLmluRGVwdGh9ICsgeEQpICogJHtcbiAgICAgICAgICAgICAgICAgICAgICAgY29udkluZm8uaW5IZWlnaHR9ICsgeFIpICogJHtjb252SW5mby5pbldpZHRofSArIHhDKSAqICR7XG4gICAgICAgICAgICAgICAgICAgICAgIGNvbnZJbmZvLmluQ2hhbm5lbHN9ICsgY2hgIDpcbiAgICAgICAgICAgICAgICAgICBgKCh4RCAqICR7Y29udkluZm8uaW5IZWlnaHR9ICsgeFIpICogJHtcbiAgICAgICAgICAgICAgICAgICAgICAgY29udkluZm8uaW5XaWR0aH0gKyB4QykgKiAke2NvbnZJbmZvLmluQ2hhbm5lbHN9ICsgY2hgKSA6XG4gICAgICAgICAgICAgIGB3RCAqICR7ZWZmZWN0aXZlRmlsdGVySGVpZ2h0fSAqICR7ZWZmZWN0aXZlRmlsdGVyV2lkdGh9ICtcbiAgICAgICAgICAgICAgICAgICAgICB3UiAqICR7ZWZmZWN0aXZlRmlsdGVyV2lkdGh9ICsgd0NgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KG1pbk1heFBvc2l0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY29tcGFyZU9wID0gJ21heCc7XG5cbiAgICBsZXQgcmV0dXJuVmFsdWUgPSBgJHtwb29sVHlwZX0oJHtwb29sVHlwZX0oJHtwb29sVHlwZX0oYCArXG4gICAgICAgICdtaW5NYXhWYWx1ZVswXSwgbWluTWF4VmFsdWVbMV0pLCBtaW5NYXhWYWx1ZVsyXSksIG1pbk1heFZhbHVlWzNdKSc7XG4gICAgaWYgKHBvb2xUeXBlID09PSAnYXZnJykge1xuICAgICAgLy8gVXNlIGBtYXgoY291bnQsIDEuMClgIGluc3RlYWQgb2YgYGNvdW50YCBpbiBjYXNlIGNvdW50ID09PSAwLjAuXG4gICAgICAvLyBJZiBjb3VudCA9PT0gMC4wLCBgYXZnVmFsdWVgIGlzIGFsd2F5cyAwLjAgYW5kIHdlIGNoYW5nZSBgY291bnRgJ3NcbiAgICAgIC8vIHZhbHVlIHRvIGF2b2lkIGRpdmlkaW5nIHplcm8uXG4gICAgICByZXR1cm5WYWx1ZSA9IGBhdmdWYWx1ZSAvIG1heChjb3VudCwgMS4wKWA7XG4gICAgfVxuXG4gICAgY29uc3QgZmlsdGVyV2lkdGhOZWFyZXN0VmVjNCA9IE1hdGguZmxvb3IoZmlsdGVyV2lkdGggLyA0KSAqIDQ7XG4gICAgY29uc3QgZmlsdGVyV2lkdGhWZWM0UmVtYWluZGVyID0gZmlsdGVyV2lkdGggJSA0O1xuXG4gICAgY29uc3QgdXBkYXRlU25pcHBldCA9IGBcbiAgICAgIGlmICgke2lzQXZnUG9vbH0pIHtcbiAgICAgICAgYXZnVmFsdWUgKz0gZG90KHZhbHVlcywgb25lcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW5NYXhWYWx1ZSA9ICR7Y29tcGFyZU9wfSh2YWx1ZXMsIG1pbk1heFZhbHVlKTtcbiAgICAgIH1cbiAgICBgO1xuXG4gICAgdGhpcy51c2VyQ29kZSA9IGBcbiAgICAgIGNvbnN0IGl2ZWMzIHN0cmlkZXMgPVxuICAgICAgICBpdmVjMygke3N0cmlkZURlcHRofSwgJHtzdHJpZGVIZWlnaHR9LCAke3N0cmlkZVdpZHRofSk7XG4gICAgICBjb25zdCBpdmVjMyBwYWRzID0gaXZlYzMoJHtwYWRGcm9udH0sICR7cGFkVG9wfSwgJHtwYWRMZWZ0fSk7XG4gICAgICBjb25zdCBmbG9hdCBpbml0aWFsaXphdGlvblZhbHVlID0gJHtpbml0aWFsaXphdGlvblZhbHVlfTtcbiAgICAgIGNvbnN0IHZlYzQgb25lcyA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgMS4wKTtcblxuICAgICAgZmxvYXQgY291bnQgPSAwLjA7XG5cbiAgICAgIGZsb2F0IGdldFZhbHVlKGludCBiYXRjaCwgaW50IHhELCBpbnQgeFIsIGludCB4QywgaW50IGNoKSB7XG4gICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gJHtjb252SW5mby5pbldpZHRofSkge1xuICAgICAgICAgIHJldHVybiBpbml0aWFsaXphdGlvblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50ICs9IDEuMDtcbiAgICAgICAgcmV0dXJuIGdldFgoYmF0Y2gsIHhELCB4UiwgeEMsIGNoKTtcbiAgICAgIH1cblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjNSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XG4gICAgICAgIGludCBjaCA9IGNvb3Jkcy51O1xuXG4gICAgICAgIGl2ZWMzIHhDb3JuZXIgPSBpdmVjMyhjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy53KSAqIHN0cmlkZXMgLSBwYWRzO1xuICAgICAgICBpbnQgeERDb3JuZXIgPSB4Q29ybmVyLng7XG4gICAgICAgIGludCB4UkNvcm5lciA9IHhDb3JuZXIueTtcbiAgICAgICAgaW50IHhDQ29ybmVyID0geENvcm5lci56O1xuXG4gICAgICAgIC8vIG1heC9taW4geCg/LCA/LCA/LCBkKSB0byBnZXQgeSh5RCwgeVIsIHlDLCBjaCkuXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkXG4gICAgICAgIHZlYzQgbWluTWF4VmFsdWUgPSB2ZWM0KCR7aW5pdGlhbGl6YXRpb25WYWx1ZX0pO1xuICAgICAgICBmbG9hdCBhdmdWYWx1ZSA9IDAuMDtcbiAgICAgICAgY291bnQgPSAwLjA7XG5cbiAgICAgICAgZm9yIChpbnQgd0QgPSAwOyB3RCA8ICR7ZWZmZWN0aXZlRmlsdGVyRGVwdGh9O1xuICAgICAgICAgICAgd0QgKz0gJHtkaWxhdGlvbkRlcHRofSkge1xuICAgICAgICAgIGludCB4RCA9IHhEQ29ybmVyICsgd0Q7XG5cbiAgICAgICAgICBpZiAoeEQgPCAwIHx8IHhEID49ICR7Y29udkluZm8uaW5EZXB0aH0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCAke2VmZmVjdGl2ZUZpbHRlckhlaWdodH07XG4gICAgICAgICAgICB3UiArPSAke2RpbGF0aW9uSGVpZ2h0fSkge1xuICAgICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UjtcblxuICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSAke2NvbnZJbmZvLmluSGVpZ2h0fSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8ICR7ZmlsdGVyV2lkdGhOZWFyZXN0VmVjNH07IHdDICs9IDQpIHtcbiAgICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QyAqICR7ZGlsYXRpb25XaWR0aH07XG5cbiAgICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxuICAgICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4RCwgeFIsIHhDLCBjaCksXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhELCB4UiwgeEMgKyAke2RpbGF0aW9uV2lkdGh9LCBjaCksXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhELCB4UiwgeEMgKyAyICogJHtkaWxhdGlvbldpZHRofSwgY2gpLFxuICAgICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4RCwgeFIsIHhDICsgMyAqICR7ZGlsYXRpb25XaWR0aH0sIGNoKVxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICR7dXBkYXRlU25pcHBldH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyAke2ZpbHRlcldpZHRoTmVhcmVzdFZlYzR9O1xuICAgICAgICAgICAgaWYgKCR7ZmlsdGVyV2lkdGhWZWM0UmVtYWluZGVyID09PSAxfSkge1xuICAgICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhELCB4UiwgeEMsIGNoKSxcbiAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICR7dXBkYXRlU25pcHBldH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJHtmaWx0ZXJXaWR0aFZlYzRSZW1haW5kZXIgPT09IDJ9KSB7XG4gICAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeEQsIHhSLCB4QywgY2gpLFxuICAgICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4RCwgeFIsIHhDICsgJHtkaWxhdGlvbldpZHRofSwgY2gpLFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICR7dXBkYXRlU25pcHBldH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJHtmaWx0ZXJXaWR0aFZlYzRSZW1haW5kZXIgPT09IDN9KSB7XG4gICAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeEQsIHhSLCB4QywgY2gpLFxuICAgICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4RCwgeFIsIHhDICsgJHtkaWxhdGlvbldpZHRofSwgY2gpLFxuICAgICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4RCwgeFIsIHhDICsgMiAqICR7ZGlsYXRpb25XaWR0aH0sIGNoKSxcbiAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgJHt1cGRhdGVTbmlwcGV0fVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRPdXRwdXQoJHtyZXR1cm5WYWx1ZX0pO1xuICAgICAgfVxuICAgIGA7XG4gIH1cbn1cbiJdfQ==","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ReduceProgram {\n    constructor(reduceInfo, reduceType) {\n        this.variableNames = ['x'];\n        const { windowSize, batchSize, inSize, outSize } = reduceInfo;\n        this.outputShape = [batchSize, outSize];\n        let initializationValue = '0.0';\n        let compareOp = ``;\n        if (reduceType === 'prod') {\n            initializationValue = '1.0';\n        }\n        else if (reduceType === 'min') {\n            // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n            initializationValue = '1.0 / 1e-20';\n            compareOp = `min`;\n        }\n        else if (reduceType === 'max') {\n            // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n            initializationValue = '-1.0 / 1e-20';\n            compareOp = `max`;\n        }\n        let returnValue = `${reduceType}(${reduceType}(${reduceType}(` +\n            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n        if (reduceType === 'sum') {\n            returnValue = `sumValue`;\n        }\n        else if (reduceType === 'prod') {\n            returnValue = `prodValue`;\n        }\n        else if (reduceType === 'all') {\n            returnValue = `allValue`;\n        }\n        else if (reduceType === 'any') {\n            returnValue = `anyValue`;\n        }\n        const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n        const windowSizeVec4Remainder = windowSize % 4;\n        let updateSnippet = `\n      if (${reduceType === 'sum'}) {\n        sumValue += dot(values, ones);\n      } else if (${reduceType === 'prod'}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n        if (${reduceType === 'min'} || ${reduceType === 'max'}) {\n          minMaxValue = ${compareOp}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `;\n        let vecType = `vec4`;\n        if (reduceType === 'all') {\n            initializationValue = '1.0';\n            updateSnippet = `\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      `;\n            vecType = `bvec4`;\n        }\n        else if (reduceType === 'any') {\n            initializationValue = '0.0';\n            updateSnippet = `\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      `;\n            vecType = `bvec4`;\n        }\n        let checkOutOfBounds = '';\n        if (inSize % windowSize > 0) {\n            checkOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return initializationValue;\n        }\n      `;\n        }\n        this.userCode = `\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${checkOutOfBounds}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${windowSize};\n\n        vec4 minMaxValue = vec4(${initializationValue});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {\n          int inIdx = inOffset + i;\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${updateSnippet}\n        }\n\n        int inIdx = inOffset + ${windowSizeNearestVec4};\n        if (${windowSizeVec4Remainder === 1}) {\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 2}) {\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 3}) {\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${updateSnippet}\n        }\n        setOutput(${returnValue});\n      }\n    `;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVkdWNlX2dwdS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RmanMtYmFja2VuZC13ZWJnbC9zcmMvcmVkdWNlX2dwdS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFLSCxNQUFNLE9BQU8sYUFBYTtJQUt4QixZQUNJLFVBQW1DLEVBQ25DLFVBQWdEO1FBTnBELGtCQUFhLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQU9wQixNQUFNLEVBQUMsVUFBVSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFDLEdBQUcsVUFBVSxDQUFDO1FBQzVELElBQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFFeEMsSUFBSSxtQkFBbUIsR0FBRyxLQUFLLENBQUM7UUFDaEMsSUFBSSxTQUFTLEdBQUcsRUFBRSxDQUFDO1FBRW5CLElBQUksVUFBVSxLQUFLLE1BQU0sRUFBRTtZQUN6QixtQkFBbUIsR0FBRyxLQUFLLENBQUM7U0FDN0I7YUFBTSxJQUFJLFVBQVUsS0FBSyxLQUFLLEVBQUU7WUFDL0IsMkRBQTJEO1lBQzNELG1CQUFtQixHQUFHLGFBQWEsQ0FBQztZQUNwQyxTQUFTLEdBQUcsS0FBSyxDQUFDO1NBQ25CO2FBQU0sSUFBSSxVQUFVLEtBQUssS0FBSyxFQUFFO1lBQy9CLDJEQUEyRDtZQUMzRCxtQkFBbUIsR0FBRyxjQUFjLENBQUM7WUFDckMsU0FBUyxHQUFHLEtBQUssQ0FBQztTQUNuQjtRQUVELElBQUksV0FBVyxHQUFHLEdBQUcsVUFBVSxJQUFJLFVBQVUsSUFBSSxVQUFVLEdBQUc7WUFDMUQsbUVBQW1FLENBQUM7UUFFeEUsSUFBSSxVQUFVLEtBQUssS0FBSyxFQUFFO1lBQ3hCLFdBQVcsR0FBRyxVQUFVLENBQUM7U0FDMUI7YUFBTSxJQUFJLFVBQVUsS0FBSyxNQUFNLEVBQUU7WUFDaEMsV0FBVyxHQUFHLFdBQVcsQ0FBQztTQUMzQjthQUFNLElBQUksVUFBVSxLQUFLLEtBQUssRUFBRTtZQUMvQixXQUFXLEdBQUcsVUFBVSxDQUFDO1NBQzFCO2FBQU0sSUFBSSxVQUFVLEtBQUssS0FBSyxFQUFFO1lBQy9CLFdBQVcsR0FBRyxVQUFVLENBQUM7U0FDMUI7UUFFRCxNQUFNLHFCQUFxQixHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUM3RCxNQUFNLHVCQUF1QixHQUFHLFVBQVUsR0FBRyxDQUFDLENBQUM7UUFFL0MsSUFBSSxhQUFhLEdBQUc7WUFDWixVQUFVLEtBQUssS0FBSzs7bUJBRWIsVUFBVSxLQUFLLE1BQU07Ozs7d0JBSWhCLFNBQVM7Y0FDbkIsVUFBVSxLQUFLLEtBQUssT0FBTyxVQUFVLEtBQUssS0FBSzswQkFDbkMsU0FBUzs7Ozs7OztLQU85QixDQUFDO1FBRUYsSUFBSSxPQUFPLEdBQUcsTUFBTSxDQUFDO1FBRXJCLElBQUksVUFBVSxLQUFLLEtBQUssRUFBRTtZQUN4QixtQkFBbUIsR0FBRyxLQUFLLENBQUM7WUFDNUIsYUFBYSxHQUFHOzs7O09BSWYsQ0FBQztZQUNGLE9BQU8sR0FBRyxPQUFPLENBQUM7U0FDbkI7YUFBTSxJQUFJLFVBQVUsS0FBSyxLQUFLLEVBQUU7WUFDL0IsbUJBQW1CLEdBQUcsS0FBSyxDQUFDO1lBQzVCLGFBQWEsR0FBRzs7OztPQUlmLENBQUM7WUFDRixPQUFPLEdBQUcsT0FBTyxDQUFDO1NBQ25CO1FBRUQsSUFBSSxnQkFBZ0IsR0FBRyxFQUFFLENBQUM7UUFDMUIsSUFBSSxNQUFNLEdBQUcsVUFBVSxHQUFHLENBQUMsRUFBRTtZQUMzQixnQkFBZ0IsR0FBRztvQ0FDVyxNQUFNOzs7T0FHbkMsQ0FBQztTQUNIO1FBQ0QsSUFBSSxDQUFDLFFBQVEsR0FBRzswQ0FDc0IsbUJBQW1COzs7O1VBSW5ELGdCQUFnQjs7Ozs7Ozs7a0NBUVEsVUFBVTs7a0NBRVYsbUJBQW1COzs7Ozs7OEJBTXZCLHFCQUFxQjs7WUFFdkMsT0FBTyxhQUFhLE9BQU87Ozs7Ozs7WUFPM0IsYUFBYTs7O2lDQUdRLHFCQUFxQjtjQUN4Qyx1QkFBdUIsS0FBSyxDQUFDO1lBQy9CLE9BQU8sYUFBYSxPQUFPOzs7Ozs7O1lBTzNCLGFBQWE7cUJBQ0osdUJBQXVCLEtBQUssQ0FBQztZQUN0QyxPQUFPLGFBQWEsT0FBTzs7Ozs7OztZQU8zQixhQUFhO3FCQUNKLHVCQUF1QixLQUFLLENBQUM7WUFDdEMsT0FBTyxhQUFhLE9BQU87Ozs7Ozs7WUFPM0IsYUFBYTs7b0JBRUwsV0FBVzs7S0FFMUIsQ0FBQztJQUNKLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtiYWNrZW5kX3V0aWx9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5pbXBvcnQge0dQR1BVUHJvZ3JhbX0gZnJvbSAnLi9ncGdwdV9tYXRoJztcblxuZXhwb3J0IGNsYXNzIFJlZHVjZVByb2dyYW0gaW1wbGVtZW50cyBHUEdQVVByb2dyYW0ge1xuICB2YXJpYWJsZU5hbWVzID0gWyd4J107XG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXTtcbiAgdXNlckNvZGU6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihcbiAgICAgIHJlZHVjZUluZm86IGJhY2tlbmRfdXRpbC5SZWR1Y2VJbmZvLFxuICAgICAgcmVkdWNlVHlwZTogJ2FsbCd8J2FueSd8J21heCd8J21pbid8J3N1bSd8J3Byb2QnKSB7XG4gICAgY29uc3Qge3dpbmRvd1NpemUsIGJhdGNoU2l6ZSwgaW5TaXplLCBvdXRTaXplfSA9IHJlZHVjZUluZm87XG4gICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtiYXRjaFNpemUsIG91dFNpemVdO1xuXG4gICAgbGV0IGluaXRpYWxpemF0aW9uVmFsdWUgPSAnMC4wJztcbiAgICBsZXQgY29tcGFyZU9wID0gYGA7XG5cbiAgICBpZiAocmVkdWNlVHlwZSA9PT0gJ3Byb2QnKSB7XG4gICAgICBpbml0aWFsaXphdGlvblZhbHVlID0gJzEuMCc7XG4gICAgfSBlbHNlIGlmIChyZWR1Y2VUeXBlID09PSAnbWluJykge1xuICAgICAgLy8gV2ViR0wgb24gRmlyZWZveCBMaW51eCBjYW4ndCBjb21waWxlIDEvMCBzbyB3ZSBkbyAxL2Vwcy5cbiAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUgPSAnMS4wIC8gMWUtMjAnO1xuICAgICAgY29tcGFyZU9wID0gYG1pbmA7XG4gICAgfSBlbHNlIGlmIChyZWR1Y2VUeXBlID09PSAnbWF4Jykge1xuICAgICAgLy8gV2ViR0wgb24gRmlyZWZveCBMaW51eCBjYW4ndCBjb21waWxlIDEvMCBzbyB3ZSBkbyAxL2Vwcy5cbiAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUgPSAnLTEuMCAvIDFlLTIwJztcbiAgICAgIGNvbXBhcmVPcCA9IGBtYXhgO1xuICAgIH1cblxuICAgIGxldCByZXR1cm5WYWx1ZSA9IGAke3JlZHVjZVR5cGV9KCR7cmVkdWNlVHlwZX0oJHtyZWR1Y2VUeXBlfShgICtcbiAgICAgICAgJ21pbk1heFZhbHVlWzBdLCBtaW5NYXhWYWx1ZVsxXSksIG1pbk1heFZhbHVlWzJdKSwgbWluTWF4VmFsdWVbM10pJztcblxuICAgIGlmIChyZWR1Y2VUeXBlID09PSAnc3VtJykge1xuICAgICAgcmV0dXJuVmFsdWUgPSBgc3VtVmFsdWVgO1xuICAgIH0gZWxzZSBpZiAocmVkdWNlVHlwZSA9PT0gJ3Byb2QnKSB7XG4gICAgICByZXR1cm5WYWx1ZSA9IGBwcm9kVmFsdWVgO1xuICAgIH0gZWxzZSBpZiAocmVkdWNlVHlwZSA9PT0gJ2FsbCcpIHtcbiAgICAgIHJldHVyblZhbHVlID0gYGFsbFZhbHVlYDtcbiAgICB9IGVsc2UgaWYgKHJlZHVjZVR5cGUgPT09ICdhbnknKSB7XG4gICAgICByZXR1cm5WYWx1ZSA9IGBhbnlWYWx1ZWA7XG4gICAgfVxuXG4gICAgY29uc3Qgd2luZG93U2l6ZU5lYXJlc3RWZWM0ID0gTWF0aC5mbG9vcih3aW5kb3dTaXplIC8gNCkgKiA0O1xuICAgIGNvbnN0IHdpbmRvd1NpemVWZWM0UmVtYWluZGVyID0gd2luZG93U2l6ZSAlIDQ7XG5cbiAgICBsZXQgdXBkYXRlU25pcHBldCA9IGBcbiAgICAgIGlmICgke3JlZHVjZVR5cGUgPT09ICdzdW0nfSkge1xuICAgICAgICBzdW1WYWx1ZSArPSBkb3QodmFsdWVzLCBvbmVzKTtcbiAgICAgIH0gZWxzZSBpZiAoJHtyZWR1Y2VUeXBlID09PSAncHJvZCd9KSB7XG4gICAgICAgIHZlYzIgdG1wID0gdmVjMih2YWx1ZXNbMF0sIHZhbHVlc1sxXSkgKiB2ZWMyKHZhbHVlc1syXSwgdmFsdWVzWzNdKTtcbiAgICAgICAgcHJvZFZhbHVlICo9IHRtcFswXSAqIHRtcFsxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pbk1heFZhbHVlID0gJHtjb21wYXJlT3B9KHZhbHVlcywgbWluTWF4VmFsdWUpO1xuICAgICAgICBpZiAoJHtyZWR1Y2VUeXBlID09PSAnbWluJ30gfHwgJHtyZWR1Y2VUeXBlID09PSAnbWF4J30pIHtcbiAgICAgICAgICBtaW5NYXhWYWx1ZSA9ICR7Y29tcGFyZU9wfSh2YWx1ZXMsIG1pbk1heFZhbHVlKTtcbiAgICAgICAgICBidmVjNCBpc05hTiA9IGlzbmFuKHZhbHVlcyk7XG4gICAgICAgICAgaWYgKGlzTmFOLnIgfHwgaXNOYU4uZyB8fCBpc05hTi5iIHx8IGlzTmFOLmEpIHtcbiAgICAgICAgICAgIG1pbk1heFZhbHVlID0gdmVjNChOQU4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIGA7XG5cbiAgICBsZXQgdmVjVHlwZSA9IGB2ZWM0YDtcblxuICAgIGlmIChyZWR1Y2VUeXBlID09PSAnYWxsJykge1xuICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSA9ICcxLjAnO1xuICAgICAgdXBkYXRlU25pcHBldCA9IGBcbiAgICAgICAgYm9vbCByZWR1Y2VkQWxsVmFsdWUgPSBhbGwodmFsdWVzKTtcbiAgICAgICAgZmxvYXQgZmxvYXRlZFJlZHVjZWRBbGxWYWx1ZSA9IGZsb2F0KHJlZHVjZWRBbGxWYWx1ZSk7XG4gICAgICAgIGFsbFZhbHVlID0gZmxvYXQoYWxsVmFsdWUgPj0gMS4wICYmIGZsb2F0ZWRSZWR1Y2VkQWxsVmFsdWUgPj0gMS4wKTtcbiAgICAgIGA7XG4gICAgICB2ZWNUeXBlID0gYGJ2ZWM0YDtcbiAgICB9IGVsc2UgaWYgKHJlZHVjZVR5cGUgPT09ICdhbnknKSB7XG4gICAgICBpbml0aWFsaXphdGlvblZhbHVlID0gJzAuMCc7XG4gICAgICB1cGRhdGVTbmlwcGV0ID0gYFxuICAgICAgICBib29sIHJlZHVjZWRBbnlWYWx1ZSA9IGFueSh2YWx1ZXMpO1xuICAgICAgICBmbG9hdCBmbG9hdGVkUmVkdWNlZEFueVZhbHVlID0gZmxvYXQocmVkdWNlZEFueVZhbHVlKTtcbiAgICAgICAgYW55VmFsdWUgPSBmbG9hdChhbnlWYWx1ZSA+PSAxLjAgfHwgZmxvYXRlZFJlZHVjZWRBbnlWYWx1ZSA+PSAxLjApO1xuICAgICAgYDtcbiAgICAgIHZlY1R5cGUgPSBgYnZlYzRgO1xuICAgIH1cblxuICAgIGxldCBjaGVja091dE9mQm91bmRzID0gJyc7XG4gICAgaWYgKGluU2l6ZSAlIHdpbmRvd1NpemUgPiAwKSB7XG4gICAgICBjaGVja091dE9mQm91bmRzID0gYFxuICAgICAgICBpZiAoaW5JZHggPCAwIHx8IGluSWR4ID49ICR7aW5TaXplfSkge1xuICAgICAgICAgIHJldHVybiBpbml0aWFsaXphdGlvblZhbHVlO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIH1cbiAgICB0aGlzLnVzZXJDb2RlID0gYFxuICAgICAgY29uc3QgZmxvYXQgaW5pdGlhbGl6YXRpb25WYWx1ZSA9ICR7aW5pdGlhbGl6YXRpb25WYWx1ZX07XG4gICAgICBjb25zdCB2ZWM0IG9uZXMgPSB2ZWM0KDEuMCwgMS4wLCAxLjAsIDEuMCk7XG5cbiAgICAgIGZsb2F0IGdldFZhbHVlKGludCBiYXRjaCwgaW50IGluSWR4KSB7XG4gICAgICAgICR7Y2hlY2tPdXRPZkJvdW5kc31cbiAgICAgICAgcmV0dXJuIGdldFgoYmF0Y2gsIGluSWR4KTtcbiAgICAgIH1cblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xuICAgICAgICBpbnQgb3V0SWR4ID0gY29vcmRzWzFdO1xuICAgICAgICBpbnQgaW5PZmZzZXQgPSBvdXRJZHggKiAke3dpbmRvd1NpemV9O1xuXG4gICAgICAgIHZlYzQgbWluTWF4VmFsdWUgPSB2ZWM0KCR7aW5pdGlhbGl6YXRpb25WYWx1ZX0pO1xuICAgICAgICBmbG9hdCBwcm9kVmFsdWUgPSAxLjA7XG4gICAgICAgIGZsb2F0IHN1bVZhbHVlID0gMC4wO1xuICAgICAgICBmbG9hdCBhbGxWYWx1ZSA9IDEuMDtcbiAgICAgICAgZmxvYXQgYW55VmFsdWUgPSAwLjA7XG5cbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke3dpbmRvd1NpemVOZWFyZXN0VmVjNH07IGkgKz0gNCkge1xuICAgICAgICAgIGludCBpbklkeCA9IGluT2Zmc2V0ICsgaTtcbiAgICAgICAgICAke3ZlY1R5cGV9IHZhbHVlcyA9ICR7dmVjVHlwZX0oXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAyKSxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDMpXG4gICAgICAgICAgKTtcblxuICAgICAgICAgICR7dXBkYXRlU25pcHBldH1cbiAgICAgICAgfVxuXG4gICAgICAgIGludCBpbklkeCA9IGluT2Zmc2V0ICsgJHt3aW5kb3dTaXplTmVhcmVzdFZlYzR9O1xuICAgICAgICBpZiAoJHt3aW5kb3dTaXplVmVjNFJlbWFpbmRlciA9PT0gMX0pIHtcbiAgICAgICAgICAke3ZlY1R5cGV9IHZhbHVlcyA9ICR7dmVjVHlwZX0oXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXG4gICAgICAgICAgKTtcblxuICAgICAgICAgICR7dXBkYXRlU25pcHBldH1cbiAgICAgICAgfSBlbHNlIGlmICgke3dpbmRvd1NpemVWZWM0UmVtYWluZGVyID09PSAyfSkge1xuICAgICAgICAgICR7dmVjVHlwZX0gdmFsdWVzID0gJHt2ZWNUeXBlfShcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXG4gICAgICAgICAgKTtcblxuICAgICAgICAgICR7dXBkYXRlU25pcHBldH1cbiAgICAgICAgfSBlbHNlIGlmICgke3dpbmRvd1NpemVWZWM0UmVtYWluZGVyID09PSAzfSkge1xuICAgICAgICAgICR7dmVjVHlwZX0gdmFsdWVzID0gJHt2ZWNUeXBlfShcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDIpLFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAke3VwZGF0ZVNuaXBwZXR9XG4gICAgICAgIH1cbiAgICAgICAgc2V0T3V0cHV0KCR7cmV0dXJuVmFsdWV9KTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG59XG4iXX0="],"names":["PackProgram","constructor","outputShape","this","variableNames","packedInputs","packedOutput","rank","length","enableShapeUniforms","userCode","channels","dtype","outOfBoundsCondition","getOutOfBoundsCondition","setup","getSetup","output","getOutput","getSourceCoordsArr","dims","coords","row","col","coord","d","push","cond","i","innerDims","slice","sourceCoords","outShape","getVecChannels","name","map","getChannels","getSourceCoords","PadProgram","xShape","paddings","constantValue","customUniforms","type","p","start","join","end","unpackedCoords","PadPackedProgram","source","cLimit","componentSetup","paddingArea","mainLoop","j","Pool2DProgram","convInfo","poolType","computePositions","flattenPositions","includeBatchInIndex","Error","filterWidth","strideHeight","strideWidth","dilationHeight","dilationWidth","effectiveFilterHeight","effectiveFilterWidth","padTop","padInfo","top","padLeft","left","isAvgPool","batchFlattenPositionStr","inHeight","inWidth","inChannels","flattenPositionStr","initializationValue","compareOp","returnValue","filterWidthNearestVec4","Math","floor","filterWidthVec4Remainder","updateSnippet","Pool3DProgram","strideDepth","dilationDepth","effectiveFilterDepth","padFront","front","inDepth","ReduceProgram","reduceInfo","reduceType","windowSize","batchSize","inSize","outSize","windowSizeNearestVec4","windowSizeVec4Remainder","vecType","checkOutOfBounds"],"sourceRoot":""}