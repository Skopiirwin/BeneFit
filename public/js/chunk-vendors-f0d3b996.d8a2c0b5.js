"use strict";(self["webpackChunkbenefit"]=self["webpackChunkbenefit"]||[]).push([[7566],{47894:function(t,e,s){var o=s(46574),n=s(45119),r=s(77084),i=s(56734),a=s(46669),h=s(66519);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const l="application/octet-stream",u="application/json";class c{constructor(t,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.weightUrlConverter=e.weightUrlConverter,null!=e.fetchFunc?((0,n.vA)("function"===typeof e.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=e.fetchFunc):this.fetch=(0,o._K)().platform.fetch,(0,n.vA)(null!=t&&t.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(t)&&(0,n.vA)(2===t.length,(()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`)),this.path=t,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{},this.loadOptions=e}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],o=(0,r.zV)(t,s);if(e.body.append("model.json",new Blob([JSON.stringify(o)],{type:u}),"model.json"),null!=t.weightData){const s=i.D.join(t.weightData);e.body.append("model.weights.bin",new Blob([s],{type:l}),"model.weights.bin")}const n=await this.fetch(this.path,e);if(n.ok)return{modelArtifactsInfo:(0,r.oR)(t),responses:[n]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${n.status}.`)}async loadModelJSON(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch(n){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const s=e.modelTopology,o=e.weightsManifest;if(null==s&&null==o)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return e}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const t=await this.loadModelJSON();return(0,r.Ej)(t,(t=>this.loadWeights(t)))}async loadStream(){const t=await this.loadModelJSON(),e=await this.getWeightUrls(t.weightsManifest),s=(0,r.Xf)(t.weightsManifest),o=()=>(0,h.SD)(e,this.loadOptions);return Object.assign(Object.assign({},t),{weightSpecs:s,getWeightStream:o})}async getWeightUrls(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[s,o]=f(e),n=this.weightPathPrefix||s,r=[],i=[];for(const a of t)for(const t of a.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(t)):r.push(n+t+o);return this.weightUrlConverter&&r.push(...await Promise.all(i)),r}async loadWeights(t){const e=await this.getWeightUrls(t),s=(0,r.Xf)(t),o=await(0,h.jP)(e,this.loadOptions);return[s,o]}}function f(t){const e=t.lastIndexOf("/"),s=t.lastIndexOf("?"),o=t.substring(0,e),n=s>e?t.substring(s):"";return[o+"/",n]}function p(t){return null!=t.match(c.URL_SCHEME_REGEX)}c.URL_SCHEME_REGEX=/^https?:\/\//;const d=(t,e)=>{if("undefined"===typeof fetch&&(null==e||null==e.fetchFunc))return null;{let s=!0;if(s=Array.isArray(t)?t.every((t=>p(t))):p(t),s)return w(t,e)}return null};function w(t,e){return new c(t,e)}a.bM.registerSaveRouter(d),a.bM.registerLoadRouter(d)}}]);
//# sourceMappingURL=chunk-vendors-f0d3b996.d8a2c0b5.js.map