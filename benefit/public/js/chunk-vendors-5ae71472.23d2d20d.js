"use strict";(self["webpackChunkbenefit"]=self["webpackChunkbenefit"]||[]).push([[5951],{30282:function(n,t,e){e.d(t,{m:function(){return u}});var i=e(22792),a=e(75694),o=e(27575);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class u{constructor(n){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=n,this.rank=n.length,this.enableShapeUniforms=(0,i.ik)(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const n=(0,a.Jp)("rc",this.rank),t=(0,o.bf)(this.rank),e=this.getOutOfBoundsCondition(n),i=this.getSetup(n),u=this.getOutput(n);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${e}) {\n            setOutput(vec4(0));\n          } else {\n            ${i}\n\n            setOutput(vec4(${u}));\n          }\n        }\n      `}}getSourceCoordsArr(n){const t=[];for(let e=0;e<=1;e++)for(let i=0;i<=1;i++){let a=`${0===e?"r":"rp1"}, ${0===i?"c":"cp1"}`;for(let t=2;t<this.rank;t++)a=`${n[n.length-1-t]},`+a;t.push(a)}return t}getOutOfBoundsCondition(n){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let e=this.rank-2;e<this.rank;e++)t+=`${n[e]} >= ${this.enableShapeUniforms?`outShape[${e}]`:this.outputShape[e]}`,e<this.rank-1&&(t+="||");return t}getSetup(n){if(1===this.rank)return"";const t=n.slice(-2),e=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],i=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${e};\n      bool rEdge = rp1 >= ${i};\n    `}getOutput(n){const t=this.getSourceCoordsArr(n);if(1===this.rank){const n=this.enableShapeUniforms?"outShape":this.outputShape[0];return`getA(rc), (rc + 1 >= ${n} ? 0. : getA(rc + 1)), 0, 0`}return`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}}},75694:function(n,t,e){
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(n,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${n}.${t}`))}function a(n,t){return 1===t?[n]:i(n,t)}function o(n,t){if(1===n)return"rc";let e="";for(let i=0;i<n;i++)e+=t[i],i<n-1&&(e+=",");return e}e.d(t,{Fd:function(){return i},Jp:function(){return a},kp:function(){return o}})},59344:function(n,t,e){e.d(t,{e:function(){return a}});var i=e(27575);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class a{constructor(n,t,e){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,e)=>t[0]+n[e]+t[1]));const a=n.length,o=(0,i.bf)(a),u=t.map((n=>n[0])).join(","),r=t.map(((t,e)=>t[0]+n[e])).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a);this.userCode=1!==a?`\n      ${o} start = ${o}(${u});\n      ${o} end = ${o}(${r});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${o} coords = outC - start;\n          setOutput(getX(${l}));\n        }\n      }\n    `:`\n        int start = ${u};\n        int end = ${r};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}},11601:function(n,t,e){e.d(t,{_:function(){return o}});var i=e(75694),a=e(27575);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class o{constructor(n,t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,e)=>t[0]+n[e]+t[1]));const o=n.length,u=(0,a.bf)(o),r=t.map((n=>n[0])).join(","),l=t.map(((t,e)=>t[0]+n[e])).join(","),s=(0,i.Jp)("rc",o),c=(0,i.Jp)("source",o),x=`${s[o-1]} < ${this.outputShape[o-1]}`,d=1===o?"source":`vec2(${c.slice(-2).join()})`,h=[`${u} rc = outputLoc;`,`${s[o-1]} += 1;\n       if(${x}) {\n      `,1===o?"":`}\n       rc = outputLoc;\n       ${s[o-2]} += 1;\n       if(${s[o-2]} < ${this.outputShape[o-2]}) {`,1===o?"":`  ${s[o-1]} += 1;\n         if(${x}) {`],$=1===o?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let f="";for(let i=0,a=1===o?2:4;i<a;i++)f+=`\n        ${h[i]}\n        if (${$}) {\n          result[${i}] = float(value);\n        } else {\n          ${u} source = rc - start;\n          result[${i}] = getChannel(getX(${c.join()}), ${d});\n        }\n      `;f+=1===o?"} ":"}}",this.userCode=`\n      const ${u} start = ${u}(${r});\n      const ${u} end = ${u}(${l});\n\n      void main() {\n        ${u} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${f}\n        setOutput(result);\n      }\n    `}}},80297:function(n,t,e){e.d(t,{U:function(){return a},h:function(){return i}});
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class i{constructor(n,t,e,i=!1,a=!1){if(this.variableNames=["x"],"avg"===t&&e)throw new Error("Cannot compute positions for average pool.");const o=n.filterWidth,u=n.strideHeight,r=n.strideWidth,l=n.dilationHeight,s=n.dilationWidth,c=n.effectiveFilterHeight,x=n.effectiveFilterWidth,d=n.padInfo.top,h=n.padInfo.left;this.outputShape=n.outShape;const $="avg"===t,f=`((batch  * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + d`,C=`(xR * ${n.inWidth} + xC) * ${n.inChannels} + d`;let v="0.0";if($||(v="-1.0 / 1e-20"),e){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${u}, ${r});\n        const ivec2 pads = ivec2(${d}, ${h});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${x};\n                wC += ${s}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${i?a?f:C:`wR * ${x} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}const p="max";let V=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(V="avgValue / max(count, 1.0)");const m=4*Math.floor(o/4),g=o%4,R=`\n      if (${$}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${p}(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${u}, ${r});\n      const ivec2 pads = ivec2(${d}, ${h});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${n.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${n.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${m}; wC += 4) {\n            int xC = xCCorner + wC * ${s};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${s}, d),\n              getValue(batch, xR, xC + 2 * ${s}, d),\n              getValue(batch, xR, xC + 3 * ${s}, d)\n            );\n\n            ${R}\n          }\n\n          int xC = xCCorner + ${m};\n          if (${1===g}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${R}\n          } else if (${2===g}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${s}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${R}\n          } else if (${3===g}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${s}, d),\n              getValue(batch, xR, xC + 2 * ${s}, d),\n              initializationValue\n            );\n\n            ${R}\n          }\n        }\n        setOutput(${V});\n      }\n    `}}class a{constructor(n,t,e,i=!1,a=!1){if(this.variableNames=["x"],"avg"===t&&e)throw new Error("Cannot compute positions for average pool.");const o=n.filterWidth,u=n.strideDepth,r=n.strideHeight,l=n.strideWidth,s=n.dilationDepth,c=n.dilationHeight,x=n.dilationWidth,d=n.effectiveFilterDepth,h=n.effectiveFilterHeight,$=n.effectiveFilterWidth,f=n.padInfo.front,C=n.padInfo.top,v=n.padInfo.left;this.outputShape=n.outShape;const p="avg"===t;let V="0.0";if(p||(V="-1.0 / 1e-20"),e){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${u}, ${r}, ${l});\n        const ivec3 pads = ivec3(${f}, ${C}, ${v});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${d};\n              wD += ${s}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${n.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${h};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${n.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${$};\n                  wC += ${x}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${n.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${i?a?`(((batch * ${n.inDepth} + xD) * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`((xD * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`wD * ${h} * ${$} +\n                      wR * ${$} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}const m="max";let g=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(g="avgValue / max(count, 1.0)");const R=4*Math.floor(o/4),b=o%4,w=`\n      if (${p}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${m}(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${u}, ${r}, ${l});\n      const ivec3 pads = ivec3(${f}, ${C}, ${v});\n      const float initializationValue = ${V};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${n.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${V});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${s}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${n.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${R}; wC += 4) {\n              int xC = xCCorner + wC * ${x};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${x}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${x}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${x}, ch)\n              );\n\n              ${w}\n            }\n\n            int xC = xCCorner + ${R};\n            if (${1===b}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${w}\n            } else if (${2===b}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${x}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${w}\n            } else if (${3===b}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${x}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${x}, ch),\n                initializationValue\n              );\n\n              ${w}\n            }\n          }\n        }\n        setOutput(${g});\n      }\n    `}}},18541:function(n,t,e){e.d(t,{t:function(){return i}});
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class i{constructor(n,t){this.variableNames=["x"];const{windowSize:e,batchSize:i,inSize:a,outSize:o}=n;this.outputShape=[i,o];let u="0.0",r="";"prod"===t?u="1.0":"min"===t?(u="1.0 / 1e-20",r="min"):"max"===t&&(u="-1.0 / 1e-20",r="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?l="sumValue":"prod"===t?l="prodValue":"all"===t?l="allValue":"any"===t&&(l="anyValue");const s=4*Math.floor(e/4),c=e%4;let x=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${r}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${r}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,d="vec4";"all"===t?(u="1.0",x="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===t&&(u="0.0",x="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let h="";a%e>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${u};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${h}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${e};\n\n        vec4 minMaxValue = vec4(${u});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${s}; i += 4) {\n          int inIdx = inOffset + i;\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${x}\n        }\n\n        int inIdx = inOffset + ${s};\n        if (${1===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${x}\n        } else if (${2===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${x}\n        } else if (${3===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${x}\n        }\n        setOutput(${l});\n      }\n    `}}}}]);
//# sourceMappingURL=chunk-vendors-5ae71472.23d2d20d.js.map