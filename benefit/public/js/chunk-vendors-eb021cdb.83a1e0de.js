"use strict";(self["webpackChunkbenefit"]=self["webpackChunkbenefit"]||[]).push([[7252],{20741:function(t,n,e){e.d(n,{ljI:function(){return y.ljI},Vvy:function(){return y.Vvy},PH8:function(){return y.PH8},OMN:function(){return y.OMN},EkD:function(){return y.EkD},u8Z:function(){return y.u8Z},FSt:function(){return y.FSt},Jp_:function(){return y.Jp_},p_m:function(){return y.p_m},QKF:function(){return y.QKF},epO:function(){return y.epO},TyE:function(){return y.TyE},lxb:function(){return y.lxb},zP9:function(){return y.zP9},ho8:function(){return y.ho8},cS:function(){return y.cS},wwC:function(){return y.wwC},VCH:function(){return y.VCH},jAQ:function(){return y.jAQ},Ik2:function(){return y.Ik2},N4F:function(){return y.N4F},HNs:function(){return y.HNs},vj7:function(){return y.vj7},KXH:function(){return y.KXH},QDP:function(){return y.QDP},vaV:function(){return y.vaV},pr3:function(){return y.pr3},$zE:function(){return y.$zE},$dB:function(){return y.$dB},p2J:function(){return y.p2J},rFm:function(){return y.rFm},jfg:function(){return y.jfg},A1h:function(){return y.A1h},iGz:function(){return y.iGz},gC7:function(){return y.gC7},Mn0:function(){return y.Mn0},MnK:function(){return y.MnK},MRQ:function(){return y.MRQ},jj_:function(){return y.jj_},nY8:function(){return y.nY8},GJx:function(){return k.GJ},wNW:function(){return y.wNW},TMz:function(){return y.TMz},tGH:function(){return y.tGH},X$8:function(){return y.X$8},nVu:function(){return y.nVu},ORI:function(){return y.ORI},jxD:function(){return y.jxD},Qgm:function(){return y.Qgm},Pah:function(){return y.Pah},rsH:function(){return y.rsH},BRl:function(){return y.BRl},_s9:function(){return y._s9},ox3:function(){return y.ox3},ybN:function(){return y.ybN},ybj:function(){return y.ybj},rGP:function(){return y.rGP},SQl:function(){return y.SQl},BxF:function(){return y.BxF},ZgB:function(){return y.ZgB},ElG:function(){return y.ElG},awo:function(){return y.awo},i5R:function(){return y.i5R},aAr:function(){return y.aAr},T7M:function(){return y.T7M},O4G:function(){return y.O4G},mxL:function(){return y.mxL},XhZ:function(){return y.XhZ},lLS:function(){return y.lLS},OAQ:function(){return y.OAQ},lzr:function(){return y.lzr},dv8:function(){return y.dv8},gIW:function(){return y.gIW},E3$:function(){return y.E3$},iPs:function(){return y.iPs},uI_:function(){return k.uI},jM4:function(){return y.jM4},ToN:function(){return y.ToN},X0$:function(){return y.X0$},mIA:function(){return y.mIA},CwD:function(){return y.CwD},mnI:function(){return y.mnI},tG8:function(){return y.tG8},Cg$:function(){return y.Cg$},RUm:function(){return y.RUm},nZd:function(){return y.nZd},LXA:function(){return y.LXA},VAI:function(){return y.VAI},t3d:function(){return y.t3d},ySp:function(){return y.ySp},cHb:function(){return y.cHb},RXX:function(){return y.RXX},TL8:function(){return y.TL8},LDN:function(){return y.LDN},g5A:function(){return y.g5A},lNG:function(){return y.lNG},LG0:function(){return y.LG0},x7F:function(){return y.x7F},BLA:function(){return y.BLA},WT3:function(){return y.WT3},xu7:function(){return y.xu7},l0G:function(){return y.l0G},SDM:function(){return y.SDM},Zl4:function(){return y.Zl4},e0f:function(){return y.e0f},ylV:function(){return y.ylV},urI:function(){return y.urI},LWX:function(){return y.LWX},mM$:function(){return y.mM$},ODT:function(){return y.ODT},pyJ:function(){return y.pyJ},Ncv:function(){return y.Ncv},kdj:function(){return y.kdj},oJ2:function(){return y.oJ2},CQC:function(){return y.CQC},mH5:function(){return y.mH5},Q6t:function(){return y.Q6t},LRy:function(){return y.LRy},sDr:function(){return y.sDr},huO:function(){return y.huO},fUj:function(){return y.fUj},P_L:function(){return y.P_L},R23:function(){return y.R23},hgw:function(){return y.hgw},FCQ:function(){return y.FCQ},jOE:function(){return y.jOE},XQy:function(){return y.XQy},D7i:function(){return y.D7i},BK4:function(){return y.BK4},hVg:function(){return y.hVg},TOR:function(){return y.TOR},pJc:function(){return y.pJc},uWl:function(){return y.uWl},l6P:function(){return y.l6P},u$b:function(){return y.u$b},vI1:function(){return y.vI1},YVe:function(){return y.YVe},hql:function(){return y.hql},J3C:function(){return y.J3C},JiE:function(){return y.JiE},rFG:function(){return y.rFG},Fin:function(){return y.Fin},A8B:function(){return y.A8B},C8s:function(){return y.C8s},BoJ:function(){return y.BoJ},L6G:function(){return y.L6G},DvZ:function(){return y.DvZ},jgd:function(){return y.jgd},Blb:function(){return y.Blb},dFH:function(){return y.dFH},M6A:function(){return y.M6A},Ddj:function(){return y.Ddj},GZp:function(){return y.GZp},pnw:function(){return y.pnw},UcO:function(){return y.UcO},YAb:function(){return y.YAb},iW0:function(){return y.iW0},$jE:function(){return y.$jE},PbM:function(){return y.PbM},WuN:function(){return y.WuN},oFs:function(){return y.oFs},iuW:function(){return y.iuW},ylz:function(){return a.yl},X4r:function(){return y.X4r},FAs:function(){return y.FAs},TBb:function(){return y.TBb},dLy:function(){return y.dLy},wx0:function(){return y.wx0},EwU:function(){return y.EwU},dXR:function(){return y.dXR},pPe:function(){return y.pPe},xJ3:function(){return y.xJ3},Dr:function(){return y.Dr},C0T:function(){return p},hOW:function(){return u.hOW},ZEY:function(){return r},ra8:function(){return u.ra8},eMq:function(){return g},Hi9:function(){return c.Hi},_K2:function(){return l._K},kpo:function(){return m},dA1:function(){return d},gJX:function(){return c.gJ},tAK:function(){return f.tA},tQQ:function(){return u.tQQ},d_2:function(){return u.d_2},Kro:function(){return i},chL:function(){return o.ch},DZQ:function(){return c.DZ},TuY:function(){return o.Tu},ZSL:function(){return s},Ul9:function(){return u.Ul9}});e(17890);var r=e(62198),i=e(34969),s=e(89783),a=e(21722),o=e(52046),u=e(38960),c=e(35287),f=e(37074),l=e(46574);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const h=(()=>"undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof setImmediate?setImmediate:t=>t())();function d(){return new Promise((t=>h((()=>t()))))}var p=e(19513),g=e(88580),m=e(75863),k=e(15149),y=e(15441)},10363:function(t,n,e){var r=e(67897),i=(e(66652),e(15618),e(83672),e(448)),s=e(29809),a=e(70125),o=e(75295),u=e(21722);
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
(0,r.Ye)();const c={buffer:i.r,cast:s.w,clone:a.o,print:o.y};(0,u.Q5)(c)},88580:function(t,n,e){
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function r(){return"undefined"!==typeof navigator&&null!=navigator}let i;function s(t){i=t}function a(t){if(void 0!==i)return i;if(t||r()){if(t||(t=navigator),"ReactNative"===t.product)return!0;const n=t.userAgent||t.vendor||("undefined"!==typeof window?window.opera:"");if(!n){const n=t;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(n)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(n.substr(0,4))}return!1}function o(){return"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope}e.r(n),e.d(n,{isBrowser:function(){return o},isMobile:function(){return a},mockIsMobile:function(){return s}})},67897:function(t,n,e){e.d(n,{T2:function(){return w},Ye:function(){return b}});var r=e(15149),i=e(46574),s=e(41743),a=e(15441),o=e(37074),u=e(73673),c=e(41466),f=e(37427),l=e(21722),h=e(30565),d=e(45119),p=e(89783);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function g(t){return null!=t.kernelName}class m{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((t=>t.name))))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class k{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new m}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const e=t[n],r=await this.initializeBackend(e).success;if(r)return void await this.setBackend(e)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:n}=this.initializeBackend(t);if(n)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,n,e=1){return t in this.registryFactory?(u.i(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:n,priority:e},!0)}async setBackend(t){if(null==this.registryFactory[t])throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,null==this.registry[t]){this.backendInstance=null;const{success:n,asyncInit:e}=this.initializeBackend(t),r=e?await n:n;if(!r)return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new c.UD(this.backendInstance),!0}setupRegisteredKernels(){const t=(0,o.Op)(this.backendName);t.forEach((t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(t){const n=(0,o.Op)(t);n.forEach((n=>{null!=n.disposeFunc&&n.disposeFunc(this.registry[t])}))}initializeBackend(t){const n=this.registryFactory[t];if(null==n)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const e=n.factory();if(!e||e instanceof r.uI||"function"!==typeof e.then)return this.registry[t]=e,{success:!0,asyncInit:!1};{const n=++this.pendingBackendInitId,r=e.then((e=>!(n<this.pendingBackendInitId)&&(this.registry[t]=e,this.pendingBackendInit=null,!0))).catch((e=>(n<this.pendingBackendInitId||(this.pendingBackendInit=null,u.i(`Initialization of backend ${t} failed`),u.i(e.stack||e.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(e){return u.i(`Initialization of backend ${t} failed`),u.i(e.stack||e.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority))}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const e=t[n],{success:r,asyncInit:i}=this.initializeBackend(e);if(i||r)return{name:e,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,n){const e=this.state.tensorInfo.get(n),r=e.backend,i=this.readSync(n),s=r.refCount(n);r.disposeData(n,!0),e.backend=t,t.move(n,i,e.shape,e.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,n){let e,r=null;if(null==n){if("function"!==typeof t)throw new Error("Please provide a function to tidy()");n=t}else{if("string"!==typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof n)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(e)),(()=>(e=n(),e instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),e)))}scopedRun(t,n,e){t();try{const t=e();return n(),t}catch(r){throw n(),r}}nextTensorId(){return k.nextTensorId++}nextVariableId(){return k.nextVariableId++}clone(t){const n=w.runKernel(a.lzr,{x:t}),e={x:t},r=t=>({x:()=>{const n="float32",e={x:t},r={dtype:n};return w.runKernel(a.KXH,e,r)}}),i=[];return this.addTapeNode(this.state.activeScope.name,e,[n],r,i,{}),n}runKernel(t,n,e){null==this.backendName&&this.backend;const r=null!=(0,o._5)(t,this.backendName);if(!r)throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:n,attrs:e})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,n,e){const r=this.backend.numDataIds();let i=0;e.forEach((t=>{i+="complex64"===t.dtype?3:1}));const s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=r-n-i-s;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${t}'`)}runKernelFunc(t){let n,e=[];const r=this.isTapeOn(),i=this.state.numBytes,s=this.state.numTensors;let a,u;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const c=g(t)?t.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(g(t)){const{kernelName:n,inputs:i,attrs:s}=t;null==this.backendName&&this.backend;const c=(0,o._5)(n,this.backendName);d.vA(null!=c,(()=>`Cannot find registered kernel '${n}' for backend '${this.backendName}'`)),a=()=>{const t=this.backend.numDataIds();u=c.kernelFunc({inputs:i,attrs:s,backend:this.backend});const a=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(n,t,a);const o=a.map((t=>null!=t.rank?t:this.makeTensorFromTensorInfo(t)));if(r){const t=this.getTensorsForGradient(n,i,o);e=this.saveTensorsForBackwardMode(t)}return o}}else{const{forwardFunc:n}=t,i=t=>{r&&(e=t.map((t=>this.keep(this.clone(t)))))};a=()=>{const t=this.backend.numDataIds();u=this.tidy((()=>n(this.backend,i)));const e=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,t,e),e}}const{inputs:f,attrs:l}=t,h=g(t)?null:t.backwardsFunc;let p;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(p=this.profiler.profileKernel(c,f,(()=>a())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),n=p.outputs):n=a()})),r&&this.addTapeNode(c,f,n,h,e,l),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(f).map((t=>null!=f[t]?f[t].shape:null)),outputShapes:n.map((t=>t.shape)),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(u)?n:n[0]}saveTensorsForBackwardMode(t){const n=t.map((t=>this.keep(this.clone(t))));return n}getTensorsForGradient(t,n,e){const r=(0,o.vQ)(t);if(null!=r){const t=r.inputsToSave||[],i=r.outputsToSave||[];let s;r.saveAllInputs?(d.vA(Array.isArray(n),(()=>"saveAllInputs is true, expected inputs to be an array.")),s=Object.keys(n).map((t=>n[t]))):s=t.map((t=>n[t]));const a=e.filter(((t,n)=>i[n]));return s.concat(a)}return[]}makeTensor(t,n,e,r){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");e=e||"float32",r=r||this.backend;let i=t;"string"===e&&d.Kg(t[0])&&(i=t.map((t=>p.encodeString(t))));const s=r.write(i,n,e),a=new l.qY(n,e,s,this.nextTensorId());if(this.trackTensor(a,r),"string"===e){const t=this.state.tensorInfo.get(s),n=(0,d.SL)(i);this.state.numBytes+=n-t.bytes,t.bytes=n}return a}makeTensorFromDataId(t,n,e,r){e=e||"float32";const i={dataId:t,shape:n,dtype:e};return this.makeTensorFromTensorInfo(i,r)}makeTensorFromTensorInfo(t,n){const{dataId:e,shape:r,dtype:i}=t,s=new l.qY(r,i,e,this.nextTensorId());return this.trackTensor(s,n),s}makeVariable(t,n=!0,e,r){e=e||this.nextVariableId().toString(),null!=r&&r!==t.dtype&&(t=t.cast(r));const i=new l.rT(t,n,e,this.nextTensorId());if(null!=this.state.registeredVariables[i.name])throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(t,n){this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++;let e=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(e=t.size*d.jv(t.dtype)),this.state.numBytes+=e,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:e})),t instanceof l.rT||this.track(t)}incRef(t,n){this.trackTensor(t,n),this.backend.incRef(t.dataId)}removeDataId(t,n){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const n=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,"string"===t.dtype&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),"complex64"!==t.dtype&&"string"!==t.dtype){const n=t.size*d.jv(t.dtype);this.state.numBytes-=n}n.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,n.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const n=this.state.registeredVariables[t];this.disposeVariable(n)}}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const n=this.state.numBytes,e=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((t=>t.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-e;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,n,e,r,i,s){const a={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:e,saved:i},u=(0,o.vQ)(t);null!=u&&(r=u.gradFunc),null!=r&&(a.gradient=t=>(t=t.map(((t,n)=>{if(null==t){const t=e[n],r=d.Ty(t.size,t.dtype);return this.makeTensor(r,t.shape,t.dtype)}return t})),r(t.length>1?t:t[0],i,s))),this.state.activeTape.push(a)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(n.name=t),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(t){const n=(0,h.NB)(t),e=new Set(n.map((t=>t.id)));for(let i=0;i<this.state.activeScope.track.length;i++){const t=this.state.activeScope.track[i];t.kept||e.has(t.id)||t.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach((t=>{t.kept||t.scopeId!==r.id||this.track(t)}))}gradients(t,n,e,r=!1){if(d.vA(n.length>0,(()=>"gradients() received an empty list of xs.")),null!=e&&"float32"!==e.dtype)throw new Error(`dy must have 'float32' dtype, but has '${e.dtype}'`);const i=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",t)));d.vA(i instanceof l.qY,(()=>"The result y returned by f() must be a tensor."));const s=(0,f.p)(this.state.activeTape,n,i);if(!r&&0===s.length&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const t={};t[i.id]=null==e?y(i.shape):e,(0,f.a)(t,s,(t=>this.tidy(t)),v);const r=n.map((n=>t[n.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((t=>{for(const n of t.saved)n.dispose()})),this.state.activeTape=null),{value:i,grads:r}}))}customGrad(t){return d.vA(d.Tn(t),(()=>"The f passed in customGrad(f) must be a function.")),(...n)=>{let e;d.vA(n.every((t=>t instanceof l.qY)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const r={};n.forEach(((t,n)=>{r[n]=t}));const i=(r,i)=>(e=t(...n,i),d.vA(e.value instanceof l.qY,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),d.vA(d.Tn(e.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),e.value),s=(t,r)=>{const i=e.gradFunc(t,r),s=Array.isArray(i)?i:[i];d.vA(s.length===n.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),d.vA(s.every((t=>t instanceof l.qY)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const a={};return s.forEach(((t,n)=>{a[n]=()=>t})),a};return this.runKernelFunc({forwardFunc:i,backwardsFunc:s,inputs:r})}}readSync(t){const n=this.state.tensorInfo.get(t);return n.backend.readSync(t)}read(t){const n=this.state.tensorInfo.get(t);return n.backend.read(t)}readToGPU(t,n){const e=this.state.tensorInfo.get(t);return e.backend.readToGPU(t,n)}async time(t){const n=(0,p.now)(),e=await this.backend.time(t);return e.wallMs=(0,p.now)()-n,e}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new m;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function y(t){const n=(0,d.FZ)((0,d.Ze)(t),"float32");return w.makeTensor(n,t,"float32")}function b(){const t=(0,s.L)();if(null==t._tfengine){const n=new i.OH(t);t._tfengine=new k(n)}return(0,i.tj)(t._tfengine.ENV),(0,l.qP)((()=>t._tfengine)),t._tfengine}k.nextTensorId=0,k.nextVariableId=0;const w=b();function v(t,n){const e={a:t,b:n};return w.runKernel(a.OMN,e)}},46574:function(t,n,e){e.d(n,{OH:function(){return s},_K:function(){return c},tj:function(){return l}});var r=e(45119);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i="tfjsflags";class s{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=a,this.populateURLFlags()}setPlatform(t,n){null!=this.platform&&(c().getBool("IS_TEST")||c().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=n}registerFlag(t,n,e){if(this.flagRegistry[t]={evaluationFn:n,setHook:e},null!=this.urlFlags[t]){const n=this.urlFlags[t];c().getBool("IS_TEST")||c().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${n}.`),this.set(t,n)}}async getAsync(t){return t in this.flags||(this.flags[t]=await this.evaluateFlag(t)),this.flags[t]}get(t){if(t in this.flags)return this.flags[t];const n=this.evaluateFlag(t);if((0,r.yL)(n))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=n,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,n){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=n,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(n)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const t=this.getQueryParams(this.global.location.search);if(i in t){const n=t[i].split(",");n.forEach((t=>{const[n,e]=t.split(":");this.urlFlags[n]=u(n,e)}))}}}function a(t){const n={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((t,...e)=>(o(n,e[0],e[1]),e.join("=")))),n}function o(t,n,e){t[decodeURIComponent(n)]=decodeURIComponent(e||"")}function u(t,n){const e=n.toLowerCase();return"true"===e||"false"===e?"true"===e:""+ +e===e?+e:n}function c(){return f}let f=null;function l(t){f=t}}}]);
//# sourceMappingURL=chunk-vendors-eb021cdb.83a1e0de.js.map