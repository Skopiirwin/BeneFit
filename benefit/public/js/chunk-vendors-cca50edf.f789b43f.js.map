{"version":3,"file":"js/chunk-vendors-cca50edf.f789b43f.js","mappings":"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","sources":["webpack://benefit/./node_modules/@tensorflow/tfjs-backend-webgl/dist/concat_gpu.js","webpack://benefit/./node_modules/@tensorflow/tfjs-backend-webgl/dist/concat_packed_gpu.js","webpack://benefit/./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_backprop_gpu.js","webpack://benefit/./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_backprop_gpu_depthwise.js","webpack://benefit/./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_backprop_packed_gpu.js","webpack://benefit/./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_gpu.js","webpack://benefit/./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_gpu_depthwise.js","webpack://benefit/./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_packed_gpu.js","webpack://benefit/./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_packed_gpu_depthwise.js","webpack://benefit/./node_modules/@tensorflow/tfjs-backend-webgl/dist/crop_and_resize_gpu.js","webpack://benefit/./node_modules/@tensorflow/tfjs-backend-webgl/dist/cum_gpu.js"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nexport class ConcatProgram {\n    // Concats 2d tensors along axis=1. See comments in MathBackendWebGL.concat().\n    constructor(shapes) {\n        this.outputShape = [];\n        this.outputShape = backend_util.computeOutShape(shapes, 1 /* axis */);\n        this.variableNames = shapes.map((_, i) => `T${i}`);\n        const offsets = new Array(shapes.length - 1);\n        offsets[0] = shapes[0][1];\n        for (let i = 1; i < offsets.length; i++) {\n            offsets[i] = offsets[i - 1] + shapes[i][1];\n        }\n        const snippets = [`if (yC < ${offsets[0]}) setOutput(getT0(yR, yC));`];\n        for (let i = 1; i < offsets.length; i++) {\n            const shift = offsets[i - 1];\n            snippets.push(`else if (yC < ${offsets[i]}) ` +\n                `setOutput(getT${i}(yR, yC-${shift}));`);\n        }\n        const lastIndex = offsets.length;\n        const lastShift = offsets[offsets.length - 1];\n        snippets.push(`else setOutput(getT${lastIndex}(yR, yC-${lastShift}));`);\n        this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${snippets.join('\\n        ')}\n      }\n    `;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uY2F0X2dwdS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RmanMtYmFja2VuZC13ZWJnbC9zcmMvY29uY2F0X2dwdS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFHbkQsTUFBTSxPQUFPLGFBQWE7SUFLeEIsOEVBQThFO0lBQzlFLFlBQVksTUFBK0I7UUFKM0MsZ0JBQVcsR0FBYSxFQUFFLENBQUM7UUFLekIsSUFBSSxDQUFDLFdBQVcsR0FBRyxZQUFZLENBQUMsZUFBZSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDdEUsSUFBSSxDQUFDLGFBQWEsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRW5ELE1BQU0sT0FBTyxHQUFhLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDdkQsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMxQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUN2QyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDNUM7UUFFRCxNQUFNLFFBQVEsR0FBRyxDQUFDLFlBQVksT0FBTyxDQUFDLENBQUMsQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO1FBQ3ZFLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ3ZDLE1BQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDN0IsUUFBUSxDQUFDLElBQUksQ0FDVCxpQkFBaUIsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJO2dCQUMvQixpQkFBaUIsQ0FBQyxXQUFXLEtBQUssS0FBSyxDQUFDLENBQUM7U0FDOUM7UUFDRCxNQUFNLFNBQVMsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDO1FBQ2pDLE1BQU0sU0FBUyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQzlDLFFBQVEsQ0FBQyxJQUFJLENBQUMsc0JBQXNCLFNBQVMsV0FBVyxTQUFTLEtBQUssQ0FBQyxDQUFDO1FBRXhFLElBQUksQ0FBQyxRQUFRLEdBQUc7Ozs7OztVQU1WLFFBQVEsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDOztLQUVoQyxDQUFDO0lBQ0osQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge2JhY2tlbmRfdXRpbH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcbmltcG9ydCB7R1BHUFVQcm9ncmFtfSBmcm9tICcuL2dwZ3B1X21hdGgnO1xuXG5leHBvcnQgY2xhc3MgQ29uY2F0UHJvZ3JhbSBpbXBsZW1lbnRzIEdQR1BVUHJvZ3JhbSB7XG4gIHZhcmlhYmxlTmFtZXM6IHN0cmluZ1tdO1xuICBvdXRwdXRTaGFwZTogbnVtYmVyW10gPSBbXTtcbiAgdXNlckNvZGU6IHN0cmluZztcblxuICAvLyBDb25jYXRzIDJkIHRlbnNvcnMgYWxvbmcgYXhpcz0xLiBTZWUgY29tbWVudHMgaW4gTWF0aEJhY2tlbmRXZWJHTC5jb25jYXQoKS5cbiAgY29uc3RydWN0b3Ioc2hhcGVzOiBBcnJheTxbbnVtYmVyLCBudW1iZXJdPikge1xuICAgIHRoaXMub3V0cHV0U2hhcGUgPSBiYWNrZW5kX3V0aWwuY29tcHV0ZU91dFNoYXBlKHNoYXBlcywgMSAvKiBheGlzICovKTtcbiAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBzaGFwZXMubWFwKChfLCBpKSA9PiBgVCR7aX1gKTtcblxuICAgIGNvbnN0IG9mZnNldHM6IG51bWJlcltdID0gbmV3IEFycmF5KHNoYXBlcy5sZW5ndGggLSAxKTtcbiAgICBvZmZzZXRzWzBdID0gc2hhcGVzWzBdWzFdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgb2Zmc2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2Zmc2V0c1tpXSA9IG9mZnNldHNbaSAtIDFdICsgc2hhcGVzW2ldWzFdO1xuICAgIH1cblxuICAgIGNvbnN0IHNuaXBwZXRzID0gW2BpZiAoeUMgPCAke29mZnNldHNbMF19KSBzZXRPdXRwdXQoZ2V0VDAoeVIsIHlDKSk7YF07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBvZmZzZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzaGlmdCA9IG9mZnNldHNbaSAtIDFdO1xuICAgICAgc25pcHBldHMucHVzaChcbiAgICAgICAgICBgZWxzZSBpZiAoeUMgPCAke29mZnNldHNbaV19KSBgICtcbiAgICAgICAgICBgc2V0T3V0cHV0KGdldFQke2l9KHlSLCB5Qy0ke3NoaWZ0fSkpO2ApO1xuICAgIH1cbiAgICBjb25zdCBsYXN0SW5kZXggPSBvZmZzZXRzLmxlbmd0aDtcbiAgICBjb25zdCBsYXN0U2hpZnQgPSBvZmZzZXRzW29mZnNldHMubGVuZ3RoIC0gMV07XG4gICAgc25pcHBldHMucHVzaChgZWxzZSBzZXRPdXRwdXQoZ2V0VCR7bGFzdEluZGV4fSh5UiwgeUMtJHtsYXN0U2hpZnR9KSk7YCk7XG5cbiAgICB0aGlzLnVzZXJDb2RlID0gYFxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IHlSID0gY29vcmRzLng7XG4gICAgICAgIGludCB5QyA9IGNvb3Jkcy55O1xuXG4gICAgICAgICR7c25pcHBldHMuam9pbignXFxuICAgICAgICAnKX1cbiAgICAgIH1cbiAgICBgO1xuICB9XG59XG4iXX0=","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class ConcatPackedProgram {\n    constructor(shapes, axis) {\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = [];\n        this.outputShape = backend_util.computeOutShape(shapes, axis);\n        const shape = this.outputShape;\n        const rank = shape.length;\n        const dtype = getCoordsDataType(rank);\n        const coords = getChannels('coords', rank);\n        const channels = ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank);\n        this.variableNames = shapes.map((_, i) => `T${i}`);\n        const offsets = new Array(shapes.length - 1);\n        offsets[0] = shapes[0][axis];\n        for (let i = 1; i < offsets.length; i++) {\n            offsets[i] = offsets[i - 1] + shapes[i][axis];\n        }\n        const channel = channels[axis];\n        const lastChannels = channels.slice(-2);\n        const allChannels = channels.join();\n        let getValueSnippet = `if (${channel} < ${offsets[0]}) {\n        return getChannel(\n            getT0(${allChannels}), vec2(${lastChannels.join()}));\n        }`;\n        for (let i = 1; i < offsets.length; i++) {\n            const shift = offsets[i - 1];\n            // Note: the >= comparison below may seem unnecessary given the check\n            // above but is needed to workaround branch execution issues on some\n            // devices. It makes all the conditions exclusive without relying on\n            // execution order.\n            getValueSnippet += `\n        if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i - 1]}) {\n          return getChannel(\n            getT${i}(${shiftedChannels(channels, channel, shift)}),\n            vec2(${shiftedChannels(lastChannels, channel, shift)}));\n        }`;\n        }\n        const lastIndex = offsets.length;\n        const shift = offsets[offsets.length - 1];\n        getValueSnippet += `\n        return getChannel(\n          getT${lastIndex}(${shiftedChannels(channels, channel, shift)}),\n          vec2(${shiftedChannels(lastChannels, channel, shift)}));`;\n        this.userCode = `\n      float getValue(${channels.map(x => 'int ' + x)}) {\n        ${getValueSnippet}\n      }\n\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${coords}), 0., 0., 0.);\n\n        ${coords[rank - 1]} = ${coords[rank - 1]} + 1;\n        if (${coords[rank - 1]} < ${shape[rank - 1]}) {\n          result.g = getValue(${coords});\n        }\n\n        ${coords[rank - 2]} = ${coords[rank - 2]} + 1;\n        if (${coords[rank - 2]} < ${shape[rank - 2]}) {\n          result.a = getValue(${coords});\n        }\n\n        ${coords[rank - 1]} = ${coords[rank - 1]} - 1;\n        if (${coords[rank - 2]} < ${shape[rank - 2]} &&\n            ${coords[rank - 1]} < ${shape[rank - 1]}) {\n          result.b = getValue(${coords});\n        }\n        setOutput(result);\n      }\n    `;\n    }\n}\n/**\n * Return an expression for coordinates into a vector where a given channel\n * will be offset by [shift].\n *\n * @param channels the channels to consider\n * @param channel the channel we want shifted\n * @param shift  the amount to subtract from the channel.\n *\n * @returns a string of the form 'x, y-[shift], z' where any one channel can\n * have the shift applied.\n */\nfunction shiftedChannels(channels, channel, shift) {\n    const channelIdx = channels.indexOf(channel);\n    const res = channels.map((c, idx) => {\n        if (idx === channelIdx) {\n            return `${c} - ${shift}`;\n        }\n        else {\n            return c;\n        }\n    });\n    return res.join();\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uY2F0X3BhY2tlZF9ncHUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtd2ViZ2wvc3JjL2NvbmNhdF9wYWNrZWRfZ3B1LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUVILE9BQU8sRUFBQyxZQUFZLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUduRCxPQUFPLEVBQUMsV0FBVyxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFDM0MsT0FBTyxFQUFDLGlCQUFpQixFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFFcEQsTUFBTSxPQUFPLG1CQUFtQjtJQU85QixZQUFZLE1BQWtCLEVBQUUsSUFBWTtRQUw1QyxpQkFBWSxHQUFHLElBQUksQ0FBQztRQUNwQixpQkFBWSxHQUFHLElBQUksQ0FBQztRQUNwQixnQkFBVyxHQUFhLEVBQUUsQ0FBQztRQUl6QixJQUFJLENBQUMsV0FBVyxHQUFHLFlBQVksQ0FBQyxlQUFlLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzlELE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUM7UUFDL0IsTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQztRQUMxQixNQUFNLEtBQUssR0FBRyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN0QyxNQUFNLE1BQU0sR0FBRyxXQUFXLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzNDLE1BQU0sUUFBUSxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQy9ELElBQUksQ0FBQyxhQUFhLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxD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Q0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7Y0FDckMsTUFBTSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztnQ0FDbkIsTUFBTTs7OztLQUlqQyxDQUFDO0lBQ0osQ0FBQztDQUNGO0FBRUQ7Ozs7Ozs7Ozs7R0FVRztBQUNILFNBQVMsZUFBZSxDQUFDLFFBQWtCLEVBQUUsT0FBZSxFQUFFLEtBQWE7SUFDekUsTUFBTSxVQUFVLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUM3QyxNQUFNLEdBQUcsR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxFQUFFO1FBQ2xDLElBQUksR0FBRyxLQUFLLFVBQVUsRUFBRTtZQUN0QixPQUFPLEdBQUcsQ0FBQyxNQUFNLEtBQUssRUFBRSxDQUFDO1NBQzFCO2FBQU07WUFDTCxPQUFPLENBQUMsQ0FBQztTQUNWO0lBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDSCxPQUFPLEdBQUcsQ0FBQyxJQUFJLEVBQUUsQ0FBQztBQUNwQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge2JhY2tlbmRfdXRpbH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuaW1wb3J0IHtHUEdQVVByb2dyYW19IGZyb20gJy4vZ3BncHVfbWF0aCc7XG5pbXBvcnQge2dldENoYW5uZWxzfSBmcm9tICcuL3BhY2tpbmdfdXRpbCc7XG5pbXBvcnQge2dldENvb3Jkc0RhdGFUeXBlfSBmcm9tICcuL3NoYWRlcl9jb21waWxlcic7XG5cbmV4cG9ydCBjbGFzcyBDb25jYXRQYWNrZWRQcm9ncmFtIGltcGxlbWVudHMgR1BHUFVQcm9ncmFtIHtcbiAgdmFyaWFibGVOYW1lczogc3RyaW5nW107XG4gIHBhY2tlZElucHV0cyA9IHRydWU7XG4gIHBhY2tlZE91dHB1dCA9IHRydWU7XG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXSA9IFtdO1xuICB1c2VyQ29kZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHNoYXBlczogbnVtYmVyW11bXSwgYXhpczogbnVtYmVyKSB7XG4gICAgdGhpcy5vdXRwdXRTaGFwZSA9IGJhY2tlbmRfdXRpbC5jb21wdXRlT3V0U2hhcGUoc2hhcGVzLCBheGlzKTtcbiAgICBjb25zdCBzaGFwZSA9IHRoaXMub3V0cHV0U2hhcGU7XG4gICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBkdHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKHJhbmspO1xuICAgIGNvbnN0IGNvb3JkcyA9IGdldENoYW5uZWxzKCdjb29yZHMnLCByYW5rKTtcbiAgICBjb25zdCBjaGFubmVscyA9IFsneCcsICd5JywgJ3onLCAndycsICd1JywgJ3YnXS5zbGljZSgwLCByYW5rKTtcbiAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBzaGFwZXMubWFwKChfLCBpKSA9PiBgVCR7aX1gKTtcblxuICAgIGNvbnN0IG9mZnNldHM6IG51bWJlcltdID0gbmV3IEFycmF5KHNoYXBlcy5sZW5ndGggLSAxKTtcbiAgICBvZmZzZXRzWzBdID0gc2hhcGVzWzBdW2F4aXNdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgb2Zmc2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2Zmc2V0c1tpXSA9IG9mZnNldHNbaSAtIDFdICsgc2hhcGVzW2ldW2F4aXNdO1xuICAgIH1cblxuICAgIGNvbnN0IGNoYW5uZWwgPSBjaGFubmVsc1theGlzXTtcbiAgICBjb25zdCBsYXN0Q2hhbm5lbHMgPSBjaGFubmVscy5zbGljZSgtMik7XG4gICAgY29uc3QgYWxsQ2hhbm5lbHMgPSBjaGFubmVscy5qb2luKCk7XG5cbiAgICBsZXQgZ2V0VmFsdWVTbmlwcGV0ID0gYGlmICgke2NoYW5uZWx9IDwgJHtvZmZzZXRzWzBdfSkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChcbiAgICAgICAgICAgIGdldFQwKCR7YWxsQ2hhbm5lbHN9KSwgdmVjMigke2xhc3RDaGFubmVscy5qb2luKCl9KSk7XG4gICAgICAgIH1gO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgb2Zmc2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc2hpZnQgPSBvZmZzZXRzW2kgLSAxXTtcbiAgICAgIC8vIE5vdGU6IHRoZSA+PSBjb21wYXJpc29uIGJlbG93IG1heSBzZWVtIHVubmVjZXNzYXJ5IGdpdmVuIHRoZSBjaGVja1xuICAgICAgLy8gYWJvdmUgYnV0IGlzIG5lZWRlZCB0byB3b3JrYXJvdW5kIGJyYW5jaCBleGVjdXRpb24gaXNzdWVzIG9uIHNvbWVcbiAgICAgIC8vIGRldmljZXMuIEl0IG1ha2VzIGFsbCB0aGUgY29uZGl0aW9ucyBleGNsdXNpdmUgd2l0aG91dCByZWx5aW5nIG9uXG4gICAgICAvLyBleGVjdXRpb24gb3JkZXIuXG4gICAgICBnZXRWYWx1ZVNuaXBwZXQgKz0gYFxuICAgICAgICBpZiAoJHtjaGFubmVsfSA8ICR7b2Zmc2V0c1tpXX0gICYmICR7Y2hhbm5lbH0gPj0gJHtvZmZzZXRzW2kgLSAxXX0pIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChcbiAgICAgICAgICAgIGdldFQke2l9KCR7c2hpZnRlZENoYW5uZWxzKGNoYW5uZWxzLCBjaGFubmVsLCBzaGlmdCl9KSxcbiAgICAgICAgICAgIHZlYzIoJHtzaGlmdGVkQ2hhbm5lbHMobGFzdENoYW5uZWxzLCBjaGFubmVsLCBzaGlmdCl9KSk7XG4gICAgICAgIH1gO1xuICAgIH1cbiAgICBjb25zdCBsYXN0SW5kZXggPSBvZmZzZXRzLmxlbmd0aDtcbiAgICBjb25zdCBzaGlmdCA9IG9mZnNldHNbb2Zmc2V0cy5sZW5ndGggLSAxXTtcbiAgICBnZXRWYWx1ZVNuaXBwZXQgKz0gYFxuICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChcbiAgICAgICAgICBnZXRUJHtsYXN0SW5kZXh9KCR7c2hpZnRlZENoYW5uZWxzKGNoYW5uZWxzLCBjaGFubmVsLCBzaGlmdCl9KSxcbiAgICAgICAgICB2ZWMyKCR7c2hpZnRlZENoYW5uZWxzKGxhc3RDaGFubmVscywgY2hhbm5lbCwgc2hpZnQpfSkpO2A7XG5cbiAgICB0aGlzLnVzZXJDb2RlID0gYFxuICAgICAgZmxvYXQgZ2V0VmFsdWUoJHtjaGFubmVscy5tYXAoeCA9PiAnaW50ICcgKyB4KX0pIHtcbiAgICAgICAgJHtnZXRWYWx1ZVNuaXBwZXR9XG4gICAgICB9XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgJHtkdHlwZX0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNChnZXRWYWx1ZSgke2Nvb3Jkc30pLCAwLiwgMC4sIDAuKTtcblxuICAgICAgICAke2Nvb3Jkc1tyYW5rIC0gMV19ID0gJHtjb29yZHNbcmFuayAtIDFdfSArIDE7XG4gICAgICAgIGlmICgke2Nvb3Jkc1tyYW5rIC0gMV19IDwgJHtzaGFwZVtyYW5rIC0gMV19KSB7XG4gICAgICAgICAgcmVzdWx0LmcgPSBnZXRWYWx1ZSgke2Nvb3Jkc30pO1xuICAgICAgICB9XG5cbiAgICAgICAgJHtjb29yZHNbcmFuayAtIDJdfSA9ICR7Y29vcmRzW3JhbmsgLSAyXX0gKyAxO1xuICAgICAgICBpZiAoJHtjb29yZHNbcmFuayAtIDJdfSA8ICR7c2hhcGVbcmFuayAtIDJdfSkge1xuICAgICAgICAgIHJlc3VsdC5hID0gZ2V0VmFsdWUoJHtjb29yZHN9KTtcbiAgICAgICAgfVxuXG4gICAgICAgICR7Y29vcmRzW3JhbmsgLSAxXX0gPSAke2Nvb3Jkc1tyYW5rIC0gMV19IC0gMTtcbiAgICAgICAgaWYgKCR7Y29vcmRzW3JhbmsgLSAyXX0gPCAke3NoYXBlW3JhbmsgLSAyXX0gJiZcbiAgICAgICAgICAgICR7Y29vcmRzW3JhbmsgLSAxXX0gPCAke3NoYXBlW3JhbmsgLSAxXX0pIHtcbiAgICAgICAgICByZXN1bHQuYiA9IGdldFZhbHVlKCR7Y29vcmRzfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XG4gICAgICB9XG4gICAgYDtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiBhbiBleHByZXNzaW9uIGZvciBjb29yZGluYXRlcyBpbnRvIGEgdmVjdG9yIHdoZXJlIGEgZ2l2ZW4gY2hhbm5lbFxuICogd2lsbCBiZSBvZmZzZXQgYnkgW3NoaWZ0XS5cbiAqXG4gKiBAcGFyYW0gY2hhbm5lbHMgdGhlIGNoYW5uZWxzIHRvIGNvbnNpZGVyXG4gKiBAcGFyYW0gY2hhbm5lbCB0aGUgY2hhbm5lbCB3ZSB3YW50IHNoaWZ0ZWRcbiAqIEBwYXJhbSBzaGlmdCAgdGhlIGFtb3VudCB0byBzdWJ0cmFjdCBmcm9tIHRoZSBjaGFubmVsLlxuICpcbiAqIEByZXR1cm5zIGEgc3RyaW5nIG9mIHRoZSBmb3JtICd4LCB5LVtzaGlmdF0sIHonIHdoZXJlIGFueSBvbmUgY2hhbm5lbCBjYW5cbiAqIGhhdmUgdGhlIHNoaWZ0IGFwcGxpZWQuXG4gKi9cbmZ1bmN0aW9uIHNoaWZ0ZWRDaGFubmVscyhjaGFubmVsczogc3RyaW5nW10sIGNoYW5uZWw6IHN0cmluZywgc2hpZnQ6IG51bWJlcikge1xuICBjb25zdCBjaGFubmVsSWR4ID0gY2hhbm5lbHMuaW5kZXhPZihjaGFubmVsKTtcbiAgY29uc3QgcmVzID0gY2hhbm5lbHMubWFwKChjLCBpZHgpID0+IHtcbiAgICBpZiAoaWR4ID09PSBjaGFubmVsSWR4KSB7XG4gICAgICByZXR1cm4gYCR7Y30gLSAke3NoaWZ0fWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXMuam9pbigpO1xufVxuIl19","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class Conv2DDerFilterProgram {\n    constructor(convInfo) {\n        this.variableNames = ['x', 'dy'];\n        this.outputShape = convInfo.filterShape;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n        this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${convInfo.batchSize}; b++) {\n          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {\n            int xR = wR + yR * ${strideHeight} - ${padTop};\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {\n              int xC = wC + yC * ${strideWidth} - ${padLeft};\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              ${isChannelsLast ?\n            `float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);` :\n            `float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);`}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\nexport class Conv2DDerInputProgram {\n    constructor(convInfo) {\n        this.variableNames = ['dy', 'W'];\n        this.outputShape = convInfo.inShape;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n        const padTop = filterHeight - 1 - convInfo.padInfo.top;\n        const padLeft = filterWidth - 1 - convInfo.padInfo.left;\n        const rowDim = isChannelsLast ? 1 : 2;\n        const colDim = isChannelsLast ? 2 : 3;\n        const channelDim = isChannelsLast ? 3 : 1;\n        this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${channelDim}];\n\n        ivec2 dyCorner = ivec2(coords[${rowDim}], coords[${colDim}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${filterHeight} - 1 - wR;\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${filterWidth} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {\n\n              if (${isChannelsLast}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\nexport class Conv3DDerFilterProgram {\n    constructor(convInfo) {\n        this.variableNames = ['x', 'dy'];\n        this.outputShape = convInfo.filterShape;\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const padFront = convInfo.padInfo.front;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        this.userCode = `\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${convInfo.batchSize}; b++) {\n          for (int yF = 0; yF < ${convInfo.outDepth}; yF++) {\n            int xF = wF + yF * ${strideDepth} - ${padFront};\n\n            if (xF < 0 || xF >= ${convInfo.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {\n              int xR = wR + yR * ${strideHeight} - ${padTop};\n\n              if (xR < 0 || xR >= ${convInfo.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {\n                int xC = wC + yC * ${strideWidth} - ${padLeft};\n\n                if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\nexport class Conv3DDerInputProgram {\n    constructor(convInfo) {\n        this.variableNames = ['dy', 'W'];\n        this.outputShape = convInfo.inShape;\n        const filterDepth = convInfo.filterDepth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const padFront = filterDepth - 1 - convInfo.padInfo.front;\n        const padTop = filterHeight - 1 - convInfo.padInfo.top;\n        const padLeft = filterWidth - 1 - convInfo.padInfo.left;\n        this.userCode = `\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${filterDepth}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${convInfo.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${filterDepth} - 1 - wF;\n\n          for (int wR = 0; wR < ${filterHeight}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${filterHeight} - 1 - wR;\n\n            for (int wC = 0; wC < ${filterWidth}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${filterWidth} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udl9iYWNrcHJvcF9ncHUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtd2ViZ2wvc3JjL2NvbnZfYmFja3Byb3BfZ3B1LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUtILE1BQU0sT0FBTyxzQkFBc0I7SUFLakMsWUFBWSxRQUFpQztRQUo3QyxrQkFBYSxHQUFHLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBSzFCLElBQUksQ0FBQyxXQUFXLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQztRQUV4QyxNQUFNLFlBQVksR0FBRyxRQUFRLENBQUMsWUFBWSxDQUFDO1FBQzNDLE1BQU0sV0FBVyxHQUFHLFFBQVEsQ0FBQyxXQUFXLENBQUM7UUFDekMsTUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUM7UUFDcEMsTUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUM7UUFDdEMsTUFBTSxjQUFjLEdBQUcsUUFBUSxDQUFDLFVBQVUsS0FBSyxjQUFjLENBQUM7UUFFOUQsSUFBSSxDQUFDLFFBQVEsR0FBRzs7Ozs7Ozs7Ozs7OzhCQVlVLFFBQVEsQ0FBQyxTQUFTO2tDQUNkLFFBQVEsQ0FBQyxTQUFTO2lDQUNuQixZQUFZLE1BQU0sTUFBTTs7a0NBRXZCLFFBQVEsQ0FBQyxRQUFROzs7O29DQUlmLFFBQVEsQ0FBQyxRQUFRO21DQUNsQixXQUFXLE1BQU0sT0FBTzs7b0NBRXZCLFFBQVEsQ0FBQyxPQUFPOzs7O2dCQUlwQyxjQUFjLENBQUEsQ0FBQztZQUNsQjs7NkNBRWdDLENBQUMsQ0FBQztZQUNsQzs7NkNBRWdDOzs7Ozs7S0FNeEMsQ0FBQztJQUNKLENBQUM7Q0FDRjtBQUVELE1BQU0sT0FBTyxxQkFBcUI7SUFLaEMsWUFBWSxRQUFpQztRQUo3QyxrQkFBYSxHQUFHLENBQUMsSUFBSSxF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LENBQUM7UUFDekMsTUFBTSxZQUFZLEdBQUcsUUFBUSxDQUFDLFlBQVksQ0FBQztRQUMzQyxNQUFNLFdBQVcsR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDO1FBQ3pDLE1BQU0sV0FBVyxHQUFHLFFBQVEsQ0FBQyxXQUFXLENBQUM7UUFDekMsTUFBTSxZQUFZLEdBQUcsUUFBUSxDQUFDLFlBQVksQ0FBQztRQUMzQyxNQUFNLFdBQVcsR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDO1FBRXpDLE1BQU0sUUFBUSxHQUFHLFdBQVcsR0FBRyxDQUFDLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUM7UUFDMUQsTUFBTSxNQUFNLEdBQUcsWUFBWSxHQUFHLENBQUMsR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQztRQUN2RCxNQUFNLE9BQU8sR0FBRyxXQUFXLEdBQUcsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO1FBRXhELElBQUksQ0FBQyxRQUFRLEdBQUc7aUNBQ2EsUUFBUSxLQUFLLE1BQU0sS0FBSyxPQUFPOzs7Ozs7Ozs7Ozs7OztnQ0FjaEMsV0FBVztnREFDSyxXQUFXOztvQ0FFdkIsUUFBUSxDQUFDLFFBQVE7Ozs7O3lCQUs1QixXQUFXOztrQ0FFRixZQUFZO2tEQUNJLFlBQVk7O3NDQUV4QixRQUFRLENBQUMsU0FBUzs7Ozs7OzJCQU03QixZQUFZOztvQ0FFSCxXQUFXO29EQUNLLFdBQVc7O3dDQUV2QixRQUFRLENBQUMsUUFBUTs7Ozs7OzZCQU01QixXQUFXOztzQ0FFRixRQUFRLENBQUMsV0FBVzs7Ozs7Ozs7OztLQVVyRCxDQUFDO0lBQ0osQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge2JhY2tlbmRfdXRpbH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcbmltcG9ydCB7R1BHUFVQcm9ncmFtfSBmcm9tICcuL2dwZ3B1X21hdGgnO1xuXG5leHBvcnQgY2xhc3MgQ29udjJERGVyRmlsdGVyUHJvZ3JhbSBpbXBsZW1lbnRzIEdQR1BVUHJvZ3JhbSB7XG4gIHZhcmlhYmxlTmFtZXMgPSBbJ3gnLCAnZHknXTtcbiAgb3V0cHV0U2hhcGU6IG51bWJlcltdO1xuICB1c2VyQ29kZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGNvbnZJbmZvOiBiYWNrZW5kX3V0aWwuQ29udjJESW5mbykge1xuICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5maWx0ZXJTaGFwZTtcblxuICAgIGNvbnN0IHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICBjb25zdCBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgIGNvbnN0IHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgIGNvbnN0IHBhZExlZnQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgY29uc3QgaXNDaGFubmVsc0xhc3QgPSBjb252SW5mby5kYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNMYXN0JztcblxuICAgIHRoaXMudXNlckNvZGUgPSBgXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgd1IgPSBjb29yZHMueDtcbiAgICAgICAgaW50IHdDID0gY29vcmRzLnk7XG4gICAgICAgIGludCBkMSA9IGNvb3Jkcy56O1xuICAgICAgICBpbnQgZDIgPSBjb29yZHMudztcblxuICAgICAgICAvLyBDb252b2x2ZSB4KD8sID8sIGQxKSB3aXRoIGR5KDosIDosIGQyKSB0byBnZXQgZHcod1IsIHdDLCBkMSwgZDIpLlxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcblxuICAgICAgICBmb3IgKGludCBiID0gMDsgYiA8ICR7Y29udkluZm8uYmF0Y2hTaXplfTsgYisrKSB7XG4gICAgICAgICAgZm9yIChpbnQgeVIgPSAwOyB5UiA8ICR7Y29udkluZm8ub3V0SGVpZ2h0fTsgeVIrKykge1xuICAgICAgICAgICAgaW50IHhSID0gd1IgKyB5UiAqICR7c3RyaWRlSGVpZ2h0fSAtICR7cGFkVG9wfTtcblxuICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSAke2NvbnZJbmZvLmluSGVpZ2h0fSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpbnQgeUMgPSAwOyB5QyA8ICR7Y29udkluZm8ub3V0V2lkdGh9OyB5QysrKSB7XG4gICAgICAgICAgICAgIGludCB4QyA9IHdDICsgeUMgKiAke3N0cmlkZVdpZHRofSAtICR7cGFkTGVmdH07XG5cbiAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSAke2NvbnZJbmZvLmluV2lkdGh9KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAke2lzQ2hhbm5lbHNMYXN0P1xuICAgICAgICAgICAgIGBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgeVIsIHlDLCBkMik7XG4gICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldFgoYiwgeFIsIHhDLCBkMSk7XG4gICAgICAgICAgICAgIGRvdFByb2QgKz0gKHhWYWx1ZSAqIGR5VmFsdWUpO2AgOlxuICAgICAgICAgICAgIGBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgZDIsIHlSLCB5Qyk7XG4gICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldFgoYiwgZDEsIHhSLCB4Qyk7XG4gICAgICAgICAgICAgIGRvdFByb2QgKz0gKHhWYWx1ZSAqIGR5VmFsdWUpO2B9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDb252MkREZXJJbnB1dFByb2dyYW0gaW1wbGVtZW50cyBHUEdQVVByb2dyYW0ge1xuICB2YXJpYWJsZU5hbWVzID0gWydkeScsICdXJ107XG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXTtcbiAgdXNlckNvZGU6IHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcihjb252SW5mbzogYmFja2VuZF91dGlsLkNvbnYyREluZm8pIHtcbiAgICB0aGlzLm91dHB1dFNoYXBlID0gY29udkluZm8uaW5TaGFwZTtcblxuICAgIGNvbnN0IGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICBjb25zdCBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgIGNvbnN0IHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICBjb25zdCBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgIGNvbnN0IGlzQ2hhbm5lbHNMYXN0ID0gY29udkluZm8uZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzTGFzdCc7XG5cbiAgICBjb25zdCBwYWRUb3AgPSBmaWx0ZXJIZWlnaHQgLSAxIC0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgY29uc3QgcGFkTGVmdCA9IGZpbHRlcldpZHRoIC0gMSAtIGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcblxuICAgIGNvbnN0IHJvd0RpbSA9IGlzQ2hhbm5lbHNMYXN0ID8gMSA6IDI7XG4gICAgY29uc3QgY29sRGltID0gaXNDaGFubmVsc0xhc3QgPyAyIDogMztcbiAgICBjb25zdCBjaGFubmVsRGltID0gaXNDaGFubmVsc0xhc3QgPyAzIDogMTtcblxuICAgIHRoaXMudXNlckNvZGUgPSBgXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoJHtwYWRUb3B9LCAke3BhZExlZnR9KTtcblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xuICAgICAgICBpbnQgZDEgPSBjb29yZHNbJHtjaGFubmVsRGltfV07XG5cbiAgICAgICAgaXZlYzIgZHlDb3JuZXIgPSBpdmVjMihjb29yZHNbJHtyb3dEaW19XSwgY29vcmRzWyR7Y29sRGltfV0pIC0gcGFkcztcbiAgICAgICAgaW50IGR5UkNvcm5lciA9IGR5Q29ybmVyLng7XG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeUNvcm5lci55O1xuXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQyKSB3aXRoIHcoOiwgOiwgZDEsIGQyKSB0byBjb21wdXRlIGR4KHhSLCB4QywgZDEpLlxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8ICR7ZmlsdGVySGVpZ2h0fTsgd1IrKykge1xuICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvICR7c3RyaWRlSGVpZ2h0fS4wO1xuXG4gICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gJHtjb252SW5mby5vdXRIZWlnaHR9LjAgfHwgZnJhY3QoZHlSKSA+IDAuMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XG5cbiAgICAgICAgICBpbnQgd1JQZXJtID0gJHtmaWx0ZXJIZWlnaHR9IC0gMSAtIHdSO1xuXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8ICR7ZmlsdGVyV2lkdGh9OyB3QysrKSB7XG4gICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyAke3N0cmlkZVdpZHRofS4wO1xuXG4gICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSAke2NvbnZJbmZvLm91dFdpZHRofS4wIHx8XG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XG5cbiAgICAgICAgICAgIGludCB3Q1Blcm0gPSAke2ZpbHRlcldpZHRofSAtIDEgLSB3QztcblxuICAgICAgICAgICAgZm9yIChpbnQgZDIgPSAwOyBkMiA8ICR7Y29udkluZm8ub3V0Q2hhbm5lbHN9OyBkMisrKSB7XG5cbiAgICAgICAgICAgICAgaWYgKCR7aXNDaGFubmVsc0xhc3R9KSB7XG4gICAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0RHkoYmF0Y2gsIGlkeVIsIGlkeUMsIGQyKTtcbiAgICAgICAgICAgICAgICBmbG9hdCB3VmFsdWUgPSBnZXRXKHdSUGVybSwgd0NQZXJtLCBkMSwgZDIpO1xuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0geFZhbHVlICogd1ZhbHVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldER5KGJhdGNoLCBkMiwgaWR5UiwgaWR5Qyk7XG4gICAgICAgICAgICAgICAgZmxvYXQgd1ZhbHVlID0gZ2V0Vyh3UlBlcm0sIHdDUGVybSwgZDEsIGQyKTtcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHhWYWx1ZSAqIHdWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDb252M0REZXJGaWx0ZXJQcm9ncmFtIGltcGxlbWVudHMgR1BHUFVQcm9ncmFtIHtcbiAgdmFyaWFibGVOYW1lcyA9IFsneCcsICdkeSddO1xuICBvdXRwdXRTaGFwZTogbnVtYmVyW107XG4gIHVzZXJDb2RlOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoY29udkluZm86IGJhY2tlbmRfdXRpbC5Db252M0RJbmZvKSB7XG4gICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLmZpbHRlclNoYXBlO1xuXG4gICAgY29uc3Qgc3RyaWRlRGVwdGggPSBjb252SW5mby5zdHJpZGVEZXB0aDtcbiAgICBjb25zdCBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgY29uc3Qgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICBjb25zdCBwYWRGcm9udCA9IGNvbnZJbmZvLnBhZEluZm8uZnJvbnQ7XG4gICAgY29uc3QgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgY29uc3QgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcblxuICAgIHRoaXMudXNlckNvZGUgPSBgXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM1IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgd0YgPSBjb29yZHMueDtcbiAgICAgICAgaW50IHdSID0gY29vcmRzLnk7XG4gICAgICAgIGludCB3QyA9IGNvb3Jkcy56O1xuICAgICAgICBpbnQgZDEgPSBjb29yZHMudztcbiAgICAgICAgaW50IGQyID0gY29vcmRzLnU7XG5cbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcblxuICAgICAgICBmb3IgKGludCBiID0gMDsgYiA8ICR7Y29udkluZm8uYmF0Y2hTaXplfTsgYisrKSB7XG4gICAgICAgICAgZm9yIChpbnQgeUYgPSAwOyB5RiA8ICR7Y29udkluZm8ub3V0RGVwdGh9OyB5RisrKSB7XG4gICAgICAgICAgICBpbnQgeEYgPSB3RiArIHlGICogJHtzdHJpZGVEZXB0aH0gLSAke3BhZEZyb250fTtcblxuICAgICAgICAgICAgaWYgKHhGIDwgMCB8fCB4RiA+PSAke2NvbnZJbmZvLmluRGVwdGh9KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGludCB5UiA9IDA7IHlSIDwgJHtjb252SW5mby5vdXRIZWlnaHR9OyB5UisrKSB7XG4gICAgICAgICAgICAgIGludCB4UiA9IHdSICsgeVIgKiAke3N0cmlkZUhlaWdodH0gLSAke3BhZFRvcH07XG5cbiAgICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSAke2NvbnZJbmZvLmluSGVpZ2h0fSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZm9yIChpbnQgeUMgPSAwOyB5QyA8ICR7Y29udkluZm8ub3V0V2lkdGh9OyB5QysrKSB7XG4gICAgICAgICAgICAgICAgaW50IHhDID0gd0MgKyB5QyAqICR7c3RyaWRlV2lkdGh9IC0gJHtwYWRMZWZ0fTtcblxuICAgICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gJHtjb252SW5mby5pbldpZHRofSkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGIsIHlGLCB5UiwgeUMsIGQyKTtcbiAgICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXRYKGIsIHhGLCB4UiwgeEMsIGQxKTtcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9ICh4VmFsdWUgKiBkeVZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XG4gICAgICB9XG4gICAgYDtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ29udjNERGVySW5wdXRQcm9ncmFtIGltcGxlbWVudHMgR1BHUFVQcm9ncmFtIHtcbiAgdmFyaWFibGVOYW1lcyA9IFsnZHknLCAnVyddO1xuICBvdXRwdXRTaGFwZTogbnVtYmVyW107XG4gIHVzZXJDb2RlOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoY29udkluZm86IGJhY2tlbmRfdXRpbC5Db252M0RJbmZvKSB7XG4gICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLmluU2hhcGU7XG5cbiAgICBjb25zdCBmaWx0ZXJEZXB0aCA9IGNvbnZJbmZvLmZpbHRlckRlcHRoO1xuICAgIGNvbnN0IGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICBjb25zdCBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgIGNvbnN0IHN0cmlkZURlcHRoID0gY29udkluZm8uc3RyaWRlRGVwdGg7XG4gICAgY29uc3Qgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgIGNvbnN0IHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG5cbiAgICBjb25zdCBwYWRGcm9udCA9IGZpbHRlckRlcHRoIC0gMSAtIGNvbnZJbmZvLnBhZEluZm8uZnJvbnQ7XG4gICAgY29uc3QgcGFkVG9wID0gZmlsdGVySGVpZ2h0IC0gMSAtIGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgIGNvbnN0IHBhZExlZnQgPSBmaWx0ZXJXaWR0aCAtIDEgLSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG5cbiAgICB0aGlzLnVzZXJDb2RlID0gYFxuICAgICAgY29uc3QgaXZlYzMgcGFkcyA9IGl2ZWMzKCR7cGFkRnJvbnR9LCAke3BhZFRvcH0sICR7cGFkTGVmdH0pO1xuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM1IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcbiAgICAgICAgaW50IGQxID0gY29vcmRzLnU7XG5cblxuICAgICAgICBpdmVjMyBkeUNvcm5lciA9IGl2ZWMzKGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLncpIC0gcGFkcztcbiAgICAgICAgaW50IGR5RkNvcm5lciA9IGR5Q29ybmVyLng7XG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeUNvcm5lci55O1xuICAgICAgICBpbnQgZHlDQ29ybmVyID0gZHlDb3JuZXIuejtcblxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xuICAgICAgICBmb3IgKGludCB3RiA9IDA7IHdGIDwgJHtmaWx0ZXJEZXB0aH07IHdGKyspIHtcbiAgICAgICAgICBmbG9hdCBkeUYgPSBmbG9hdChkeUZDb3JuZXIgKyB3RikgLyAke3N0cmlkZURlcHRofS4wO1xuXG4gICAgICAgICAgaWYgKGR5RiA8IDAuMCB8fCBkeUYgPj0gJHtjb252SW5mby5vdXREZXB0aH0uMCB8fCBmcmFjdChkeUYpID4gMC4wKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW50IGlkeUYgPSBpbnQoZHlGKTtcblxuICAgICAgICAgIGludCB3RlBlcm0gPSAke2ZpbHRlckRlcHRofSAtIDEgLSB3RjtcblxuICAgICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCAke2ZpbHRlckhlaWdodH07IHdSKyspIHtcbiAgICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvICR7c3RyaWRlSGVpZ2h0fS4wO1xuXG4gICAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSAke2NvbnZJbmZvLm91dEhlaWdodH0uMCB8fFxuICAgICAgICAgICAgICBmcmFjdChkeVIpID4gMC4wKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcblxuICAgICAgICAgICAgaW50IHdSUGVybSA9ICR7ZmlsdGVySGVpZ2h0fSAtIDEgLSB3UjtcblxuICAgICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8ICR7ZmlsdGVyV2lkdGh9OyB3QysrKSB7XG4gICAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvICR7c3RyaWRlV2lkdGh9LjA7XG5cbiAgICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gJHtjb252SW5mby5vdXRXaWR0aH0uMCB8fFxuICAgICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XG5cbiAgICAgICAgICAgICAgaW50IHdDUGVybSA9ICR7ZmlsdGVyV2lkdGh9IC0gMSAtIHdDO1xuXG4gICAgICAgICAgICAgIGZvciAoaW50IGQyID0gMDsgZDIgPCAke2NvbnZJbmZvLm91dENoYW5uZWxzfTsgZDIrKykge1xuICAgICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldER5KGJhdGNoLCBpZHlGLCBpZHlSLCBpZHlDLCBkMik7XG4gICAgICAgICAgICAgICAgZmxvYXQgd1ZhbHVlID0gZ2V0Vyh3RlBlcm0sIHdSUGVybSwgd0NQZXJtLCBkMSwgZDIpO1xuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0geFZhbHVlICogd1ZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG59XG4iXX0=","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class DepthwiseConv2DDerFilterProgram {\n    constructor(convInfo) {\n        this.variableNames = ['x', 'dy'];\n        this.outputShape = convInfo.filterShape;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const channelMul = convInfo.outChannels / convInfo.inChannels;\n        this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${channelMul} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${convInfo.batchSize}; b++) {\n          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {\n            int xR = wR + yR * ${strideHeight} - ${padTop};\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {\n              int xC = wC + yC * ${strideWidth} - ${padLeft};\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\nexport class DepthwiseConv2DDerInputProgram {\n    constructor(convInfo) {\n        this.variableNames = ['dy', 'W'];\n        this.outputShape = convInfo.inShape;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const padTop = filterHeight - 1 - convInfo.padInfo.top;\n        const padLeft = filterWidth - 1 - convInfo.padInfo.left;\n        const channelMul = convInfo.outChannels / convInfo.inChannels;\n        this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${filterHeight} - 1 - wR;\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${filterWidth} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${channelMul}; dm++) {\n              int d2 = d1 * ${channelMul} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udl9iYWNrcHJvcF9ncHVfZGVwdGh3aXNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vdGZqcy1iYWNrZW5kLXdlYmdsL3NyYy9jb252X2JhY2twcm9wX2dwdV9kZXB0aHdpc2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBS0gsTUFBTSxPQUFPLCtCQUErQjtJQUsxQyxZQUFZLFFBQWlDO1FBSjdDLGtCQUFhLEdBQUcsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFLMUIsSUFBSSxDQUFDLFdBQVcsR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDO1FBRXhDLE1BQU0sWUFBWSxHQUFHLFFBQVEsQ0FBQyxZQUFZLENBQUM7UUFDM0MsTUFBTSxXQUFXLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQztRQUN6QyxNQUFNLE1BQU0sR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQztRQUNwQyxNQUFNLE9BQU8sR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQztRQUN0QyxNQUFNLFVBQVUsR0FBRyxRQUFRLENBQUMsV0FBVyxHQUFHLFFBQVEsQ0FBQyxVQUFVLENBQUM7UUFFOUQsSUFBSSxDQUFDLFFBQVEsR0FBRzs7Ozs7Ozt3QkFPSSxVQUFVOzs7Ozs4QkFLSixRQUFRLENBQUMsU0FBUztrQ0FDZCxRQUFRLENBQUMsU0FBUztpQ0FDbkIsWUFBWSxNQUFNLE1BQU07O2tDQUV2QixRQUFRLENBQUMsUUFBUTs7OztvQ0FJZixRQUFRLENBQUMsUUFBUTttQ0FDbEIsV0FBVyxNQUFNLE9BQU87O29DQUV2QixRQUFRLENBQUMsT0FBTzs7Ozs7Ozs7Ozs7O0tBWS9DLENBQUM7SUFDSixDQUFDO0NBQ0Y7QUFFRCxNQUFNLE9BQU8sOEJBQThCO0lBS3pDLFlBQVksUUFBaUM7UUFKN0Msa0JBQWEsR0FBRyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQztRQUsxQixJQUFJLENBQUMsV0FBVyxHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUM7UUFFcEMsTUFBTSxZQUFZLEdBQUcsUUFBUSxDQUFDLFlBQVksQ0FBQztRQUMzQyxNQUFNLFdBQVcsR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDO1FBQ3pDLE1BQU0sWUFBWSxHQUFHLFFBQVEsQ0FBQyxZQUFZLENBQUM7UUFDM0MsTUFBTSxXQUFXLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQztRQUV6QyxNQUFNLE1BQU0sR0FBRyxZQUFZLEdBQUcsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDO1FBQ3ZELE1BQU0sT0FBTyxHQUFHLFdBQVcsR0FBRyxDQUFDLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUM7UUFDeEQsTUFBTSxVQUFVLEdBQUcsUUFBUSxDQUFDLFdBQVcsR0FBRyxRQUFRLENBQUMsVUFBVSxDQUFDO1FBRTlELElBQUksQ0FBQyxRQUFRLEdBQUc7aUNBQ2EsTUFBTSxLQUFLLE9BQU87Ozs7Ozs7Ozs7OztnQ0FZbkIsWUFBWTtnREFDSSxZQUFZOztvQ0FFeEIsUUFBUSxDQUFDLFNBQVM7Ozs7O3lCQUs3QixZQUFZOztrQ0FFSCxXQUFXO2tEQUNLLFdBQVc7O3NDQUV2QixRQUFRLENBQUMsUUFBUTs7Ozs7OzJCQU01QixXQUFXOzs7b0NBR0YsVUFBVTs4QkFDaEIsVUFBVTs7Ozs7Ozs7O0tBU25DLENBQUM7SUFDSixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7YmFja2VuZF91dGlsfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuaW1wb3J0IHtHUEdQVVByb2dyYW19IGZyb20gJy4vZ3BncHVfbWF0aCc7XG5cbmV4cG9ydCBjbGFzcyBEZXB0aHdpc2VDb252MkREZXJGaWx0ZXJQcm9ncmFtIGltcGxlbWVudHMgR1BHUFVQcm9ncmFtIHtcbiAgdmFyaWFibGVOYW1lcyA9IFsneCcsICdkeSddO1xuICBvdXRwdXRTaGFwZTogbnVtYmVyW107XG4gIHVzZXJDb2RlOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoY29udkluZm86IGJhY2tlbmRfdXRpbC5Db252MkRJbmZvKSB7XG4gICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLmZpbHRlclNoYXBlO1xuXG4gICAgY29uc3Qgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgIGNvbnN0IHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgY29uc3QgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgY29uc3QgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICBjb25zdCBjaGFubmVsTXVsID0gY29udkluZm8ub3V0Q2hhbm5lbHMgLyBjb252SW5mby5pbkNoYW5uZWxzO1xuXG4gICAgdGhpcy51c2VyQ29kZSA9IGBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCB3UiA9IGNvb3Jkcy54O1xuICAgICAgICBpbnQgd0MgPSBjb29yZHMueTtcbiAgICAgICAgaW50IGQxID0gY29vcmRzLno7XG4gICAgICAgIGludCBkbSA9IGNvb3Jkcy53O1xuICAgICAgICBpbnQgZDIgPSBkMSAqICR7Y2hhbm5lbE11bH0gKyBkbTtcblxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xuXG4gICAgICAgIC8vIFRPIERPOiBWZWM0IG92ZXIgdGhlIGJhdGNoIHNpemVcbiAgICAgICAgZm9yIChpbnQgYiA9IDA7IGIgPCAke2NvbnZJbmZvLmJhdGNoU2l6ZX07IGIrKykge1xuICAgICAgICAgIGZvciAoaW50IHlSID0gMDsgeVIgPCAke2NvbnZJbmZvLm91dEhlaWdodH07IHlSKyspIHtcbiAgICAgICAgICAgIGludCB4UiA9IHdSICsgeVIgKiAke3N0cmlkZUhlaWdodH0gLSAke3BhZFRvcH07XG5cbiAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gJHtjb252SW5mby5pbkhlaWdodH0pIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaW50IHlDID0gMDsgeUMgPCAke2NvbnZJbmZvLm91dFdpZHRofTsgeUMrKykge1xuICAgICAgICAgICAgICBpbnQgeEMgPSB3QyArIHlDICogJHtzdHJpZGVXaWR0aH0gLSAke3BhZExlZnR9O1xuXG4gICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gJHtjb252SW5mby5pbldpZHRofSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGIsIHlSLCB5QywgZDIpO1xuICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXRYKGIsIHhSLCB4QywgZDEpO1xuICAgICAgICAgICAgICBkb3RQcm9kICs9ICh4VmFsdWUgKiBkeVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xuICAgICAgfVxuICAgIGA7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIERlcHRod2lzZUNvbnYyRERlcklucHV0UHJvZ3JhbSBpbXBsZW1lbnRzIEdQR1BVUHJvZ3JhbSB7XG4gIHZhcmlhYmxlTmFtZXMgPSBbJ2R5JywgJ1cnXTtcbiAgb3V0cHV0U2hhcGU6IG51bWJlcltdO1xuICB1c2VyQ29kZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGNvbnZJbmZvOiBiYWNrZW5kX3V0aWwuQ29udjJESW5mbykge1xuICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5pblNoYXBlO1xuXG4gICAgY29uc3QgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgIGNvbnN0IGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgY29uc3Qgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgIGNvbnN0IHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG5cbiAgICBjb25zdCBwYWRUb3AgPSBmaWx0ZXJIZWlnaHQgLSAxIC0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgY29uc3QgcGFkTGVmdCA9IGZpbHRlcldpZHRoIC0gMSAtIGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICBjb25zdCBjaGFubmVsTXVsID0gY29udkluZm8ub3V0Q2hhbm5lbHMgLyBjb252SW5mby5pbkNoYW5uZWxzO1xuXG4gICAgdGhpcy51c2VyQ29kZSA9IGBcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke3BhZFRvcH0sICR7cGFkTGVmdH0pO1xuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XG4gICAgICAgIGludCBkMSA9IGNvb3Jkc1szXTtcbiAgICAgICAgaXZlYzIgZHlDb3JuZXIgPSBjb29yZHMueXogLSBwYWRzO1xuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlDb3JuZXIueDtcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLnk7XG5cbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcblxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgJHtmaWx0ZXJIZWlnaHR9OyB3UisrKSB7XG4gICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gJHtzdHJpZGVIZWlnaHR9LjA7XG5cbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSAke2NvbnZJbmZvLm91dEhlaWdodH0uMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcblxuICAgICAgICAgIGludCB3UlBlcm0gPSAke2ZpbHRlckhlaWdodH0gLSAxIC0gd1I7XG5cbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgJHtmaWx0ZXJXaWR0aH07IHdDKyspIHtcbiAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvICR7c3RyaWRlV2lkdGh9LjA7XG5cbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49ICR7Y29udkluZm8ub3V0V2lkdGh9LjAgfHxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcblxuICAgICAgICAgICAgaW50IHdDUGVybSA9ICR7ZmlsdGVyV2lkdGh9IC0gMSAtIHdDO1xuXG4gICAgICAgICAgICAvLyBUTyBETzogVmVjNCBvdmVyIHRoZSBjaGFubmVsTXVsXG4gICAgICAgICAgICBmb3IgKGludCBkbSA9IDA7IGRtIDwgJHtjaGFubmVsTXVsfTsgZG0rKykge1xuICAgICAgICAgICAgICBpbnQgZDIgPSBkMSAqICR7Y2hhbm5lbE11bH0gKyBkbTtcbiAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0RHkoYmF0Y2gsIGlkeVIsIGlkeUMsIGQyKTtcbiAgICAgICAgICAgICAgZmxvYXQgd1ZhbHVlID0gZ2V0Vyh3UlBlcm0sIHdDUGVybSwgZDEsIGRtKTtcbiAgICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsdWUgKiB3VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG59XG4iXX0=","/**\n * @license\n * Copyright 2023 Google LLC.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { useShapeUniforms } from './gpgpu_math';\nexport class Conv2DDerInputPackedProgram {\n    constructor(convInfo) {\n        this.variableNames = ['dy', 'W'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.customUniforms = [\n            { name: 'strides', type: 'vec2' },\n        ];\n        this.outputShape = convInfo.inShape;\n        this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const padTop = filterHeight - 1 - convInfo.padInfo.top;\n        const padLeft = filterWidth - 1 - convInfo.padInfo.left;\n        this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${filterHeight} - 1 - wR;\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            int wCPerm = ${filterWidth} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${convInfo.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${convInfo.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udl9iYWNrcHJvcF9wYWNrZWRfZ3B1LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vdGZqcy1iYWNrZW5kLXdlYmdsL3NyYy9jb252X2JhY2twcm9wX3BhY2tlZF9ncHUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBR0gsT0FBTyxFQUFlLGdCQUFnQixFQUFDLE1BQU0sY0FBYyxDQUFDO0FBRTVELE1BQU0sT0FBTywyQkFBMkI7SUFXdEMsWUFBWSxRQUFpQztRQVY3QyxrQkFBYSxHQUFHLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQzVCLGlCQUFZLEdBQUcsSUFBSSxDQUFDO1FBQ3BCLGlCQUFZLEdBQUcsSUFBSSxDQUFDO1FBSXBCLG1CQUFjLEdBQUc7WUFDZixFQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLE1BQWUsRUFBRTtTQUMxQyxDQUFDO1FBR0EsSUFBSSxDQUFDLFdBQVcsR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDO1FBQ3BDLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRXJFLE1BQU0sWUFBWSxHQUFHLFFBQVEsQ0FBQyxZQUFZLENBQUM7UUFDM0MsTUFBTSxXQUFXLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQztRQUV6QyxNQUFNLE1BQU0sR0FBRyxZQUFZLEdBQUcsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDO1FBQ3ZELE1BQU0sT0FBTyxHQUFHLFdBQVcsR0FBRyxDQUFDLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUM7UUFFeEQsSUFBSSxDQUFDLFFBQVEsR0FBRztpQ0FDYSxNQUFNLEtBQUssT0FBTzs7Ozs7Ozs7Ozs7O2dDQVluQixZQUFZOztvQ0FFUixRQUFRLENBQUMsU0FBUzs7Ozt5QkFJN0IsWUFBWTs7a0NBRUgsV0FBVzsyQkFDbEIsV0FBVzs7O29EQUdjLFFBQVEsQ0FBQyxRQUFROzs7Ozt1REFLZCxRQUFRLENBQUMsUUFBUTs7Ozs7c0NBS2xDLFFBQVEsQ0FBQyxXQUFXOzs7Ozs7Ozs7Ozs7Ozs7OztzQ0FpQnBCLFFBQVEsQ0FBQyxXQUFXOzs7Ozs7Ozs7c0NBU3BCLFFBQVEsQ0FBQyxXQUFXOzs7Ozs7Ozs7Ozs7O0tBYXJELENBQUM7SUFDSixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7YmFja2VuZF91dGlsfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuaW1wb3J0IHtHUEdQVVByb2dyYW0sIHVzZVNoYXBlVW5pZm9ybXN9IGZyb20gJy4vZ3BncHVfbWF0aCc7XG5cbmV4cG9ydCBjbGFzcyBDb252MkREZXJJbnB1dFBhY2tlZFByb2dyYW0gaW1wbGVtZW50cyBHUEdQVVByb2dyYW0ge1xuICB2YXJpYWJsZU5hbWVzID0gWydkeScsICdXJ107XG4gIHBhY2tlZElucHV0cyA9IHRydWU7XG4gIHBhY2tlZE91dHB1dCA9IHRydWU7XG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXTtcbiAgdXNlckNvZGU6IHN0cmluZztcbiAgZW5hYmxlU2hhcGVVbmlmb3JtczogYm9vbGVhbjtcbiAgY3VzdG9tVW5pZm9ybXMgPSBbXG4gICAge25hbWU6ICdzdHJpZGVzJywgdHlwZTogJ3ZlYzInIGFzIGNvbnN0IH0sXG4gIF07XG5cbiAgY29uc3RydWN0b3IoY29udkluZm86IGJhY2tlbmRfdXRpbC5Db252MkRJbmZvKSB7XG4gICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLmluU2hhcGU7XG4gICAgdGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zID0gdXNlU2hhcGVVbmlmb3Jtcyh0aGlzLm91dHB1dFNoYXBlLmxlbmd0aCk7XG5cbiAgICBjb25zdCBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgY29uc3QgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcblxuICAgIGNvbnN0IHBhZFRvcCA9IGZpbHRlckhlaWdodCAtIDEgLSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICBjb25zdCBwYWRMZWZ0ID0gZmlsdGVyV2lkdGggLSAxIC0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuXG4gICAgdGhpcy51c2VyQ29kZSA9IGBcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke3BhZFRvcH0sICR7cGFkTGVmdH0pO1xuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XG4gICAgICAgIGludCBkMSA9IGNvb3Jkc1szXTtcblxuICAgICAgICBpdmVjMiBkeUNvcm5lciA9IGl2ZWMyKGNvb3Jkc1sxXSwgY29vcmRzWzJdKSAtIHBhZHM7XG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeUNvcm5lci54O1xuICAgICAgICBpbnQgZHlDQ29ybmVyID0gZHlDb3JuZXIueTtcblxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgJHtmaWx0ZXJIZWlnaHR9OyB3UisrKSB7XG4gICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gc3RyaWRlc1swXTtcbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSAke2NvbnZJbmZvLm91dEhlaWdodH0uMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcbiAgICAgICAgICBpbnQgd1JQZXJtID0gJHtmaWx0ZXJIZWlnaHR9IC0gMSAtIHdSO1xuXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8ICR7ZmlsdGVyV2lkdGh9OyB3QysrKSB7XG4gICAgICAgICAgICBpbnQgd0NQZXJtID0gJHtmaWx0ZXJXaWR0aH0gLSAxIC0gd0M7XG5cbiAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvIHN0cmlkZXNbMV07XG4gICAgICAgICAgICBib29sIGlkeUNWYWwgPSAoZHlDID49IDAuMCkgJiYgKGR5QyA8ICR7Y29udkluZm8ub3V0V2lkdGh9LjApXG4gICAgICAgICAgICAgICYmIChmcmFjdChkeUMpID09IDAuMCk7XG4gICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xuXG4gICAgICAgICAgICBmbG9hdCBkeUMyID0gZmxvYXQoZHlDQ29ybmVyICsgd0MgKyAxKSAvIHN0cmlkZXNbMV07XG4gICAgICAgICAgICBib29sIGlkeUNWYWwyID0gKGR5QzIgPj0gMC4wKSAmJiAoZHlDMiA8ICR7Y29udkluZm8ub3V0V2lkdGh9LjApXG4gICAgICAgICAgICAgICYmIChmcmFjdChkeUMyKSA9PSAwLjApO1xuICAgICAgICAgICAgaW50IGlkeUMyID0gaW50KGR5QzIpO1xuXG4gICAgICAgICAgICBpZiAoaWR5Q1ZhbCAmJiBpZHlDVmFsMikge1xuICAgICAgICAgICAgICBmb3IgKGludCBkMiA9IDA7IGQyIDwgJHtjb252SW5mby5vdXRDaGFubmVsc307IGQyICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2ZWM0IHdWYWx1ZSA9IGdldFcod1JQZXJtLCB3Q1Blcm0sIGQxLCBkMik7XG4gICAgICAgICAgICAgICAgdmVjNCBkeVNhbXBsZSA9IGdldER5KGJhdGNoLCBpZHlSLCBpZHlDLCBkMik7XG4gICAgICAgICAgICAgICAgdmVjNCBkeVNhbXBsZTIgPSAoaWR5QyAvIDIgPT0gaWR5QzIgLyAyKSA/XG4gICAgICAgICAgICAgICAgICBkeVNhbXBsZSA6IGdldER5KGJhdGNoLCBpZHlSLCBpZHlDMiwgZDIpO1xuXG4gICAgICAgICAgICAgICAgdmVjMiBkeVZhbHVlID0gbW9kKGZsb2F0KGlkeUMpLCAyLikgPT0gMC4gP1xuICAgICAgICAgICAgICAgICAgZHlTYW1wbGUueHkgOiBkeVNhbXBsZS56dztcbiAgICAgICAgICAgICAgICByZXN1bHQueHkgKz0gdmVjMihkb3QoZHlWYWx1ZSwgd1ZhbHVlLnh5KSxcbiAgICAgICAgICAgICAgICAgIGRvdChkeVZhbHVlLCB3VmFsdWUuencpKTtcblxuICAgICAgICAgICAgICAgIGR5VmFsdWUgPSBtb2QoZmxvYXQoaWR5QzIpLCAyLikgPT0gMC4gP1xuICAgICAgICAgICAgICAgICAgZHlTYW1wbGUyLnh5IDogZHlTYW1wbGUyLnp3O1xuICAgICAgICAgICAgICAgIHJlc3VsdC56dyArPSB2ZWMyKGRvdChkeVZhbHVlLCB3VmFsdWUueHkpLFxuICAgICAgICAgICAgICAgICAgZG90KGR5VmFsdWUsIHdWYWx1ZS56dykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlkeUNWYWwpIHtcbiAgICAgICAgICAgICAgZm9yIChpbnQgZDIgPSAwOyBkMiA8ICR7Y29udkluZm8ub3V0Q2hhbm5lbHN9OyBkMiArPSAyKSB7XG4gICAgICAgICAgICAgICAgdmVjNCB3VmFsdWUgPSBnZXRXKHdSUGVybSwgd0NQZXJtLCBkMSwgZDIpO1xuICAgICAgICAgICAgICAgIHZlYzQgZHlTYW1wbGUgPSBnZXREeShiYXRjaCwgaWR5UiwgaWR5QywgZDIpO1xuICAgICAgICAgICAgICAgIHZlYzIgZHlWYWx1ZSA9IG1vZChmbG9hdChpZHlDKSwgMi4pID09IDAuID9cbiAgICAgICAgICAgICAgICAgIGR5U2FtcGxlLnh5IDogZHlTYW1wbGUuenc7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lnh5ICs9IHZlYzIoZG90KGR5VmFsdWUsIHdWYWx1ZS54eSksXG4gICAgICAgICAgICAgICAgICBkb3QoZHlWYWx1ZSwgd1ZhbHVlLnp3KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaWR5Q1ZhbDIpIHtcbiAgICAgICAgICAgICAgZm9yIChpbnQgZDIgPSAwOyBkMiA8ICR7Y29udkluZm8ub3V0Q2hhbm5lbHN9OyBkMiArPSAyKSB7XG4gICAgICAgICAgICAgICAgdmVjNCB3VmFsdWUgPSBnZXRXKHdSUGVybSwgd0NQZXJtLCBkMSwgZDIpO1xuICAgICAgICAgICAgICAgIHZlYzQgZHlTYW1wbGUgPSBnZXREeShiYXRjaCwgaWR5UiwgaWR5QzIsIGQyKTtcbiAgICAgICAgICAgICAgICB2ZWMyIGR5VmFsdWUgPSBtb2QoZmxvYXQoaWR5QzIpLCAyLikgPT0gMC4gP1xuICAgICAgICAgICAgICAgICAgZHlTYW1wbGUueHkgOiBkeVNhbXBsZS56dztcbiAgICAgICAgICAgICAgICByZXN1bHQuencgKz0gdmVjMihkb3QoZHlWYWx1ZSwgd1ZhbHVlLnh5KSxcbiAgICAgICAgICAgICAgICAgIGRvdChkeVZhbHVlLCB3VmFsdWUuencpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG59XG4iXX0=","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class Conv2DProgram {\n    constructor(convInfo, addBias = false, activation = null, hasPreluActivationWeights = false, hasLeakyreluAlpha = false) {\n        this.variableNames = ['x', 'W'];\n        this.outputShape = convInfo.outShape;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;\n        const inputDepthVec4Remainder = convInfo.inChannels % 4;\n        const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n        const rowDim = isChannelsLast ? 1 : 2;\n        const colDim = isChannelsLast ? 2 : 3;\n        const channelDim = isChannelsLast ? 3 : 1;\n        let activationSnippet = '', applyActivationSnippet = '';\n        if (activation) {\n            if (hasPreluActivationWeights) {\n                activationSnippet = `float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else if (hasLeakyreluAlpha) {\n                activationSnippet = `float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else {\n                activationSnippet = `\n          float activation(float x) {\n            ${activation}\n          }\n        `;\n            }\n            applyActivationSnippet = `result = activation(result);`;\n        }\n        const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n        if (addBias) {\n            this.variableNames.push('bias');\n        }\n        if (hasPreluActivationWeights) {\n            this.variableNames.push('preluActivationWeights');\n        }\n        if (hasLeakyreluAlpha) {\n            this.variableNames.push('leakyreluAlpha');\n        }\n        this.userCode = `\n      ${activationSnippet}\n\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${channelDim}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${rowDim}], coords[${colDim}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          int xR = xRCorner + wR * ${dilationHeight};\n\n          if (xR < 0 || xR >= ${convInfo.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            int xC = xCCorner + wC * ${dilationWidth};\n\n            if (xC < 0 || xC >= ${convInfo.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${inputDepthVec4Remainder === 1}) {\n\n              if (${isChannelsLast}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${inputDepthNearestVec4}) *\n                    getW(wR, wC, ${inputDepthNearestVec4}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${inputDepthNearestVec4}, xR, xC) *\n                    getW(wR, wC, ${inputDepthNearestVec4}, d2);\n              }\n\n            } else if (${inputDepthVec4Remainder === 2}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${inputDepthNearestVec4}, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${inputDepthNearestVec4}, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${inputDepthVec4Remainder === 3}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${inputDepthNearestVec4}, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 2, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${inputDepthNearestVec4}, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n    }\n}\nexport class Conv3DProgram {\n    constructor(convInfo) {\n        this.variableNames = ['x', 'W'];\n        this.outputShape = convInfo.outShape;\n        const padFront = convInfo.padInfo.front;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationDepth = convInfo.dilationDepth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const filterDepth = convInfo.filterDepth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;\n        const inputDepthVec4Remainder = convInfo.inChannels % 4;\n        this.userCode = `\n      const ivec3 strides = ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${filterDepth}; wF++) {\n          int xF = xFCorner + wF * ${dilationDepth};\n\n          if (xF < 0 || xF >= ${convInfo.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${filterHeight}; wR++) {\n            int xR = xRCorner + wR * ${dilationHeight};\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${filterWidth}; wC++) {\n              int xC = xCCorner + wC * ${dilationWidth};\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${inputDepthVec4Remainder === 1}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}) *\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2);\n              } else if (${inputDepthVec4Remainder === 2}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${inputDepthVec4Remainder === 3}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udl9ncHUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtd2ViZ2wvc3JjL2NvbnZfZ3B1LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUtILE1BQU0sT0FBTyxhQUFhO0lBS3hCLFlBQ0ksUUFBaUMsRUFBRSxPQUFPLEdBQUcsS0FBSyxFQUNsRCxhQUFxQixJQUFJLEVBQUUseUJBQXlCLEdBQUcsS0FBSyxFQUM1RCxpQkFBaUIsR0FBRyxLQUFLO1FBUDdCLGtCQUFhLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFRekIsSUFBSSxDQUFDLFdBQVcsR0FBRyxRQUFRLENBQUMsUUFBUSxDQUFDO1FBQ3JDLE1BQU0sTUFBTSxHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDO1FBQ3BDLE1BQU0sT0FBTyxHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO1FBQ3RDLE1BQU0sWUFBWSxHQUFHLFFBQVEsQ0FBQyxZQUFZLENBQUM7UUFDM0MsTUFBTSxXQUFXLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQztRQUN6QyxNQUFNLGNBQWMsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDO1FBQy9DLE1BQU0sYUFBYSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUM7UUFDN0MsTUFBTSxZQUFZLEdBQUcsUUFBUSxDQUFDLFlBQVksQ0FBQztRQUMzQyxNQUFNLFdBQVcsR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDO1FBRXpDLE1BQU0scUJBQXFCLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsVUFBVSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN0RSxNQUFNLHVCQUF1QixHQUFHLFFBQVEsQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDO1FBQ3hELE1BQU0sY0FBYyxHQUFHLFFBQVEsQ0FBQyxVQUFVLEtB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dUJBQXVCLEtBQUssQ0FBQzs7NENBRVoscUJBQXFCOzRDQUNyQixxQkFBcUI7OztxQ0FHNUIscUJBQXFCO3FDQUNyQixxQkFBcUI7OzsyQkFHL0IsdUJBQXVCLEtBQUssQ0FBQzs7NENBRVoscUJBQXFCOzRDQUNyQixxQkFBcUI7NENBQ3JCLHFCQUFxQjs7O3FDQUc1QixxQkFBcUI7cUNBQ3JCLHFCQUFxQjtxQ0FDckIscUJBQXFCOzs7Ozs7Ozs7S0FTckQsQ0FBQztJQUNKLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtiYWNrZW5kX3V0aWx9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5pbXBvcnQge0dQR1BVUHJvZ3JhbX0gZnJvbSAnLi9ncGdwdV9tYXRoJztcblxuZXhwb3J0IGNsYXNzIENvbnYyRFByb2dyYW0gaW1wbGVtZW50cyBHUEdQVVByb2dyYW0ge1xuICB2YXJpYWJsZU5hbWVzID0gWyd4JywgJ1cnXTtcbiAgb3V0cHV0U2hhcGU6IG51bWJlcltdO1xuICB1c2VyQ29kZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgY29udkluZm86IGJhY2tlbmRfdXRpbC5Db252MkRJbmZvLCBhZGRCaWFzID0gZmFsc2UsXG4gICAgICBhY3RpdmF0aW9uOiBzdHJpbmcgPSBudWxsLCBoYXNQcmVsdUFjdGl2YXRpb25XZWlnaHRzID0gZmFsc2UsXG4gICAgICBoYXNMZWFreXJlbHVBbHBoYSA9IGZhbHNlKSB7XG4gICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLm91dFNoYXBlO1xuICAgIGNvbnN0IHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgIGNvbnN0IHBhZExlZnQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgY29uc3Qgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgIGNvbnN0IHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgY29uc3QgZGlsYXRpb25IZWlnaHQgPSBjb252SW5mby5kaWxhdGlvbkhlaWdodDtcbiAgICBjb25zdCBkaWxhdGlvbldpZHRoID0gY29udkluZm8uZGlsYXRpb25XaWR0aDtcbiAgICBjb25zdCBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgY29uc3QgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcblxuICAgIGNvbnN0IGlucHV0RGVwdGhOZWFyZXN0VmVjNCA9IE1hdGguZmxvb3IoY29udkluZm8uaW5DaGFubmVscyAvIDQpICogNDtcbiAgICBjb25zdCBpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9IGNvbnZJbmZvLmluQ2hhbm5lbHMgJSA0O1xuICAgIGNvbnN0IGlzQ2hhbm5lbHNMYXN0ID0gY29udkluZm8uZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzTGFzdCc7XG5cbiAgICBjb25zdCByb3dEaW0gPSBpc0NoYW5uZWxzTGFzdCA/IDEgOiAyO1xuICAgIGNvbnN0IGNvbERpbSA9IGlzQ2hhbm5lbHNMYXN0ID8gMiA6IDM7XG4gICAgY29uc3QgY2hhbm5lbERpbSA9IGlzQ2hhbm5lbHNMYXN0ID8gMyA6IDE7XG5cbiAgICBsZXQgYWN0aXZhdGlvblNuaXBwZXQgPSAnJywgYXBwbHlBY3RpdmF0aW9uU25pcHBldCA9ICcnO1xuICAgIGlmIChhY3RpdmF0aW9uKSB7XG4gICAgICBpZiAoaGFzUHJlbHVBY3RpdmF0aW9uV2VpZ2h0cykge1xuICAgICAgICBhY3RpdmF0aW9uU25pcHBldCA9IGBmbG9hdCBhY3RpdmF0aW9uKGZsb2F0IGEpIHtcbiAgICAgICAgICBmbG9hdCBiID0gZ2V0UHJlbHVBY3RpdmF0aW9uV2VpZ2h0c0F0T3V0Q29vcmRzKCk7XG4gICAgICAgICAgJHthY3RpdmF0aW9ufVxuICAgICAgICB9YDtcbiAgICAgIH0gZWxzZSBpZiAoaGFzTGVha3lyZWx1QWxwaGEpIHtcbiAgICAgICAgYWN0aXZhdGlvblNuaXBwZXQgPSBgZmxvYXQgYWN0aXZhdGlvbihmbG9hdCBhKSB7XG4gICAgICAgICAgZmxvYXQgYiA9IGdldExlYWt5cmVsdUFscGhhQXRPdXRDb29yZHMoKTtcbiAgICAgICAgICAke2FjdGl2YXRpb259XG4gICAgICAgIH1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZhdGlvblNuaXBwZXQgPSBgXG4gICAgICAgICAgZmxvYXQgYWN0aXZhdGlvbihmbG9hdCB4KSB7XG4gICAgICAgICAgICAke2FjdGl2YXRpb259XG4gICAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgfVxuXG4gICAgICBhcHBseUFjdGl2YXRpb25TbmlwcGV0ID0gYHJlc3VsdCA9IGFjdGl2YXRpb24ocmVzdWx0KTtgO1xuICAgIH1cblxuICAgIGNvbnN0IGFkZEJpYXNTbmlwcGV0ID0gYWRkQmlhcyA/ICdyZXN1bHQgKz0gZ2V0Qmlhc0F0T3V0Q29vcmRzKCk7JyA6ICcnO1xuICAgIGlmIChhZGRCaWFzKSB7XG4gICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgnYmlhcycpO1xuICAgIH1cblxuICAgIGlmIChoYXNQcmVsdUFjdGl2YXRpb25XZWlnaHRzKSB7XG4gICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgncHJlbHVBY3RpdmF0aW9uV2VpZ2h0cycpO1xuICAgIH1cblxuICAgIGlmIChoYXNMZWFreXJlbHVBbHBoYSkge1xuICAgICAgdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goJ2xlYWt5cmVsdUFscGhhJyk7XG4gICAgfVxuXG4gICAgdGhpcy51c2VyQ29kZSA9IGBcbiAgICAgICR7YWN0aXZhdGlvblNuaXBwZXR9XG5cbiAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMigke3N0cmlkZUhlaWdodH0sICR7c3RyaWRlV2lkdGh9KTtcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke3BhZFRvcH0sICR7cGFkTGVmdH0pO1xuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XG4gICAgICAgIGludCBkMiA9IGNvb3Jkc1ske2NoYW5uZWxEaW19XTtcblxuICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPVxuICAgICAgICAgICAgaXZlYzIoY29vcmRzWyR7cm93RGltfV0sIGNvb3Jkc1ske2NvbERpbX1dKSAqIHN0cmlkZXMgLSBwYWRzO1xuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcbiAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XG5cbiAgICAgICAgLy8gQ29udm9sdmUgeCg/LCA/LCBkMSkgd2l0aCB3KDosIDosIGQxLCBkMikgdG8gZ2V0IHkoeVIsIHlDLCBkMikuXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgJHtmaWx0ZXJIZWlnaHR9OyB3UisrKSB7XG4gICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UiAqICR7ZGlsYXRpb25IZWlnaHR9O1xuXG4gICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSAke2NvbnZJbmZvLmluSGVpZ2h0fSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8ICR7ZmlsdGVyV2lkdGh9OyB3QysrKSB7XG4gICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDICogJHtkaWxhdGlvbldpZHRofTtcblxuICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSAke2NvbnZJbmZvLmluV2lkdGh9KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGludCBkMSA9IDA7IGQxIDwgJHtpbnB1dERlcHRoTmVhcmVzdFZlYzR9OyBkMSArPSA0KSB7XG4gICAgICAgICAgICAgIHZlYzQgd1ZhbHVlcyA9IHZlYzQoXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxLCBkMiksXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxICsgMSwgZDIpLFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBkMSArIDIsIGQyKSxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgZDEgKyAzLCBkMilcbiAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICBpZiAoJHtpc0NoYW5uZWxzTGFzdH0pIHtcbiAgICAgICAgICAgICAgICB2ZWM0IHhWYWx1ZXMgPSB2ZWM0KFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSksXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxICsgMSksXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxICsgMiksXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxICsgMylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZlYzQgeFZhbHVlcyA9IHZlYzQoXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMSwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMywgeFIsIHhDKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCR7aW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT09IDF9KSB7XG5cbiAgICAgICAgICAgICAgaWYgKCR7aXNDaGFubmVsc0xhc3R9KSB7XG4gICAgICAgICAgICAgICAgZG90UHJvZCArPVxuICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsICR7aW5wdXREZXB0aE5lYXJlc3RWZWM0fSkgKlxuICAgICAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgJHtpbnB1dERlcHRoTmVhcmVzdFZlYzR9LCBkMik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZG90UHJvZCArPVxuICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCAke2lucHV0RGVwdGhOZWFyZXN0VmVjNH0sIHhSLCB4QykgKlxuICAgICAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgJHtpbnB1dERlcHRoTmVhcmVzdFZlYzR9LCBkMik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIGlmICgke2lucHV0RGVwdGhWZWM0UmVtYWluZGVyID09PSAyfSkge1xuICAgICAgICAgICAgICB2ZWMyIHdWYWx1ZXMgPSB2ZWMyKFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCAke2lucHV0RGVwdGhOZWFyZXN0VmVjNH0sIGQyKSxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgJHtpbnB1dERlcHRoTmVhcmVzdFZlYzR9ICsgMSwgZDIpXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgaWYgKCR7aXNDaGFubmVsc0xhc3R9KSB7XG4gICAgICAgICAgICAgICAgdmVjMiB4VmFsdWVzID0gdmVjMihcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgJHtpbnB1dERlcHRoTmVhcmVzdFZlYzR9KSxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgJHtpbnB1dERlcHRoTmVhcmVzdFZlYzR9ICsgMSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZlYzIgeFZhbHVlcyA9IHZlYzIoXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCAke2lucHV0RGVwdGhOZWFyZXN0VmVjNH0sIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCAke2lucHV0RGVwdGhOZWFyZXN0VmVjNH0gKyAxLCB4UiwgeEMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCR7aW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT09IDN9KSB7XG4gICAgICAgICAgICAgIHZlYzMgd1ZhbHVlcyA9IHZlYzMoXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsICR7aW5wdXREZXB0aE5lYXJlc3RWZWM0fSwgZDIpLFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCAke2lucHV0RGVwdGhOZWFyZXN0VmVjNH0gKyAxLCBkMiksXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsICR7aW5wdXREZXB0aE5lYXJlc3RWZWM0fSArIDIsIGQyKVxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgIGlmICgke2lzQ2hhbm5lbHNMYXN0fSkge1xuICAgICAgICAgICAgICAgIHZlYzMgeFZhbHVlcyA9IHZlYzMoXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsICR7aW5wdXREZXB0aE5lYXJlc3RWZWM0fSksXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsICR7aW5wdXREZXB0aE5lYXJlc3RWZWM0fSArIDEpLFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCAke2lucHV0RGVwdGhOZWFyZXN0VmVjNH0gKyAyKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmVjMyB4VmFsdWVzID0gdmVjMyhcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsICR7aW5wdXREZXB0aE5lYXJlc3RWZWM0fSwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsICR7aW5wdXREZXB0aE5lYXJlc3RWZWM0fSArIDEsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCAke2lucHV0RGVwdGhOZWFyZXN0VmVjNH0gKyAyLCB4UiwgeEMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZmxvYXQgcmVzdWx0ID0gZG90UHJvZDtcbiAgICAgICAgJHthZGRCaWFzU25pcHBldH1cbiAgICAgICAgJHthcHBseUFjdGl2YXRpb25TbmlwcGV0fVxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDb252M0RQcm9ncmFtIGltcGxlbWVudHMgR1BHUFVQcm9ncmFtIHtcbiAgdmFyaWFibGVOYW1lcyA9IFsneCcsICdXJ107XG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXTtcbiAgdXNlckNvZGU6IHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcihjb252SW5mbzogYmFja2VuZF91dGlsLkNvbnYzREluZm8pIHtcbiAgICB0aGlzLm91dHB1dFNoYXBlID0gY29udkluZm8ub3V0U2hhcGU7XG4gICAgY29uc3QgcGFkRnJvbnQgPSBjb252SW5mby5wYWRJbmZvLmZyb250O1xuICAgIGNvbnN0IHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgIGNvbnN0IHBhZExlZnQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgY29uc3Qgc3RyaWRlRGVwdGggPSBjb252SW5mby5zdHJpZGVEZXB0aDtcbiAgICBjb25zdCBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgY29uc3Qgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICBjb25zdCBkaWxhdGlvbkRlcHRoID0gY29udkluZm8uZGlsYXRpb25EZXB0aDtcbiAgICBjb25zdCBkaWxhdGlvbkhlaWdodCA9IGNvbnZJbmZvLmRpbGF0aW9uSGVpZ2h0O1xuICAgIGNvbnN0IGRpbGF0aW9uV2lkdGggPSBjb252SW5mby5kaWxhdGlvbldpZHRoO1xuICAgIGNvbnN0IGZpbHRlckRlcHRoID0gY29udkluZm8uZmlsdGVyRGVwdGg7XG4gICAgY29uc3QgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgIGNvbnN0IGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG5cbiAgICBjb25zdCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgPSBNYXRoLmZsb29yKGNvbnZJbmZvLmluQ2hhbm5lbHMgLyA0KSAqIDQ7XG4gICAgY29uc3QgaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPSBjb252SW5mby5pbkNoYW5uZWxzICUgNDtcblxuICAgIHRoaXMudXNlckNvZGUgPSBgXG4gICAgICBjb25zdCBpdmVjMyBzdHJpZGVzID0gaXZlYzMoJHtzdHJpZGVEZXB0aH0sICR7c3RyaWRlSGVpZ2h0fSwgJHtcbiAgICAgICAgc3RyaWRlV2lkdGh9KTtcbiAgICAgIGNvbnN0IGl2ZWMzIHBhZHMgPSBpdmVjMygke3BhZEZyb250fSwgJHtwYWRUb3B9LCAke3BhZExlZnR9KTtcblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjNSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy51O1xuXG4gICAgICAgIGl2ZWMzIHhGUkNDb3JuZXIgPSBpdmVjMyhjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy53KSAqIHN0cmlkZXMgLSBwYWRzO1xuICAgICAgICBpbnQgeEZDb3JuZXIgPSB4RlJDQ29ybmVyLng7XG4gICAgICAgIGludCB4UkNvcm5lciA9IHhGUkNDb3JuZXIueTtcbiAgICAgICAgaW50IHhDQ29ybmVyID0geEZSQ0Nvcm5lci56O1xuXG4gICAgICAgIC8vIENvbnZvbHZlIHgoPywgPywgPywgZDEpIHdpdGggdyg6LCA6LCA6LCBkMSwgZDIpIHRvIGdldFxuICAgICAgICAvLyB5KHlGLCB5UiwgeUMsIGQyKS4gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsXG4gICAgICAgIC8vIHZhbHVlcyBpbiB0aGF0IGF4aXMuXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XG4gICAgICAgIGZvciAoaW50IHdGID0gMDsgd0YgPCAke2ZpbHRlckRlcHRofTsgd0YrKykge1xuICAgICAgICAgIGludCB4RiA9IHhGQ29ybmVyICsgd0YgKiAke2RpbGF0aW9uRGVwdGh9O1xuXG4gICAgICAgICAgaWYgKHhGIDwgMCB8fCB4RiA+PSAke2NvbnZJbmZvLmluRGVwdGh9KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgJHtmaWx0ZXJIZWlnaHR9OyB3UisrKSB7XG4gICAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSICogJHtkaWxhdGlvbkhlaWdodH07XG5cbiAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gJHtjb252SW5mby5pbkhlaWdodH0pIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCAke2ZpbHRlcldpZHRofTsgd0MrKykge1xuICAgICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDICogJHtkaWxhdGlvbldpZHRofTtcblxuICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49ICR7Y29udkluZm8uaW5XaWR0aH0pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZvciAoaW50IGQxID0gMDsgZDEgPCAke2lucHV0RGVwdGhOZWFyZXN0VmVjNH07IGQxICs9IDQpIHtcbiAgICAgICAgICAgICAgICB2ZWM0IHhWYWx1ZXMgPSB2ZWM0KFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEpLFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEgKyAxKSxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxICsgMiksXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSArIDMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB2ZWM0IHdWYWx1ZXMgPSB2ZWM0KFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBkMSwgZDIpLFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBkMSArIDEsIGQyKSxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgZDEgKyAyLCBkMiksXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsIGQxICsgMywgZDIpXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCR7aW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT09IDF9KSB7XG4gICAgICAgICAgICAgICAgZG90UHJvZCArPVxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgJHtpbnB1dERlcHRoTmVhcmVzdFZlYzR9KSAqXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsICR7aW5wdXREZXB0aE5lYXJlc3RWZWM0fSwgZDIpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCR7aW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT09IDJ9KSB7XG4gICAgICAgICAgICAgICAgdmVjMiB4VmFsdWVzID0gdmVjMihcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsICR7aW5wdXREZXB0aE5lYXJlc3RWZWM0fSksXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCAke2lucHV0RGVwdGhOZWFyZXN0VmVjNH0gKyAxKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdmVjMiB3VmFsdWVzID0gdmVjMihcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgJHtpbnB1dERlcHRoTmVhcmVzdFZlYzR9LCBkMiksXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsICR7aW5wdXREZXB0aE5lYXJlc3RWZWM0fSArIDEsIGQyKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoJHtpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PT0gM30pIHtcbiAgICAgICAgICAgICAgICB2ZWMzIHhWYWx1ZXMgPSB2ZWMzKFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgJHtpbnB1dERlcHRoTmVhcmVzdFZlYzR9KSxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsICR7aW5wdXREZXB0aE5lYXJlc3RWZWM0fSArIDEpLFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgJHtpbnB1dERlcHRoTmVhcmVzdFZlYzR9ICsgMilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHZlYzMgd1ZhbHVlcyA9IHZlYzMoXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsICR7aW5wdXREZXB0aE5lYXJlc3RWZWM0fSwgZDIpLFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCAke2lucHV0RGVwdGhOZWFyZXN0VmVjNH0gKyAxLCBkMiksXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsICR7aW5wdXREZXB0aE5lYXJlc3RWZWM0fSArIDIsIGQyKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xuICAgICAgfVxuICAgIGA7XG4gIH1cbn1cbiJdfQ==","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { useShapeUniforms } from './gpgpu_math';\nexport class DepthwiseConv2DProgram {\n    constructor(convInfo, addBias = false, activation = null, hasPreluActivation = false, hasLeakyReluAlpha = false) {\n        this.variableNames = ['x', 'W'];\n        this.customUniforms = [\n            { name: 'pads', type: 'ivec2' },\n            { name: 'strides', type: 'ivec2' },\n            { name: 'dilations', type: 'ivec2' },\n            { name: 'inDims', type: 'ivec2' },\n        ];\n        this.outputShape = convInfo.outShape;\n        this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const channelMul = convInfo.outChannels / convInfo.inChannels;\n        let activationSnippet = '', applyActivationSnippet = '';\n        if (activation) {\n            if (hasPreluActivation) {\n                activationSnippet = `float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else if (hasLeakyReluAlpha) {\n                activationSnippet = `float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else {\n                activationSnippet = `\n          float activation(float x) {\n            ${activation}\n          }\n        `;\n            }\n            applyActivationSnippet = `result = activation(result);`;\n        }\n        const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n        if (addBias) {\n            this.variableNames.push('bias');\n        }\n        if (hasPreluActivation) {\n            this.variableNames.push('preluActivationWeights');\n        }\n        if (hasLeakyReluAlpha) {\n            this.variableNames.push('leakyreluAlpha');\n        }\n        this.userCode = `\n      ${activationSnippet}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${channelMul};\n        int q = d2 - d1 * ${channelMul};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udl9ncHVfZGVwdGh3aXNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vdGZqcy1iYWNrZW5kLXdlYmdsL3NyYy9jb252X2dwdV9kZXB0aHdpc2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBR0gsT0FBTyxFQUFlLGdCQUFnQixFQUFDLE1BQU0sY0FBYyxDQUFDO0FBRTVELE1BQU0sT0FBTyxzQkFBc0I7SUFZakMsWUFDSSxRQUFpQyxFQUFFLE9BQU8sR0FBRyxLQUFLLEVBQ2xELGFBQXFCLElBQUksRUFBRSxrQkFBa0IsR0FBRyxLQUFLLEVBQ3JELGlCQUFpQixHQUFHLEtBQUs7UUFkN0Isa0JBQWEsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUkzQixtQkFBYyxHQUFHO1lBQ2YsRUFBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxPQUFnQixFQUFFO1lBQ3ZDLEVBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsT0FBZ0IsRUFBRTtZQUMxQyxFQUFDLElBQUksRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFLE9BQWdCLEVBQUU7WUFDNUMsRUFBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxPQUFnQixFQUFFO1NBQzFDLENBQUM7UUFNQSxJQUFJLENBQUMsV0FBVyxHQUFHLFFBQVEsQ0FBQyxRQUFRLENBQUM7UUFDckMsSUFBSSxDQUFDLG1CQUFtQixHQUFHLGdCQUFnQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFckUsTUFBTSxZQUFZLEdBQUcsUUFBUSxDQUFDLFlBQVksQ0FBQztRQUMzQyxNQUFNLFdBQVcsR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDO1FBQ3pDLE1BQU0sVUFBVSxHQUFHLFFBQVEsQ0FBQyxXQUFXLEdBQUcsUUFBUSxDQUFDLFVBQVUsQ0FBQztRQUU5RCxJQUFJLGlCQUFpQixHQUFHLEVBQUUsRUFBRSxzQkFBc0IsR0FBRyxFQUFFLENBQUM7UUFDeEQsSUFBSSxVQUFVLEVBQUU7WUFDZCxJQUFJLGtCQUFrQixFQUFFO2dCQUN0QixpQkFBaUIsR0FBRzs7WUFFaEIsVUFBVTtVQUNaLENBQUM7YUFDSjtpQkFBTSxJQUFJLGlCQUFpQixFQUFFO2dCQUM1QixpQkFBaUIsR0FBRzs7WUFFaEIsVUFBVTtVQUNaLENBQUM7YUFDSjtpQkFBTTtnQkFDTCxpQkFBaUIsR0FBRzs7Y0FFZCxVQUFVOztTQUVmLENBQUM7YUFDSDtZQUVELHNCQUFzQixHQUFHLDhCQUE4QixDQUFDO1NBQ3pEO1FBRUQsTUFBTSxjQUFjLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ3hFLElBQUksT0FBTyxFQUFFO1lBQ1gsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDakM7UUFFRCxJQUFJLGtCQUFrQixFQUFFO1lBQ3RCLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLHdCQUF3QixDQUFDLENBQUM7U0FDbkQ7UUFDRCxJQUFJLGlCQUFpQixFQUFFO1lBQ3JCLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7U0FDM0M7UUFFRCxJQUFJLENBQUMsUUFBUSxHQUFHO1FBQ1osaUJBQWlCOzs7Ozs7O3dCQU9ELFVBQVU7NEJBQ04sVUFBVTs7Ozs7Ozs7O2dDQVNOLFlBQVk7Ozs7Ozs7a0NBT1YsV0FBVzs7Ozs7Ozs7Ozs7Ozs7VUFjbkMsY0FBYztVQUNkLHNCQUFzQjs7O0tBRzNCLENBQUM7SUFDSixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7YmFja2VuZF91dGlsfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuaW1wb3J0IHtHUEdQVVByb2dyYW0sIHVzZVNoYXBlVW5pZm9ybXN9IGZyb20gJy4vZ3BncHVfbWF0aCc7XG5cbmV4cG9ydCBjbGFzcyBEZXB0aHdpc2VDb252MkRQcm9ncmFtIGltcGxlbWVudHMgR1BHUFVQcm9ncmFtIHtcbiAgdmFyaWFibGVOYW1lcyA9IFsneCcsICdXJ107XG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXTtcbiAgdXNlckNvZGU6IHN0cmluZztcbiAgZW5hYmxlU2hhcGVVbmlmb3JtczogYm9vbGVhbjtcbiAgY3VzdG9tVW5pZm9ybXMgPSBbXG4gICAge25hbWU6ICdwYWRzJywgdHlwZTogJ2l2ZWMyJyBhcyBjb25zdCB9LFxuICAgIHtuYW1lOiAnc3RyaWRlcycsIHR5cGU6ICdpdmVjMicgYXMgY29uc3QgfSxcbiAgICB7bmFtZTogJ2RpbGF0aW9ucycsIHR5cGU6ICdpdmVjMicgYXMgY29uc3QgfSxcbiAgICB7bmFtZTogJ2luRGltcycsIHR5cGU6ICdpdmVjMicgYXMgY29uc3QgfSxcbiAgXTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICAgIGNvbnZJbmZvOiBiYWNrZW5kX3V0aWwuQ29udjJESW5mbywgYWRkQmlhcyA9IGZhbHNlLFxuICAgICAgYWN0aXZhdGlvbjogc3RyaW5nID0gbnVsbCwgaGFzUHJlbHVBY3RpdmF0aW9uID0gZmFsc2UsXG4gICAgICBoYXNMZWFreVJlbHVBbHBoYSA9IGZhbHNlKSB7XG4gICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLm91dFNoYXBlO1xuICAgIHRoaXMuZW5hYmxlU2hhcGVVbmlmb3JtcyA9IHVzZVNoYXBlVW5pZm9ybXModGhpcy5vdXRwdXRTaGFwZS5sZW5ndGgpO1xuXG4gICAgY29uc3QgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgIGNvbnN0IGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgY29uc3QgY2hhbm5lbE11bCA9IGNvbnZJbmZvLm91dENoYW5uZWxzIC8gY29udkluZm8uaW5DaGFubmVscztcblxuICAgIGxldCBhY3RpdmF0aW9uU25pcHBldCA9ICcnLCBhcHBseUFjdGl2YXRpb25TbmlwcGV0ID0gJyc7XG4gICAgaWYgKGFjdGl2YXRpb24pIHtcbiAgICAgIGlmIChoYXNQcmVsdUFjdGl2YXRpb24pIHtcbiAgICAgICAgYWN0aXZhdGlvblNuaXBwZXQgPSBgZmxvYXQgYWN0aXZhdGlvbihmbG9hdCBhKSB7XG4gICAgICAgICAgZmxvYXQgYiA9IGdldFByZWx1QWN0aXZhdGlvbldlaWdodHNBdE91dENvb3JkcygpO1xuICAgICAgICAgICR7YWN0aXZhdGlvbn1cbiAgICAgICAgfWA7XG4gICAgICB9IGVsc2UgaWYgKGhhc0xlYWt5UmVsdUFscGhhKSB7XG4gICAgICAgIGFjdGl2YXRpb25TbmlwcGV0ID0gYGZsb2F0IGFjdGl2YXRpb24oZmxvYXQgYSkge1xuICAgICAgICAgIGZsb2F0IGIgPSBnZXRMZWFreXJlbHVBbHBoYUF0T3V0Q29vcmRzKCk7XG4gICAgICAgICAgJHthY3RpdmF0aW9ufVxuICAgICAgICB9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2YXRpb25TbmlwcGV0ID0gYFxuICAgICAgICAgIGZsb2F0IGFjdGl2YXRpb24oZmxvYXQgeCkge1xuICAgICAgICAgICAgJHthY3RpdmF0aW9ufVxuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIH1cblxuICAgICAgYXBwbHlBY3RpdmF0aW9uU25pcHBldCA9IGByZXN1bHQgPSBhY3RpdmF0aW9uKHJlc3VsdCk7YDtcbiAgICB9XG5cbiAgICBjb25zdCBhZGRCaWFzU25pcHBldCA9IGFkZEJpYXMgPyAncmVzdWx0ICs9IGdldEJpYXNBdE91dENvb3JkcygpOycgOiAnJztcbiAgICBpZiAoYWRkQmlhcykge1xuICAgICAgdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goJ2JpYXMnKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzUHJlbHVBY3RpdmF0aW9uKSB7XG4gICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgncHJlbHVBY3RpdmF0aW9uV2VpZ2h0cycpO1xuICAgIH1cbiAgICBpZiAoaGFzTGVha3lSZWx1QWxwaGEpIHtcbiAgICAgIHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKCdsZWFreXJlbHVBbHBoYScpO1xuICAgIH1cblxuICAgIHRoaXMudXNlckNvZGUgPSBgXG4gICAgICAke2FjdGl2YXRpb25TbmlwcGV0fVxuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcbiAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy53O1xuICAgICAgICBpbnQgZDEgPSBkMiAvICR7Y2hhbm5lbE11bH07XG4gICAgICAgIGludCBxID0gZDIgLSBkMSAqICR7Y2hhbm5lbE11bH07XG5cbiAgICAgICAgaW50IHhSQ29ybmVyID0geFJDQ29ybmVyLng7XG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xuXG4gICAgICAgIC8vIENvbnZvbHZlIHgoPywgPywgZDEpIHdpdGggdyg6LCA6LCBkMSwgcSkgdG8gZ2V0IHkoeVIsIHlDLCBkMikuXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xuICAgICAgICAvLyBUTyBETyhkc21pbGtvdik6IEZsYXR0ZW4gdGhlIHR3byBmb3IgbG9vcHMgYW5kIHZlYzQgdGhlIG9wZXJhdGlvbnMuXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCAke2ZpbHRlckhlaWdodH07IHdSKyspIHtcbiAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSICogZGlsYXRpb25zWzBdO1xuXG4gICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBpbkRpbXNbMF0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCAke2ZpbHRlcldpZHRofTsgd0MrKykge1xuICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QyAqIGRpbGF0aW9uc1sxXTtcblxuICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZsb2F0IHhWYWwgPSBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxKTtcbiAgICAgICAgICAgIGZsb2F0IHdWYWwgPSBnZXRXKHdSLCB3QywgZDEsIHEpO1xuICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsICogd1ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmbG9hdCByZXN1bHQgPSBkb3RQcm9kO1xuICAgICAgICAke2FkZEJpYXNTbmlwcGV0fVxuICAgICAgICAke2FwcGx5QWN0aXZhdGlvblNuaXBwZXR9XG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xuICAgICAgfVxuICAgIGA7XG4gIH1cbn1cbiJdfQ==","/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { useShapeUniforms } from './gpgpu_math';\nexport class Conv2DPackedProgram {\n    constructor(convInfo, addBias = false, activation = null, hasPreluActivation = false, hasLeakyReluAlpha = false) {\n        this.variableNames = ['x', 'W'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.customUniforms = [\n            { name: 'pads', type: 'ivec2' },\n            { name: 'strides', type: 'ivec2' },\n            { name: 'dilations', type: 'ivec2' },\n            { name: 'inDims', type: 'ivec2' },\n        ];\n        this.outputShape = convInfo.outShape;\n        this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);\n        const padLeft = convInfo.padInfo.left;\n        const strideWidth = convInfo.strideWidth;\n        const dilationWidth = convInfo.dilationWidth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const texelsAcross = filterWidth;\n        let mainLoop = `\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;`;\n        for (let c = 0; c < filterWidth; c++) {\n            mainLoop += `\n           vec4 xTexelC${c * 2};\n           int xTexelC${c * 2}Ready;\n           vec4 xTexelC${c * 2 + 1};\n           int xTexelC${c * 2 + 1}Ready;\n           vec4 xC${c};`;\n        }\n        /**\n         * This vectorized implementation works by gathering the values needed for\n         * each output channel's dot product into vec4's and then multiplying them\n         * all together (this happens in the final double for-loop below). Most of\n         * the main loop consists of constructing these vec4's with the minimum\n         * number of texture2D calls, which means making use of all four returned\n         * values from a texture2D call at once.\n         */\n        mainLoop += `\n     for (int r = 0; r < ${filterHeight}; r++) {\n      for (int d1 = 0; d1 < ${convInfo.inChannels}; d1 += 2) {\n       `;\n        for (let c = 0; c < filterWidth; c++) {\n            mainLoop += `\n           xTexelC${c * 2} = vec4(0.0);\n           xTexelC${c * 2}Ready = 0;\n           xTexelC${c * 2 + 1} = vec4(0.0);\n           xTexelC${c * 2 + 1}Ready = 0;\n           xC${c} = vec4(0.0);`;\n        }\n        mainLoop += `\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       `;\n        for (let texelC = 0; texelC < (texelsAcross + 1) / 2; texelC++) {\n            const colIndex = texelC * 2;\n            mainLoop += `\n           xC = xCCorner + ${colIndex * dilationWidth};\n           `;\n            if (strideWidth === 1) {\n                if (colIndex < filterWidth) {\n                    // If padding is odd, the outer texels have to be composed.\n                    if (padLeft % 2 === 1) {\n                        // TODO: Ensure vec4 previous does not result in redundant sample,\n                        // and avoid setting xTexelRC's that exceed the boundary in the\n                        // first place rather than resetting them to vec4(0)).\n                        // To compute xCOffset:\n                        // - If padding is odd, we must add 1 to ensure we ask for an\n                        // even-numbered row.\n                        // - We subtract 2 to access the previous texel.\n                        mainLoop += `\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex}Ready == 0) {\n                   xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${colIndex}.zw = vec2(0.0);\n                   }\n                   xTexelC${colIndex}Ready = 1;\n                 }\n               `;\n                        // This texel has been read in previous iteration if the dilation\n                        // is 1.\n                        if (dilationWidth === 1 && colIndex > 0) {\n                            mainLoop += `\n                 xC${colIndex} = vec4(xTexelC${colIndex - 2}.zw, xTexelC${colIndex}.xy);\n                 `;\n                        }\n                        else {\n                            mainLoop += `\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${colIndex} = vec4(previous.zw, xTexelC${colIndex}.xy);\n                   } else {\n                     xC${colIndex} = vec4(0.0, 0.0, xTexelC${colIndex}.xy);\n                   }\n                   `;\n                        }\n                    }\n                    else {\n                        // Padding is even, so xRC corresponds to a single texel.\n                        mainLoop += `\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${colIndex}Ready == 0) {\n                   xTexelC${colIndex} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${colIndex}.zw = vec2(0.0);\n                   }\n                   xTexelC${colIndex}Ready = 1;\n                 }\n\n                 xC${colIndex} = xTexelC${colIndex};\n                 `;\n                    }\n                    if (colIndex + 1 < filterWidth) {\n                        // If dilation is even, the second entry should match the first\n                        // (either both are composed or both are single samples). But if\n                        // dilation is odd, then the second entry should be the opposite\n                        // of the first (if the first is composed, the second is a single\n                        // sample, and vice versa.)\n                        const nextTexelOffset = padLeft % 2 === 0 ?\n                            util.nearestLargerEven(dilationWidth) :\n                            dilationWidth;\n                        if ((dilationWidth % 2 === 0 && padLeft % 2 === 1) ||\n                            (dilationWidth % 2 !== 0 && padLeft % 2 !== 1)) {\n                            mainLoop += `\n                   xCOffset = xC + imod(pads[1], 2) + ${nextTexelOffset};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {\n                     xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${colIndex + 1}.zw = vec2(0.0);\n                     }\n                     xTexelC${colIndex + 1}Ready = 1;\n                   }\n                   `;\n                            // If dilation > 1 then the xRC's will not be able to share any\n                            // values, so each xRC will require two unique calls to getX.\n                            if (dilationWidth > 1) {\n                                mainLoop += `\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${colIndex + 1} = vec4(previous.zw, xTexelC${colIndex + 1}.xy);\n                     } else {\n                      xC${colIndex + 1} = vec4(0.0, 0.0, xTexelC${colIndex + 1}.xy);\n                     }\n                     `;\n                            }\n                            else {\n                                mainLoop += `\n                     xC${colIndex + 1} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.xy);\n                     `;\n                            }\n                        }\n                        else {\n                            // If dilation is 1 and padding is odd, we have already read the\n                            // texel when constructing the previous x value. Here we can\n                            // simply skip the texture read.\n                            if (nextTexelOffset === 1) {\n                                mainLoop += `\n                     xC${colIndex + 1} = xTexelC${colIndex};\n                     `;\n                            }\n                            else {\n                                mainLoop += `\n                     xCOffset = xC + ${nextTexelOffset};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {\n                       xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${colIndex + 1}.zw = vec2(0.0);\n                       }\n                       xTexelC${colIndex + 1}Ready = 1;\n                     }\n\n                     xC${colIndex + 1} = xTexelC${colIndex + 1};\n                     `;\n                            }\n                        }\n                    }\n                }\n            }\n            else { // stride === 2\n                if (colIndex < filterWidth) {\n                    // Depending on whether padLeft is even or odd, we want either the\n                    // xy or zw channels from X texels for xC${colIndex}. If padLeft is\n                    // even, xC${colIndex +1} is simply the zw channels of texels we've\n                    // already sampled. But if padLeft is odd, xC{$c + 1}.zw will\n                    // need to come from the xy channels of a new texel, hence the `\n                    // vec4\n                    // final` initialized below.\n                    if (padLeft % 2 === 1) {\n                        mainLoop += `\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex}Ready == 0) {\n                   xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${colIndex}.zw = vec2(0.0);\n                   }\n                   xTexelC${colIndex}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {\n                   xTexelC${colIndex + 1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${colIndex + 1}.zw = vec2(0.0);\n                   }\n                   xTexelC${colIndex + 1}Ready = 1;\n                 }\n\n                 xC${colIndex} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.zw);\n               `;\n                        if (colIndex + 1 < filterWidth) {\n                            mainLoop += `\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${colIndex + 1} = vec4(xTexelC${colIndex + 1}.xy, final.xy);\n                 `;\n                        }\n                    }\n                    else {\n                        mainLoop += `\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${colIndex}Ready == 0) {\n                   xTexelC${colIndex} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${colIndex}.zw = vec2(0.0);\n                   }\n                   xTexelC${colIndex}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {\n                   xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${colIndex + 1}.zw = vec2(0.);\n                   }\n                   xTexelC${colIndex + 1}Ready = 1;\n                 }\n\n                 xC${colIndex} = vec4(\n                   xTexelC${colIndex}.xy, xTexelC${colIndex + 1}.xy);\n               `;\n                        if (colIndex + 1 < filterWidth) {\n                            mainLoop += `\n                   xC${colIndex + 1} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.zw);\n                 `;\n                        }\n                    }\n                }\n            }\n            // localize the dotProd accumulation within the loop, the theory is for\n            // GPU with limited cache, accumulate sum across large amount of\n            // veriables will cause lots of cache misses. (i.e. 5x5 filter will have\n            // 50 variables)\n            if (colIndex < filterWidth) {\n                mainLoop += `\n             wTexel = getW(r, ${colIndex}, d1, d2);\n             dotProd += xC${colIndex}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${convInfo.inChannels}) {\n               dotProd += xC${colIndex}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `;\n                if (colIndex + 1 < filterWidth) {\n                    mainLoop += `\n               wTexel = getW(r, ${colIndex + 1}, d1, d2);\n               dotProd += xC${colIndex + 1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${convInfo.inChannels}) {\n                 dotProd += xC${colIndex + 1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `;\n                }\n            }\n        }\n        mainLoop += `\n     }\n   `;\n        mainLoop += `\n     }\n   `;\n        mainLoop += `\n     }\n   `;\n        let activationSnippet = '', applyActivationSnippet = '';\n        if (activation) {\n            if (hasPreluActivation) {\n                activationSnippet = `vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${activation}\n         }`;\n            }\n            else if (hasLeakyReluAlpha) {\n                activationSnippet = `vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${activation}\n         }`;\n            }\n            else {\n                activationSnippet = `vec4 activation(vec4 x) {\n           ${activation}\n         }`;\n            }\n            applyActivationSnippet = `result = activation(result);`;\n        }\n        const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n        if (addBias) {\n            this.variableNames.push('bias');\n        }\n        if (hasPreluActivation) {\n            this.variableNames.push('preluActivationWeights');\n        }\n        if (hasLeakyReluAlpha) {\n            this.variableNames.push('leakyreluAlpha');\n        }\n        this.userCode = `\n       ${activationSnippet}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${mainLoop}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${addBiasSnippet}\n         ${applyActivationSnippet}\n         setOutput(result);\n       }\n     `;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udl9wYWNrZWRfZ3B1LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vdGZqcy1iYWNrZW5kLXdlYmdsL3NyYy9jb252X3BhY2tlZF9ncHUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUYsT0FBTyxFQUFlLElBQUksRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBRXpELE9BQU8sRUFBZSxnQkFBZ0IsRUFBQyxNQUFNLGNBQWMsQ0FBQztBQUU1RCxNQUFNLE9BQU8sbUJBQW1CO0lBYzlCLFlBQ0ksUUFBaUMsRUFBRSxPQUFPLEdBQUcsS0FBSyxFQUNsRCxhQUFxQixJQUFJLEVBQUUsa0JBQWtCLEdBQUcsS0FBSyxFQUNyRCxpQkFBaUIsR0FBRyxLQUFLO1FBaEI3QixrQkFBYSxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQzNCLGlCQUFZLEdBQUcsSUFBSSxDQUFDO1FBQ3BCLGlCQUFZLEdBQUcsSUFBSSxDQUFDO1FBSXBCLG1CQUFjLEdBQUc7WUFDZixFQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLE9BQWdCLEVBQUU7WUFDdkMsRUFBQyxJQUFJLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxPQUFnQixFQUFFO1lBQzFDLEVBQUMsSUFBSSxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUsT0FBZ0IsRUFBRTtZQUM1QyxFQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLE9BQWdCLEVBQUU7U0FDMUMsQ0FBQztRQU1BLElBQUksQ0FBQyxXQUFXLEdBQUcsUUFBUSxDQUFDLFFBQVEsQ0FBQztRQUNyQyxJQUFJLENBQUMsbUJBQW1CLEdBQUcsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNyRSxNQUFNLE9BQU8sR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQztRQUN0QyxNQUFN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LElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUNqQztRQUVELElBQUksa0JBQWtCLEVBQUU7WUFDdEIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsd0JBQXdCLENBQUMsQ0FBQztTQUNuRDtRQUNELElBQUksaUJBQWlCLEVBQUU7WUFDckIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztTQUMzQztRQUVELElBQUksQ0FBQyxRQUFRLEdBQUc7U0FDWixpQkFBaUI7Ozs7Ozs7Ozs7Ozs7V0FhZixRQUFROzs7V0FHUixjQUFjO1dBQ2Qsc0JBQXNCOzs7TUFHM0IsQ0FBQztJQUNKLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuIGltcG9ydCB7YmFja2VuZF91dGlsLCB1dGlsfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuXG4gaW1wb3J0IHtHUEdQVVByb2dyYW0sIHVzZVNoYXBlVW5pZm9ybXN9IGZyb20gJy4vZ3BncHVfbWF0aCc7XG5cbiBleHBvcnQgY2xhc3MgQ29udjJEUGFja2VkUHJvZ3JhbSBpbXBsZW1lbnRzIEdQR1BVUHJvZ3JhbSB7XG4gICB2YXJpYWJsZU5hbWVzID0gWyd4JywgJ1cnXTtcbiAgIHBhY2tlZElucHV0cyA9IHRydWU7XG4gICBwYWNrZWRPdXRwdXQgPSB0cnVlO1xuICAgb3V0cHV0U2hhcGU6IG51bWJlcltdO1xuICAgdXNlckNvZGU6IHN0cmluZztcbiAgIGVuYWJsZVNoYXBlVW5pZm9ybXM6IGJvb2xlYW47XG4gICBjdXN0b21Vbmlmb3JtcyA9IFtcbiAgICAge25hbWU6ICdwYWRzJywgdHlwZTogJ2l2ZWMyJyBhcyBjb25zdCB9LFxuICAgICB7bmFtZTogJ3N0cmlkZXMnLCB0eXBlOiAnaXZlYzInIGFzIGNvbnN0IH0sXG4gICAgIHtuYW1lOiAnZGlsYXRpb25zJywgdHlwZTogJ2l2ZWMyJyBhcyBjb25zdCB9LFxuICAgICB7bmFtZTogJ2luRGltcycsIHR5cGU6ICdpdmVjMicgYXMgY29uc3QgfSxcbiAgIF07XG5cbiAgIGNvbnN0cnVjdG9yKFxuICAgICAgIGNvbnZJbmZvOiBiYWNrZW5kX3V0aWwuQ29udjJESW5mbywgYWRkQmlhcyA9IGZhbHNlLFxuICAgICAgIGFjdGl2YXRpb246IHN0cmluZyA9IG51bGwsIGhhc1ByZWx1QWN0aXZhdGlvbiA9IGZhbHNlLFxuICAgICAgIGhhc0xlYWt5UmVsdUFscGhhID0gZmFsc2UpIHtcbiAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLm91dFNoYXBlO1xuICAgICB0aGlzLmVuYWJsZVNoYXBlVW5pZm9ybXMgPSB1c2VTaGFwZVVuaWZvcm1zKHRoaXMub3V0cHV0U2hhcGUubGVuZ3RoKTtcbiAgICAgY29uc3QgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgY29uc3Qgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgY29uc3QgZGlsYXRpb25XaWR0aCA9IGNvbnZJbmZvLmRpbGF0aW9uV2lkdGg7XG4gICAgIGNvbnN0IGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgY29uc3QgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgY29uc3QgdGV4ZWxzQWNyb3NzID0gZmlsdGVyV2lkdGg7XG5cbiAgICAgbGV0IG1haW5Mb29wID0gYFxuICAgICAgIGludCB4UjsgaW50IHhDOyBpbnQgeENPZmZzZXQ7XG4gICAgICAgdmVjNCB3VGV4ZWw7IHZlYzQgcHJldmlvdXM7IHZlYzQgZmluYWw7YDtcblxuICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGZpbHRlcldpZHRoOyBjKyspIHtcbiAgICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICAgIHZlYzQgeFRleGVsQyR7YyAqIDJ9O1xuICAgICAgICAgICBpbnQgeFRleGVsQyR7YyAqIDJ9UmVhZHk7XG4gICAgICAgICAgIHZlYzQgeFRleGVsQyR7YyAqIDIgKyAxfTtcbiAgICAgICAgICAgaW50IHhUZXhlbEMke2MgKiAyICsgMX1SZWFkeTtcbiAgICAgICAgICAgdmVjNCB4QyR7Y307YDtcbiAgICAgfVxuXG4gICAgIC8qKlxuICAgICAgKiBUaGlzIHZlY3Rvcml6ZWQgaW1wbGVtZW50YXRpb24gd29ya3MgYnkgZ2F0aGVyaW5nIHRoZSB2YWx1ZXMgbmVlZGVkIGZvclxuICAgICAgKiBlYWNoIG91dHB1dCBjaGFubmVsJ3MgZG90IHByb2R1Y3QgaW50byB2ZWM0J3MgYW5kIHRoZW4gbXVsdGlwbHlpbmcgdGhlbVxuICAgICAgKiBhbGwgdG9nZXRoZXIgKHRoaXMgaGFwcGVucyBpbiB0aGUgZmluYWwgZG91YmxlIGZvci1sb29wIGJlbG93KS4gTW9zdCBvZlxuICAgICAgKiB0aGUgbWFpbiBsb29wIGNvbnNpc3RzIG9mIGNvbnN0cnVjdGluZyB0aGVzZSB2ZWM0J3Mgd2l0aCB0aGUgbWluaW11bVxuICAgICAgKiBudW1iZXIgb2YgdGV4dHVyZTJEIGNhbGxzLCB3aGljaCBtZWFucyBtYWtpbmcgdXNlIG9mIGFsbCBmb3VyIHJldHVybmVkXG4gICAgICAqIHZhbHVlcyBmcm9tIGEgdGV4dHVyZTJEIGNhbGwgYXQgb25jZS5cbiAgICAgICovXG4gICAgIG1haW5Mb29wICs9IGBcbiAgICAgZm9yIChpbnQgciA9IDA7IHIgPCAke2ZpbHRlckhlaWdodH07IHIrKykge1xuICAgICAgZm9yIChpbnQgZDEgPSAwOyBkMSA8ICR7Y29udkluZm8uaW5DaGFubmVsc307IGQxICs9IDIpIHtcbiAgICAgICBgO1xuICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGZpbHRlcldpZHRoOyBjKyspIHtcbiAgICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICAgIHhUZXhlbEMke2MgKiAyfSA9IHZlYzQoMC4wKTtcbiAgICAgICAgICAgeFRleGVsQyR7YyAqIDJ9UmVhZHkgPSAwO1xuICAgICAgICAgICB4VGV4ZWxDJHtjICogMiArIDF9ID0gdmVjNCgwLjApO1xuICAgICAgICAgICB4VGV4ZWxDJHtjICogMiArIDF9UmVhZHkgPSAwO1xuICAgICAgICAgICB4QyR7Y30gPSB2ZWM0KDAuMCk7YDtcbiAgICAgfVxuICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICB4UiA9IHhSQ29ybmVyICsgciAqIGRpbGF0aW9uc1swXTtcbiAgICAgICAgIGlmICh4UiA+PTAgJiYgeFIgPCBpbkRpbXNbMF0pIHtcbiAgICAgICBgO1xuXG4gICAgIGZvciAobGV0IHRleGVsQyA9IDA7IHRleGVsQyA8ICh0ZXhlbHNBY3Jvc3MgKyAxKSAvIDI7IHRleGVsQysrKSB7XG4gICAgICAgY29uc3QgY29sSW5kZXggPSB0ZXhlbEMgKiAyO1xuXG4gICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgICB4QyA9IHhDQ29ybmVyICsgJHtjb2xJbmRleCAqIGRpbGF0aW9uV2lkdGh9O1xuICAgICAgICAgICBgO1xuXG4gICAgICAgaWYgKHN0cmlkZVdpZHRoID09PSAxKSB7XG4gICAgICAgICBpZiAoY29sSW5kZXggPCBmaWx0ZXJXaWR0aCkge1xuICAgICAgICAgICAvLyBJZiBwYWRkaW5nIGlzIG9kZCwgdGhlIG91dGVyIHRleGVscyBoYXZlIHRvIGJlIGNvbXBvc2VkLlxuICAgICAgICAgICBpZiAocGFkTGVmdCAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgICAvLyBUT0RPOiBFbnN1cmUgdmVjNCBwcmV2aW91cyBkb2VzIG5vdCByZXN1bHQgaW4gcmVkdW5kYW50IHNhbXBsZSxcbiAgICAgICAgICAgICAvLyBhbmQgYXZvaWQgc2V0dGluZyB4VGV4ZWxSQydzIHRoYXQgZXhjZWVkIHRoZSBib3VuZGFyeSBpbiB0aGVcbiAgICAgICAgICAgICAvLyBmaXJzdCBwbGFjZSByYXRoZXIgdGhhbiByZXNldHRpbmcgdGhlbSB0byB2ZWM0KDApKS5cblxuICAgICAgICAgICAgIC8vIFRvIGNvbXB1dGUgeENPZmZzZXQ6XG4gICAgICAgICAgICAgLy8gLSBJZiBwYWRkaW5nIGlzIG9kZCwgd2UgbXVzdCBhZGQgMSB0byBlbnN1cmUgd2UgYXNrIGZvciBhblxuICAgICAgICAgICAgIC8vIGV2ZW4tbnVtYmVyZWQgcm93LlxuICAgICAgICAgICAgIC8vIC0gV2Ugc3VidHJhY3QgMiB0byBhY2Nlc3MgdGhlIHByZXZpb3VzIHRleGVsLlxuXG4gICAgICAgICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgMTtcbiAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBpbkRpbXNbMV0gJiYgeFRleGVsQyR7XG4gICAgICAgICAgICAgICAgIGNvbEluZGV4fVJlYWR5ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleH0gPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcblxuICAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gbWFudWFsbHkgY2xlYXIgdW51c2VkIGNoYW5uZWxzIGluIGNhc2VcbiAgICAgICAgICAgICAgICAgICAvLyB3ZSdyZSByZWFkaW5nIGZyb20gcmVjeWNsZWQgdGV4dHVyZS5cbiAgICAgICAgICAgICAgICAgICBpZiAoeENPZmZzZXQgKyAxID49IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXh9Lnp3ID0gdmVjMigwLjApO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleH1SZWFkeSA9IDE7XG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGA7XG4gICAgICAgICAgICAgLy8gVGhpcyB0ZXhlbCBoYXMgYmVlbiByZWFkIGluIHByZXZpb3VzIGl0ZXJhdGlvbiBpZiB0aGUgZGlsYXRpb25cbiAgICAgICAgICAgICAvLyBpcyAxLlxuICAgICAgICAgICAgIGlmIChkaWxhdGlvbldpZHRoID09PSAxICYmIGNvbEluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgICAgICAgICB4QyR7Y29sSW5kZXh9ID0gdmVjNCh4VGV4ZWxDJHtjb2xJbmRleCAtIDJ9Lnp3LCB4VGV4ZWxDJHtcbiAgICAgICAgICAgICAgICAgICBjb2xJbmRleH0ueHkpO1xuICAgICAgICAgICAgICAgICBgO1xuICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIDEgLSAyO1xuXG4gICAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gbWFudWFsbHkgY2xlYXIgdW51c2VkIGNoYW5uZWxzIGluIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIHJlYWRpbmcgZnJvbSByZWN5Y2xlZCB0ZXh0dXJlLlxuICAgICAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ICsgMSA+PSBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMuencgPSB2ZWMyKDAuMCk7XG4gICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgIHhDJHtjb2xJbmRleH0gPSB2ZWM0KHByZXZpb3VzLnp3LCB4VGV4ZWxDJHtjb2xJbmRleH0ueHkpO1xuICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICB4QyR7Y29sSW5kZXh9ID0gdmVjNCgwLjAsIDAuMCwgeFRleGVsQyR7Y29sSW5kZXh9Lnh5KTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgYDtcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgLy8gUGFkZGluZyBpcyBldmVuLCBzbyB4UkMgY29ycmVzcG9uZHMgdG8gYSBzaW5nbGUgdGV4ZWwuXG4gICAgICAgICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgICAgICAgICBpZiAoeEMgPj0gMCAmJiB4QyA8IGluRGltc1sxXSAmJiB4VGV4ZWxDJHtjb2xJbmRleH1SZWFkeSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXh9ID0gZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSk7XG4gICAgICAgICAgICAgICAgICAgaWYgKHhDICsgMSA+PSBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2NvbEluZGV4fS56dyA9IHZlYzIoMC4wKTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXh9UmVhZHkgPSAxO1xuICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgeEMke2NvbEluZGV4fSA9IHhUZXhlbEMke2NvbEluZGV4fTtcbiAgICAgICAgICAgICAgICAgYDtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIGlmIChjb2xJbmRleCArIDEgPCBmaWx0ZXJXaWR0aCkge1xuICAgICAgICAgICAgIC8vIElmIGRpbGF0aW9uIGlzIGV2ZW4sIHRoZSBzZWNvbmQgZW50cnkgc2hvdWxkIG1hdGNoIHRoZSBmaXJzdFxuICAgICAgICAgICAgIC8vIChlaXRoZXIgYm90aCBhcmUgY29tcG9zZWQgb3IgYm90aCBhcmUgc2luZ2xlIHNhbXBsZXMpLiBCdXQgaWZcbiAgICAgICAgICAgICAvLyBkaWxhdGlvbiBpcyBvZGQsIHRoZW4gdGhlIHNlY29uZCBlbnRyeSBzaG91bGQgYmUgdGhlIG9wcG9zaXRlXG4gICAgICAgICAgICAgLy8gb2YgdGhlIGZpcnN0IChpZiB0aGUgZmlyc3QgaXMgY29tcG9zZWQsIHRoZSBzZWNvbmQgaXMgYSBzaW5nbGVcbiAgICAgICAgICAgICAvLyBzYW1wbGUsIGFuZCB2aWNlIHZlcnNhLilcblxuICAgICAgICAgICAgIGNvbnN0IG5leHRUZXhlbE9mZnNldCA9IHBhZExlZnQgJSAyID09PSAwID9cbiAgICAgICAgICAgICAgICAgdXRpbC5uZWFyZXN0TGFyZ2VyRXZlbihkaWxhdGlvbldpZHRoKSA6XG4gICAgICAgICAgICAgICAgIGRpbGF0aW9uV2lkdGg7XG5cbiAgICAgICAgICAgICBpZiAoKGRpbGF0aW9uV2lkdGggJSAyID09PSAwICYmIHBhZExlZnQgJSAyID09PSAxKSB8fFxuICAgICAgICAgICAgICAgICAoZGlsYXRpb25XaWR0aCAlIDIgIT09IDAgJiYgcGFkTGVmdCAlIDIgIT09IDEpKSB7XG4gICAgICAgICAgICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIGltb2QocGFkc1sxXSwgMikgKyAke25leHRUZXhlbE9mZnNldH07XG5cbiAgICAgICAgICAgICAgICAgICBpZiAoeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IGluRGltc1sxXSAmJiB4VGV4ZWxDJHtcbiAgICAgICAgICAgICAgICAgICBjb2xJbmRleCArIDF9UmVhZHkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXggKyAxfSA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIG1hbnVhbGx5IGNsZWFyIHVudXNlZCBjaGFubmVscyBpbiBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAvLyB3ZSdyZSByZWFkaW5nIGZyb20gcmVjeWNsZWQgdGV4dHVyZS5cbiAgICAgICAgICAgICAgICAgICAgIGlmICh4Q09mZnNldCArIDEgPj0gaW5EaW1zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2NvbEluZGV4ICsgMX0uencgPSB2ZWMyKDAuMCk7XG4gICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleCArIDF9UmVhZHkgPSAxO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICBgO1xuXG4gICAgICAgICAgICAgICAvLyBJZiBkaWxhdGlvbiA+IDEgdGhlbiB0aGUgeFJDJ3Mgd2lsbCBub3QgYmUgYWJsZSB0byBzaGFyZSBhbnlcbiAgICAgICAgICAgICAgIC8vIHZhbHVlcywgc28gZWFjaCB4UkMgd2lsbCByZXF1aXJlIHR3byB1bmlxdWUgY2FsbHMgdG8gZ2V0WC5cbiAgICAgICAgICAgICAgIGlmIChkaWxhdGlvbldpZHRoID4gMSkge1xuICAgICAgICAgICAgICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICAgICAgICAgICAgICB4Q09mZnNldCAtPSAyO1xuICAgICAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xuICAgICAgICAgICAgICAgICAgICAgIHhDJHtjb2xJbmRleCArIDF9ID0gdmVjNChwcmV2aW91cy56dywgeFRleGVsQyR7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xJbmRleCArIDF9Lnh5KTtcbiAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgeEMke2NvbEluZGV4ICsgMX0gPSB2ZWM0KDAuMCwgMC4wLCB4VGV4ZWxDJHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbEluZGV4ICsgMX0ueHkpO1xuICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgYDtcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgIG1haW5Mb29wICs9IGBcbiAgICAgICAgICAgICAgICAgICAgIHhDJHtjb2xJbmRleCArIDF9ID0gdmVjNCh4VGV4ZWxDJHtjb2xJbmRleH0uencsIHhUZXhlbEMke1xuICAgICAgICAgICAgICAgICAgICAgY29sSW5kZXggKyAxfS54eSk7XG4gICAgICAgICAgICAgICAgICAgICBgO1xuICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIC8vIElmIGRpbGF0aW9uIGlzIDEgYW5kIHBhZGRpbmcgaXMgb2RkLCB3ZSBoYXZlIGFscmVhZHkgcmVhZCB0aGVcbiAgICAgICAgICAgICAgIC8vIHRleGVsIHdoZW4gY29uc3RydWN0aW5nIHRoZSBwcmV2aW91cyB4IHZhbHVlLiBIZXJlIHdlIGNhblxuICAgICAgICAgICAgICAgLy8gc2ltcGx5IHNraXAgdGhlIHRleHR1cmUgcmVhZC5cbiAgICAgICAgICAgICAgIGlmIChuZXh0VGV4ZWxPZmZzZXQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgICAgICAgICAgICAgeEMke2NvbEluZGV4ICsgMX0gPSB4VGV4ZWxDJHtjb2xJbmRleH07XG4gICAgICAgICAgICAgICAgICAgICBgO1xuICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArICR7bmV4dFRleGVsT2Zmc2V0fTtcblxuICAgICAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBpbkRpbXNbMV0gJiYgeFRleGVsQyR7XG4gICAgICAgICAgICAgICAgICAgICBjb2xJbmRleCArIDF9UmVhZHkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleCArIDF9ID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XG4gICAgICAgICAgICAgICAgICAgICAgIGlmICh4Q09mZnNldCArIDEgPj0gaW5EaW1zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXggKyAxfS56dyA9IHZlYzIoMC4wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleCArIDF9UmVhZHkgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICB4QyR7Y29sSW5kZXggKyAxfSA9IHhUZXhlbEMke2NvbEluZGV4ICsgMX07XG4gICAgICAgICAgICAgICAgICAgICBgO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgIH0gZWxzZSB7ICAvLyBzdHJpZGUgPT09IDJcbiAgICAgICAgIGlmIChjb2xJbmRleCA8IGZpbHRlcldpZHRoKSB7XG4gICAgICAgICAgIC8vIERlcGVuZGluZyBvbiB3aGV0aGVyIHBhZExlZnQgaXMgZXZlbiBvciBvZGQsIHdlIHdhbnQgZWl0aGVyIHRoZVxuICAgICAgICAgICAvLyB4eSBvciB6dyBjaGFubmVscyBmcm9tIFggdGV4ZWxzIGZvciB4QyR7Y29sSW5kZXh9LiBJZiBwYWRMZWZ0IGlzXG4gICAgICAgICAgIC8vIGV2ZW4sIHhDJHtjb2xJbmRleCArMX0gaXMgc2ltcGx5IHRoZSB6dyBjaGFubmVscyBvZiB0ZXhlbHMgd2UndmVcbiAgICAgICAgICAgLy8gYWxyZWFkeSBzYW1wbGVkLiBCdXQgaWYgcGFkTGVmdCBpcyBvZGQsIHhDeyRjICsgMX0uencgd2lsbFxuICAgICAgICAgICAvLyBuZWVkIHRvIGNvbWUgZnJvbSB0aGUgeHkgY2hhbm5lbHMgb2YgYSBuZXcgdGV4ZWwsIGhlbmNlIHRoZSBgXG4gICAgICAgICAgIC8vIHZlYzRcbiAgICAgICAgICAgLy8gZmluYWxgIGluaXRpYWxpemVkIGJlbG93LlxuICAgICAgICAgICBpZiAocGFkTGVmdCAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyAxIC0gc3RyaWRlc1sxXTtcbiAgICAgICAgICAgICAgICAgaWYoeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IGluRGltc1sxXSAmJiB4VGV4ZWxDJHtcbiAgICAgICAgICAgICAgICAgY29sSW5kZXh9UmVhZHkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2NvbEluZGV4fSA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xuICAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gbWFudWFsbHkgY2xlYXIgdW51c2VkIGNoYW5uZWxzIGluIGNhc2VcbiAgICAgICAgICAgICAgICAgICAvLyB3ZSdyZSByZWFkaW5nIGZyb20gcmVjeWNsZWQgdGV4dHVyZS5cbiAgICAgICAgICAgICAgICAgICBpZiAoeENPZmZzZXQgKyAxID49IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXh9Lnp3ID0gdmVjMigwLjApO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleH1SZWFkeSA9IDE7XG4gICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICBpZih4QyArIDEgPj0gMCAmJiB4QyArIDEgPCBpbkRpbXNbMV0gJiYgeFRleGVsQyR7XG4gICAgICAgICAgICAgICAgIGNvbEluZGV4ICsgMX1SZWFkeSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXggKyAxfSA9IGdldFgoYmF0Y2gsIHhSLCB4QyArIDEsIGQxKTtcbiAgICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIG1hbnVhbGx5IGNsZWFyIHVudXNlZCBjaGFubmVscyBpbiBjYXNlXG4gICAgICAgICAgICAgICAgICAgLy8gd2UncmUgcmVhZGluZyBmcm9tIHJlY3ljbGVkIHRleHR1cmUuXG4gICAgICAgICAgICAgICAgICAgaWYgKHhDICsgMiA+PSBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2NvbEluZGV4ICsgMX0uencgPSB2ZWMyKDAuMCk7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2NvbEluZGV4ICsgMX1SZWFkeSA9IDE7XG4gICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICB4QyR7Y29sSW5kZXh9ID0gdmVjNCh4VGV4ZWxDJHtjb2xJbmRleH0uencsIHhUZXhlbEMke1xuICAgICAgICAgICAgICAgICBjb2xJbmRleCArIDF9Lnp3KTtcbiAgICAgICAgICAgICAgIGA7XG5cbiAgICAgICAgICAgICBpZiAoY29sSW5kZXggKyAxIDwgZmlsdGVyV2lkdGgpIHtcbiAgICAgICAgICAgICAgIG1haW5Mb29wICs9IGBcbiAgICAgICAgICAgICAgICAgICBmaW5hbCA9IHZlYzQoMC4wKTtcbiAgICAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgMSArIHN0cmlkZXNbMV07XG4gICAgICAgICAgICAgICAgICAgaWYoeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAgZmluYWwgPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgeEMke2NvbEluZGV4ICsgMX0gPSB2ZWM0KHhUZXhlbEMke2NvbEluZGV4ICsgMX0ueHksIGZpbmFsLnh5KTtcbiAgICAgICAgICAgICAgICAgYDtcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgICAgICAgICBpZih4QyA+PSAwICYmIHhDIDwgaW5EaW1zWzFdICYmIHhUZXhlbEMke2NvbEluZGV4fVJlYWR5ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleH0gPSBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxKTtcbiAgICAgICAgICAgICAgICAgICBpZiAoeEMgKyAxID49IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXh9Lnp3ID0gdmVjMigwLjApO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleH1SZWFkeSA9IDE7XG4gICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgc3RyaWRlc1sxXTtcbiAgICAgICAgICAgICAgICAgaWYoeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IGluRGltc1sxXSAmJiB4VGV4ZWxDJHtcbiAgICAgICAgICAgICAgICAgY29sSW5kZXggKyAxfVJlYWR5ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleCArIDF9ID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XG4gICAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ICsgMSA+PSBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2NvbEluZGV4ICsgMX0uencgPSB2ZWMyKDAuKTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXggKyAxfVJlYWR5ID0gMTtcbiAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgIHhDJHtjb2xJbmRleH0gPSB2ZWM0KFxuICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2NvbEluZGV4fS54eSwgeFRleGVsQyR7Y29sSW5kZXggKyAxfS54eSk7XG4gICAgICAgICAgICAgICBgO1xuXG4gICAgICAgICAgICAgaWYgKGNvbEluZGV4ICsgMSA8IGZpbHRlcldpZHRoKSB7XG4gICAgICAgICAgICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICAgICAgICAgICAgeEMke2NvbEluZGV4ICsgMX0gPSB2ZWM0KHhUZXhlbEMke2NvbEluZGV4fS56dywgeFRleGVsQyR7XG4gICAgICAgICAgICAgICAgICAgY29sSW5kZXggKyAxfS56dyk7XG4gICAgICAgICAgICAgICAgIGA7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgLy8gbG9jYWxpemUgdGhlIGRvdFByb2QgYWNjdW11bGF0aW9uIHdpdGhpbiB0aGUgbG9vcCwgdGhlIHRoZW9yeSBpcyBmb3JcbiAgICAgICAvLyBHUFUgd2l0aCBsaW1pdGVkIGNhY2hlLCBhY2N1bXVsYXRlIHN1bSBhY3Jvc3MgbGFyZ2UgYW1vdW50IG9mXG4gICAgICAgLy8gdmVyaWFibGVzIHdpbGwgY2F1c2UgbG90cyBvZiBjYWNoZSBtaXNzZXMuIChpLmUuIDV4NSBmaWx0ZXIgd2lsbCBoYXZlXG4gICAgICAgLy8gNTAgdmFyaWFibGVzKVxuICAgICAgIGlmIChjb2xJbmRleCA8IGZpbHRlcldpZHRoKSB7XG4gICAgICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICAgICAgd1RleGVsID0gZ2V0VyhyLCAke2NvbEluZGV4fSwgZDEsIGQyKTtcbiAgICAgICAgICAgICBkb3RQcm9kICs9IHhDJHtjb2xJbmRleH0ueHh6eiAqIHZlYzQod1RleGVsLnh5LCB3VGV4ZWwueHkpO1xuICAgICAgICAgICAgIGlmKGQxICsgMSA8ICR7Y29udkluZm8uaW5DaGFubmVsc30pIHtcbiAgICAgICAgICAgICAgIGRvdFByb2QgKz0geEMke2NvbEluZGV4fS55eXd3ICogdmVjNCh3VGV4ZWwuencsIHdUZXhlbC56dyk7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICBgO1xuXG4gICAgICAgICBpZiAoY29sSW5kZXggKyAxIDwgZmlsdGVyV2lkdGgpIHtcbiAgICAgICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgICAgICAgd1RleGVsID0gZ2V0VyhyLCAke2NvbEluZGV4ICsgMX0sIGQxLCBkMik7XG4gICAgICAgICAgICAgICBkb3RQcm9kICs9IHhDJHtjb2xJbmRleCArIDF9Lnh4enogKiB2ZWM0KHdUZXhlbC54eSwgd1RleGVsLnh5KTtcbiAgICAgICAgICAgICAgIGlmKGQxICsgMSA8ICR7Y29udkluZm8uaW5DaGFubmVsc30pIHtcbiAgICAgICAgICAgICAgICAgZG90UHJvZCArPSB4QyR7Y29sSW5kZXggKyAxfS55eXd3ICogdmVjNCh3VGV4ZWwuencsIHdUZXhlbC56dyk7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgYDtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH1cbiAgICAgbWFpbkxvb3AgKz0gYFxuICAgICB9XG4gICBgO1xuICAgbWFpbkxvb3AgKz0gYFxuICAgICB9XG4gICBgO1xuICAgbWFpbkxvb3AgKz0gYFxuICAgICB9XG4gICBgO1xuXG4gICAgIGxldCBhY3RpdmF0aW9uU25pcHBldCA9ICcnLCBhcHBseUFjdGl2YXRpb25TbmlwcGV0ID0gJyc7XG4gICAgIGlmIChhY3RpdmF0aW9uKSB7XG4gICAgICAgaWYgKGhhc1ByZWx1QWN0aXZhdGlvbikge1xuICAgICAgICAgYWN0aXZhdGlvblNuaXBwZXQgPSBgdmVjNCBhY3RpdmF0aW9uKHZlYzQgYSkge1xuICAgICAgICAgICB2ZWM0IGIgPSBnZXRQcmVsdUFjdGl2YXRpb25XZWlnaHRzQXRPdXRDb29yZHMoKTtcbiAgICAgICAgICAgJHthY3RpdmF0aW9ufVxuICAgICAgICAgfWA7XG4gICAgICAgfSBlbHNlIGlmIChoYXNMZWFreVJlbHVBbHBoYSkge1xuICAgICAgICAgYWN0aXZhdGlvblNuaXBwZXQgPSBgdmVjNCBhY3RpdmF0aW9uKHZlYzQgYSkge1xuICAgICAgICAgICB2ZWM0IGIgPSBnZXRMZWFreXJlbHVBbHBoYUF0T3V0Q29vcmRzKCk7XG4gICAgICAgICAgICR7YWN0aXZhdGlvbn1cbiAgICAgICAgIH1gO1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICBhY3RpdmF0aW9uU25pcHBldCA9IGB2ZWM0IGFjdGl2YXRpb24odmVjNCB4KSB7XG4gICAgICAgICAgICR7YWN0aXZhdGlvbn1cbiAgICAgICAgIH1gO1xuICAgICAgIH1cblxuICAgICAgIGFwcGx5QWN0aXZhdGlvblNuaXBwZXQgPSBgcmVzdWx0ID0gYWN0aXZhdGlvbihyZXN1bHQpO2A7XG4gICAgIH1cblxuICAgICBjb25zdCBhZGRCaWFzU25pcHBldCA9IGFkZEJpYXMgPyAncmVzdWx0ICs9IGdldEJpYXNBdE91dENvb3JkcygpOycgOiAnJztcbiAgICAgaWYgKGFkZEJpYXMpIHtcbiAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgnYmlhcycpO1xuICAgICB9XG5cbiAgICAgaWYgKGhhc1ByZWx1QWN0aXZhdGlvbikge1xuICAgICAgIHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKCdwcmVsdUFjdGl2YXRpb25XZWlnaHRzJyk7XG4gICAgIH1cbiAgICAgaWYgKGhhc0xlYWt5UmVsdUFscGhhKSB7XG4gICAgICAgdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goJ2xlYWt5cmVsdUFscGhhJyk7XG4gICAgIH1cblxuICAgICB0aGlzLnVzZXJDb2RlID0gYFxuICAgICAgICR7YWN0aXZhdGlvblNuaXBwZXR9XG5cbiAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xuICAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XG4gICAgICAgICBpbnQgZDIgPSBjb29yZHMudztcbiAgICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xuICAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XG5cbiAgICAgICAgIC8vaW50aWFsaXplIGRvdFByb2Qgd2l0aCBhIHNtYWxsIGVwc2lsb24gc2VlbXMgdG8gcmVkdWNlIEdQVSBhY2N1cmFjeSBsb3NzLlxuICAgICAgICAgdmVjNCBkb3RQcm9kID0gdmVjNCgwLjAwMDAwMDAwMDAwMDAwMSk7XG5cbiAgICAgICAgICR7bWFpbkxvb3B9XG5cbiAgICAgICAgIHZlYzQgcmVzdWx0ID0gZG90UHJvZCAtIHZlYzQoMC4wMDAwMDAwMDAwMDAwMDEpO1xuICAgICAgICAgJHthZGRCaWFzU25pcHBldH1cbiAgICAgICAgICR7YXBwbHlBY3RpdmF0aW9uU25pcHBldH1cbiAgICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xuICAgICAgIH1cbiAgICAgYDtcbiAgIH1cbiB9XG4iXX0=","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { useShapeUniforms } from './gpgpu_math';\nexport class DepthwiseConvPacked2DProgram {\n    constructor(convInfo, addBias = false, activation = null, hasPreluActivation = false, hasLeakyReluAlpha = false) {\n        this.variableNames = ['x', 'W'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.customUniforms = [\n            { name: 'pads', type: 'ivec2' },\n            { name: 'strides', type: 'ivec2' },\n            { name: 'dilations', type: 'ivec2' },\n            { name: 'inDims', type: 'ivec2' },\n        ];\n        this.outputShape = convInfo.outShape;\n        this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);\n        const channelMul = convInfo.outChannels / convInfo.inChannels;\n        const padLeft = convInfo.padInfo.left;\n        const strideWidth = convInfo.strideWidth;\n        const dilationWidth = convInfo.dilationWidth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const texelsAcross = filterWidth;\n        let mainLoop = `\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;`;\n        for (let c = 0; c < filterWidth; c++) {\n            mainLoop += `\n          vec4 xTexelC${c * 2};\n          int xTexelC${c * 2}Ready;\n          vec4 xTexelC${c * 2 + 1};\n          int xTexelC${c * 2 + 1}Ready;\n          vec4 xC${c};`;\n        }\n        /**\n         * This vectorized implementation works by gathering the values needed for\n         * each output channel's dot product into vec4's and then multiplying them\n         * all together (this happens in the final double for-loop below). Most of\n         * the main loop consists of constructing these vec4's with the minimum\n         * number of texture2D calls, which means making use of all four returned\n         * values from a texture2D call at once.\n         */\n        mainLoop += `\n    for (int r = 0; r < ${filterHeight}; r++) {\n      `;\n        for (let c = 0; c < filterWidth; c++) {\n            mainLoop += `\n          xTexelC${c * 2} = vec4(0.0);\n          xTexelC${c * 2}Ready = 0;\n          xTexelC${c * 2 + 1} = vec4(0.0);\n          xTexelC${c * 2 + 1}Ready = 0;\n          xC${c} = vec4(0.0);`;\n        }\n        mainLoop += `\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      `;\n        for (let texelC = 0; texelC < (texelsAcross + 1) / 2; texelC++) {\n            const colIndex = texelC * 2;\n            mainLoop += `\n          xC = xCCorner + ${colIndex * dilationWidth};\n          `;\n            if (strideWidth === 1) {\n                if (colIndex < filterWidth) {\n                    // If padding is odd, the outer texels have to be composed.\n                    if (padLeft % 2 === 1) {\n                        // TODO: Ensure vec4 previous does not result in redundant sample,\n                        // and avoid setting xTexelRC's that exceed the boundary in the\n                        // first place rather than resetting them to vec4(0)).\n                        // To compute xCOffset:\n                        // - If padding is odd, we must add 1 to ensure we ask for an\n                        // even-numbered row.\n                        // - We subtract 2 to access the previous texel.\n                        mainLoop += `\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex}Ready == 0) {\n                  xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${colIndex}.zw = vec2(0.0);\n                  }\n                  xTexelC${colIndex}Ready = 1;\n                }\n              `;\n                        // This texel has been read in previous iteration if the dilation\n                        // is 1.\n                        if (dilationWidth === 1 && colIndex > 0) {\n                            mainLoop += `\n                xC${colIndex} = vec4(xTexelC${colIndex - 2}.zw, xTexelC${colIndex}.xy);\n                `;\n                        }\n                        else {\n                            mainLoop += `\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${colIndex} = vec4(previous.zw, xTexelC${colIndex}.xy);\n                  } else {\n                    xC${colIndex} = vec4(0.0, 0.0, xTexelC${colIndex}.xy);\n                  }\n                  `;\n                        }\n                    }\n                    else {\n                        // Padding is even, so xRC corresponds to a single texel.\n                        mainLoop += `\n                if (xC >= 0 && xC < inDims[1] && xTexelC${colIndex}Ready == 0) {\n                  xTexelC${colIndex} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${colIndex}.zw = vec2(0.0);\n                  }\n                  xTexelC${colIndex}Ready = 1;\n                }\n\n                xC${colIndex} = xTexelC${colIndex};\n                `;\n                    }\n                    if (colIndex + 1 < filterWidth) {\n                        // If dilation is even, the second entry should match the first\n                        // (either both are composed or both are single samples). But if\n                        // dilation is odd, then the second entry should be the opposite\n                        // of the first (if the first is composed, the second is a single\n                        // sample, and vice versa.)\n                        const nextTexelOffset = padLeft % 2 === 0 ?\n                            util.nearestLargerEven(dilationWidth) :\n                            dilationWidth;\n                        if ((dilationWidth % 2 === 0 && padLeft % 2 === 1) ||\n                            (dilationWidth % 2 !== 0 && padLeft % 2 !== 1)) {\n                            mainLoop += `\n                  xCOffset = xC + imod(pads[1], 2) + ${nextTexelOffset};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {\n                    xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${colIndex + 1}.zw = vec2(0.0);\n                    }\n                    xTexelC${colIndex + 1}Ready = 1;\n                  }\n                  `;\n                            // If dilation > 1 then the xRC's will not be able to share any\n                            // values, so each xRC will require two unique calls to getX.\n                            if (dilationWidth > 1) {\n                                mainLoop += `\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${colIndex + 1} = vec4(previous.zw, xTexelC${colIndex + 1}.xy);\n                    } else {\n                     xC${colIndex + 1} = vec4(0.0, 0.0, xTexelC${colIndex + 1}.xy);\n                    }\n                    `;\n                            }\n                            else {\n                                mainLoop += `\n                    xC${colIndex + 1} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.xy);\n                    `;\n                            }\n                        }\n                        else {\n                            // If dilation is 1 and padding is odd, we have already read the\n                            // texel when constructing the previous x value. Here we can\n                            // simply skip the texture read.\n                            if (nextTexelOffset === 1) {\n                                mainLoop += `\n                    xC${colIndex + 1} = xTexelC${colIndex};\n                    `;\n                            }\n                            else {\n                                mainLoop += `\n                    xCOffset = xC + ${nextTexelOffset};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {\n                      xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${colIndex + 1}.zw = vec2(0.0);\n                      }\n                      xTexelC${colIndex + 1}Ready = 1;\n                    }\n\n                    xC${colIndex + 1} = xTexelC${colIndex + 1};\n                    `;\n                            }\n                        }\n                    }\n                }\n            }\n            else { // stride === 2\n                if (colIndex < filterWidth) {\n                    // Depending on whether padLeft is even or odd, we want either the\n                    // xy or zw channels from X texels for xC${colIndex}. If padLeft is\n                    // even, xC${colIndex +1} is simply the zw channels of texels we've\n                    // already sampled. But if padLeft is odd, xC{$c + 1}.zw will\n                    // need to come from the xy channels of a new texel, hence the `\n                    // vec4\n                    // final` initialized below.\n                    if (padLeft % 2 === 1) {\n                        mainLoop += `\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex}Ready == 0) {\n                  xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${colIndex}.zw = vec2(0.0);\n                  }\n                  xTexelC${colIndex}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {\n                  xTexelC${colIndex + 1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${colIndex + 1}.zw = vec2(0.0);\n                  }\n                  xTexelC${colIndex + 1}Ready = 1;\n                }\n\n                xC${colIndex} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.zw);\n              `;\n                        if (colIndex + 1 < filterWidth) {\n                            mainLoop += `\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${colIndex + 1} = vec4(xTexelC${colIndex + 1}.xy, final.xy);\n                `;\n                        }\n                    }\n                    else {\n                        mainLoop += `\n                if(xC >= 0 && xC < inDims[1] && xTexelC${colIndex}Ready == 0) {\n                  xTexelC${colIndex} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${colIndex}.zw = vec2(0.0);\n                  }\n                  xTexelC${colIndex}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {\n                  xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${colIndex + 1}.zw = vec2(0.);\n                  }\n                  xTexelC${colIndex + 1}Ready = 1;\n                }\n\n                xC${colIndex} = vec4(\n                  xTexelC${colIndex}.xy, xTexelC${colIndex + 1}.xy);\n              `;\n                        if (colIndex + 1 < filterWidth) {\n                            mainLoop += `\n                  xC${colIndex + 1} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.zw);\n                `;\n                        }\n                    }\n                }\n            }\n            // localize the dotProd accumulation within the loop, the theory is for\n            // GPU with limited cache, accumulate sum across large amount of\n            // veriables will cause lots of cache misses. (i.e. 5x5 filter will have\n            // 50 variables)\n            if (colIndex < filterWidth) {\n                mainLoop += `\n            wTexel = getW(r, ${colIndex}, d1, q);\n            dotProd += xC${colIndex} * vec4(wTexel.xz, wTexel.xz);\n          `;\n                if (colIndex + 1 < filterWidth) {\n                    mainLoop += `\n              wTexel = getW(r, ${colIndex + 1}, d1, q);\n              dotProd += xC${colIndex + 1} * vec4(wTexel.xz, wTexel.xz);\n            `;\n                }\n            }\n        }\n        mainLoop += `\n    }\n  `;\n        mainLoop += `\n      }\n    `;\n        let activationSnippet = '', applyActivationSnippet = '';\n        if (activation) {\n            if (hasPreluActivation) {\n                activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else if (hasLeakyReluAlpha) {\n                activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else {\n                activationSnippet = `vec4 activation(vec4 x) {\n          ${activation}\n        }`;\n            }\n            applyActivationSnippet = `result = activation(result);`;\n        }\n        const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n        if (addBias) {\n            this.variableNames.push('bias');\n        }\n        if (hasPreluActivation) {\n            this.variableNames.push('preluActivationWeights');\n        }\n        if (hasLeakyReluAlpha) {\n            this.variableNames.push('leakyreluAlpha');\n        }\n        this.userCode = `\n      ${activationSnippet}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${channelMul};\n        int q = d2 - d1 * ${channelMul};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${mainLoop}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udl9wYWNrZWRfZ3B1X2RlcHRod2lzZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RmanMtYmFja2VuZC13ZWJnbC9zcmMvY29udl9wYWNrZWRfZ3B1X2RlcHRod2lzZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQWUsSUFBSSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFekQsT0FBTyxFQUFlLGdCQUFnQixFQUFDLE1BQU0sY0FBYyxDQUFDO0FBRTVELE1BQU0sT0FBTyw0QkFBNEI7SUFjdkMsWUFDSSxRQUFpQyxFQUFFLE9BQU8sR0FBRyxLQUFLLEVBQ2xELGFBQXFCLElBQUksRUFBRSxrQkFBa0IsR0FBRyxLQUFLLEVBQ3JELGlCQUFpQixHQUFHLEtBQUs7UUFoQjdCLGtCQUFhLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDM0IsaUJBQVksR0FBRyxJQUFJLENBQUM7UUFDcEIsaUJBQVksR0FBRyxJQUFJLENBQUM7UUFJcEIsbUJBQWMsR0FBRztZQUNmLEVBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsT0FBZ0IsRUFBRTtZQUN2QyxFQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLE9BQWdCLEVBQUU7WUFDMUMsRUFBQyxJQUFJLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRSxPQUFnQixFQUFFO1lBQzVDLEVBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsT0FBZ0IsRUFBRTtTQUMxQyxDQUFDO1FBTUEsSUFBSSxDQUFDLFdBQVcsR0FBRyxRQUFRLENBQUMsUUFBUSxDQUFDO1FBQ3JDLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3JFLE1BQU0sVUFBVSxHQUFHLFFBQVEsQ0FBQyxXQUFXLEdBQUcsUUFBUSxDQUFDLFVBQVUsQ0FBQztRQUM5RCxNQUFNLE9BQU8sR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQztRQUN0QyxNQUFNLFdBQVcsR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDO1FBQ3pDLE1BQU0sYUFBYSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUM7UUFDN0MsTUFBTSxZQUFZLEdBQUcsUUFBUSxDQUFDLFlBQVksQ0FBQztRQUMzQyxNQUFNLFdBQVcsR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDO1FBQ3pDLE1BQU0sWUFBWSxHQUFHLFdBQVcsQ0FBQztRQUVqQyxJQUFJLFFBQVEsR0FBRzs7OENBRTJCLENBQUM7UUFFM0MsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFdBQVcsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNwQyxRQUFRLElBQUk7d0JBQ00sQ0FBQyxHQUFHLENBQUM7dUJBQ04sQ0FBQyxHQUFHLENBQUM7d0JBQ0osQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO3VCQUNWLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQzttQkFDYixDQUFDLEdBQUcsQ0FBQztTQUNuQjtRQUVEOzs7Ozs7O1dBT0c7UUFDSCxRQUFRLElBQUk7MEJBQ1UsWUFBWTtPQUMvQixDQUFDO1FBQ0osS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFdBQVcsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNwQyxRQUFRLElBQUk7bUJBQ0MsQ0FBQyxHQUFHLENBQUM7bUJBQ0wsQ0FBQyxHQUFHLENBQUM7bUJBQ0wsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO21CQUNULENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQztjQUNkLENBQUMsZUFBZSxDQUFDO1NBQzFCO1FBQ0QsUUFBUSxJQUFJOzs7T0FHVCxDQUFDO1FBRUosS0FBSyxJQUFJLE1BQU0sR0FBRyxDQUFDLEVBQUUsTUFBTSxHQUFHLENBQUMsWUFBWSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxNQUFNLEVBQUUsRUFBRTtZQUM5RCxNQUFNLFFBQVEsR0FBRyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1lBRTVCLFFBQVEsSUFBSTs0QkFDVSxRQUFRLEdBQUcsYUFBYTtXQUN6QyxDQUFDO1lBRU4sSUFBSSxXQUFXLEtBQUssQ0FBQyxFQUFFO2dCQUNyQixJQUFJLFFBQVEsR0FBRyxXQUFXLEVBQUU7b0JBQzFCLDJEQUEyRDtvQkFDM0QsSUFBSSxPQUFPLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRTt3QkFDckIsa0VBQWtFO3dCQUNsRSwrREFBK0Q7d0JBQy9ELHNEQUFzRDt3QkFFdEQsdUJBQXVCO3dCQUN2Qiw2REFBNkQ7d0JBQzdELHFCQUFxQjt3QkFDckIsZ0RBQWdEO3dCQUVoRCxRQUFRLElBQUk7O3NFQUdSLFFBQVE7MkJBQ0csUUFBUTs7Ozs7NkJBS04sUUFBUTs7MkJBRVYsUUFBUTs7ZUFFcEIsQ0FBQzt3QkFDSixpRUFBaUU7d0JBQ2pFLFFBQVE7d0JBQ1IsSUFBSSxhQUFhLEtBQUssQ0FBQyxJQUFJLFFBQVEsR0FBRyxDQUFDLEVBQUU7NEJBQ3ZDLFFBQVEsSUFBSTtvQkFDTixRQUFRLGtCQUFrQixRQUFRLEdBQUcsQ0FBQyxlQUN4QyxRQUFRO2lCQUNULENBQUM7eUJBQ0w7NkJBQU07NEJBQ0wsUUFBUSxJQUFJOzs7Ozs7Ozs7Ozs7d0JBWUYsUUFBUSwrQkFBK0IsUUFBUTs7d0JBRS9DLFFBQVEsNEJBQTRCLFFBQVE7O21CQUVqRCxDQUFDO3lCQUNQO3FCQUNGO3lCQUFNO3dCQUNMLHlEQUF5RDt3QkFDekQsUUFBUSxJQUFJOzBEQUNrQyxRQUFROzJCQUN2QyxRQUFROzs2QkFFTixRQUFROzsyQkFFVixRQUFROzs7b0JBR2YsUUFBUSxhQUFhLFFBQVE7aUJBQ2hDLENBQUM7cUJBQ1A7b0JBRUQsSUFBSSxRQUFRLEdBQUcsQ0FBQyxHQUFHLFdBQVcsRUFBRTt3QkFDOUIsK0RBQStEO3dCQUMvRCxnRUFBZ0U7d0JBQ2hFLGdFQUFnRTt3QkFDaEUsaUVBQWlFO3dCQUNqRSwyQkFBMkI7d0JBRTNCLE1BQU0sZUFBZSxHQUFHLE9BQU8sR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7NEJBQ3ZDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDOzRCQUN2QyxhQUFhLENBQUM7d0JBRWxCLElBQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxPQUFPLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQzs0QkFDOUMsQ0FBQyxhQUFhLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxPQUFPLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFOzRCQUNsRCxRQUFRLElBQUk7dURBQzZCLGVBQWU7O3dFQUdwRCxRQUFRLEdBQUcsQ0FBQzs2QkFDRCxRQUFRLEdBQUcsQ0FBQzs7Ozs7K0JBS1YsUUFBUSxHQUFHLENBQUM7OzZCQUVkLFFBQVEsR0FBRyxDQUFDOzttQkFFdEIsQ0FBQzs0QkFFTiwrREFBK0Q7NEJBQy9ELDZEQUE2RDs0QkFDN0QsSUFBSSxhQUFhLEdBQUcsQ0FBQyxFQUFFO2dDQUNyQixRQUFRLElBQUk7Ozs7eUJBSUgsUUFBUSxHQUFHLENBQUMsK0JBQ2QsUUFBUSxHQUFHLENBQUM7O3lCQUVWLFFBQVEsR0FBRyxDQUFDLDRCQUNkLFFBQVEsR0FBRyxDQUFDOztxQkFFZCxDQUFDOzZCQUNQO2lDQUFNO2dDQUNMLFFBQVEsSUFBSTt3QkFDSixRQUFRLEdBQUcsQ0FBQyxrQkFBa0IsUUFBUSxlQUMxQyxRQUFRLEdBQUcsQ0FBQztxQkFDWCxDQUFDOzZCQUNQO3lCQUNGOzZCQUFNOzRCQUNMLGdFQUFnRTs0QkFDaEUsNERBQTREOzRCQUM1RCxnQ0FBZ0M7NEJBQ2hDLElBQUksZUFBZSxLQUFLLENBQUMsRUFBRTtnQ0FDekIsUUFBUSxJQUFJO3dCQUNKLFFBQVEsR0FBRyxDQUFDLGFBQWEsUUFBUTtxQkFDcEMsQ0FBQzs2QkFDUDtpQ0FBTTtnQ0FDTCxRQUFRLElBQUk7c0NBQ1UsZUFBZTs7MEVBR2pDLFFBQVEsR0FBRyxDQUFDOytCQUNELFFBQVEsR0FBRyxDQUFDOztpQ0FFVixRQUFRLEdBQUcsQ0FBQzs7K0JBRWQsUUFBUSxHQUFHLENBQUM7Ozt3QkFHbkIsUUFBUSxHQUFHLENBQUMsYUFBYSxRQUFRLEdBQUcsQ0FBQztxQkFDeEMsQ0FBQzs2QkFDUDt5QkFDRjtxQkFDRjtpQkFDRjthQUNGO2lCQUFNLEVBQUcsZUFBZTtnQkFDdkIsSUFBSSxRQUFRLEdBQUcsV0FBVyxFQUFFO29CQUMxQixrRUFBa0U7b0JBQ2xFLG1FQUFtRTtvQkFDbkUsbUVBQW1FO29CQUNuRSw2REFBNkQ7b0JBQzdELGdFQUFnRTtvQkFDaEUsT0FBTztvQkFDUCw0QkFBNEI7b0JBQzVCLElBQUksT0FBTyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUU7d0JBQ3JCLFFBQVEsSUFBSTs7cUVBR1IsUUFBUTsyQkFDRyxRQUFROzs7OzZCQUlOLFFBQVE7OzJCQUVWLFFBQVE7OztpRUFJbkIsUUFBUSxHQUFHLENBQUM7MkJBQ0QsUUFBUSxHQUFHLENBQUM7Ozs7NkJBSVYsUUFBUSxHQUFHLENBQUM7OzJCQUVkLFFBQVEsR0FBRyxDQUFDOzs7b0JBR25CLFFBQVEsa0JBQWtCLFFBQVEsZUFDdEMsUUFBUSxHQUFHLENBQUM7ZUFDYixDQUFDO3dCQUVKLElBQUksUUFBUSxHQUFHLENBQUMsR0FBRyxXQUFXLEVBQUU7NEJBQzlCLFFBQVEsSUFBSTs7Ozs7O3NCQU1KLFFBQVEsR0FBRyxDQUFDLGtCQUFrQixRQUFRLEdBQUcsQ0FBQztpQkFDL0MsQ0FBQzt5QkFDTDtxQkFDRjt5QkFBTTt3QkFDTCxRQUFRLElBQUk7eURBQ2lDLFFBQVE7MkJBQ3RDLFFBQVE7OzZCQUVOLFFBQVE7OzJCQUVWLFFBQVE7Ozs7cUVBS25CLFFBQVEsR0FBRyxDQUFDOzJCQUNELFFBQVEsR0FBRyxDQUFDOzs2QkFFVixRQUFRLEdBQUcsQ0FBQzs7MkJBRWQsUUFBUSxHQUFHLENBQUM7OztvQkFHbkIsUUFBUTsyQkFDRCxRQUFRLGVBQWUsUUFBUSxHQUFHLENBQUM7ZUFDL0MsQ0FBQzt3QkFFSixJQUFJLFFBQVEsR0FBRyxDQUFDLEdBQUcsV0FBVyxFQUFFOzRCQUM5QixRQUFRLElBQUk7c0JBQ0osUUFBUSxHQUFHLENBQUMsa0JBQWtCLFFBQVEsZUFDMUMsUUFBUSxHQUFHLENBQUM7aUJBQ2IsQ0FBQzt5QkFDTDtxQkFDRjtpQkFDRjthQUNGO1lBRUQsdUVBQXVFO1lBQ3ZFLGdFQUFnRTtZQUNoRSx3RUFBd0U7WUFDeEUsZ0JBQWdCO1lBQ2hCLElBQUksUUFBUSxHQUFHLFdBQVcsRUFBRTtnQkFDMUIsUUFBUSxJQUFJOytCQUNXLFFBQVE7MkJBQ1osUUFBUTtXQUN4QixDQUFDO2dCQUVKLElBQUksUUFBUSxHQUFHLENBQUMsR0FBRyxXQUFXLEVBQUU7b0JBQzlCLFFBQVEsSUFBSTtpQ0FDVyxRQUFRLEdBQUcsQ0FBQzs2QkFDaEIsUUFBUSxHQUFHLENBQUM7YUFDNUIsQ0FBQztpQkFDTDthQUNGO1NBQ0Y7UUFDRCxRQUFRLElBQUk7O0dBRWIsQ0FBQztRQUNBLFFBQVEsSUFBSTs7S0FFWCxDQUFDO1FBRUYsSUFBSSxpQkFBaUIsR0FBRyxFQUFFLEVBQUUsc0JBQXNCLEdBQUcsRUFBRSxDQUFDO1FBQ3hELElBQUksVUFBVSxFQUFFO1lBQ2QsSUFBSSxrQkFBa0IsRUFBRTtnQkFDdEIsaUJBQWlCLEdBQUc7O1lBRWhCLFVBQVU7VUFDWixDQUFDO2FBQ0o7aUJBQU0sSUFBSSxpQkFBaUIsRUFBRTtnQkFDNUIsaUJBQWlCLEdBQUc7O1lBRWhCLFVBQVU7VUFDWixDQUFDO2FBQ0o7aUJBQU07Z0JBQ0wsaUJBQWlCLEdBQUc7WUFDaEIsVUFBVTtVQUNaLENBQUM7YUFDSjtZQUVELHNCQUFzQixHQUFHLDhCQUE4QixDQUFDO1NBQ3pEO1FBRUQsTUFBTSxjQUFjLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ3hFLElBQUksT0FBTyxFQUFFO1lBQ1gsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDakM7UUFFRCxJQUFJLGtCQUFrQixFQUFFO1lBQ3RCLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLHdCQUF3QixDQUFDLENBQUM7U0FDbkQ7UUFDRCxJQUFJLGlCQUFpQixFQUFFO1lBQ3JCLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7U0FDM0M7UUFFRCxJQUFJLENBQUMsUUFBUSxHQUFHO1FBQ1osaUJBQWlCOzs7Ozs7O3dCQU9ELFVBQVU7NEJBQ04sVUFBVTs7Ozs7OztVQU81QixRQUFROzs7VUFHUixjQUFjO1VBQ2Qsc0JBQXNCOzs7S0FHM0IsQ0FBQztJQUNKLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtiYWNrZW5kX3V0aWwsIHV0aWx9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmltcG9ydCB7R1BHUFVQcm9ncmFtLCB1c2VTaGFwZVVuaWZvcm1zfSBmcm9tICcuL2dwZ3B1X21hdGgnO1xuXG5leHBvcnQgY2xhc3MgRGVwdGh3aXNlQ29udlBhY2tlZDJEUHJvZ3JhbSBpbXBsZW1lbnRzIEdQR1BVUHJvZ3JhbSB7XG4gIHZhcmlhYmxlTmFtZXMgPSBbJ3gnLCAnVyddO1xuICBwYWNrZWRJbnB1dHMgPSB0cnVlO1xuICBwYWNrZWRPdXRwdXQgPSB0cnVlO1xuICBvdXRwdXRTaGFwZTogbnVtYmVyW107XG4gIHVzZXJDb2RlOiBzdHJpbmc7XG4gIGVuYWJsZVNoYXBlVW5pZm9ybXM6IGJvb2xlYW47XG4gIGN1c3RvbVVuaWZvcm1zID0gW1xuICAgIHtuYW1lOiAncGFkcycsIHR5cGU6ICdpdmVjMicgYXMgY29uc3QgfSxcbiAgICB7bmFtZTogJ3N0cmlkZXMnLCB0eXBlOiAnaXZlYzInIGFzIGNvbnN0IH0sXG4gICAge25hbWU6ICdkaWxhdGlvbnMnLCB0eXBlOiAnaXZlYzInIGFzIGNvbnN0IH0sXG4gICAge25hbWU6ICdpbkRpbXMnLCB0eXBlOiAnaXZlYzInIGFzIGNvbnN0IH0sXG4gIF07XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBjb252SW5mbzogYmFja2VuZF91dGlsLkNvbnYyREluZm8sIGFkZEJpYXMgPSBmYWxzZSxcbiAgICAgIGFjdGl2YXRpb246IHN0cmluZyA9IG51bGwsIGhhc1ByZWx1QWN0aXZhdGlvbiA9IGZhbHNlLFxuICAgICAgaGFzTGVha3lSZWx1QWxwaGEgPSBmYWxzZSkge1xuICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5vdXRTaGFwZTtcbiAgICB0aGlzLmVuYWJsZVNoYXBlVW5pZm9ybXMgPSB1c2VTaGFwZVVuaWZvcm1zKHRoaXMub3V0cHV0U2hhcGUubGVuZ3RoKTtcbiAgICBjb25zdCBjaGFubmVsTXVsID0gY29udkluZm8ub3V0Q2hhbm5lbHMgLyBjb252SW5mby5pbkNoYW5uZWxzO1xuICAgIGNvbnN0IHBhZExlZnQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgY29uc3Qgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICBjb25zdCBkaWxhdGlvbldpZHRoID0gY29udkluZm8uZGlsYXRpb25XaWR0aDtcbiAgICBjb25zdCBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgY29uc3QgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICBjb25zdCB0ZXhlbHNBY3Jvc3MgPSBmaWx0ZXJXaWR0aDtcblxuICAgIGxldCBtYWluTG9vcCA9IGBcbiAgICAgIGludCB4UjsgaW50IHhDOyBpbnQgeENPZmZzZXQ7XG4gICAgICB2ZWM0IHdUZXhlbDsgdmVjNCBwcmV2aW91czsgdmVjNCBmaW5hbDtgO1xuXG4gICAgZm9yIChsZXQgYyA9IDA7IGMgPCBmaWx0ZXJXaWR0aDsgYysrKSB7XG4gICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICAgdmVjNCB4VGV4ZWxDJHtjICogMn07XG4gICAgICAgICAgaW50IHhUZXhlbEMke2MgKiAyfVJlYWR5O1xuICAgICAgICAgIHZlYzQgeFRleGVsQyR7YyAqIDIgKyAxfTtcbiAgICAgICAgICBpbnQgeFRleGVsQyR7YyAqIDIgKyAxfVJlYWR5O1xuICAgICAgICAgIHZlYzQgeEMke2N9O2A7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyB2ZWN0b3JpemVkIGltcGxlbWVudGF0aW9uIHdvcmtzIGJ5IGdhdGhlcmluZyB0aGUgdmFsdWVzIG5lZWRlZCBmb3JcbiAgICAgKiBlYWNoIG91dHB1dCBjaGFubmVsJ3MgZG90IHByb2R1Y3QgaW50byB2ZWM0J3MgYW5kIHRoZW4gbXVsdGlwbHlpbmcgdGhlbVxuICAgICAqIGFsbCB0b2dldGhlciAodGhpcyBoYXBwZW5zIGluIHRoZSBmaW5hbCBkb3VibGUgZm9yLWxvb3AgYmVsb3cpLiBNb3N0IG9mXG4gICAgICogdGhlIG1haW4gbG9vcCBjb25zaXN0cyBvZiBjb25zdHJ1Y3RpbmcgdGhlc2UgdmVjNCdzIHdpdGggdGhlIG1pbmltdW1cbiAgICAgKiBudW1iZXIgb2YgdGV4dHVyZTJEIGNhbGxzLCB3aGljaCBtZWFucyBtYWtpbmcgdXNlIG9mIGFsbCBmb3VyIHJldHVybmVkXG4gICAgICogdmFsdWVzIGZyb20gYSB0ZXh0dXJlMkQgY2FsbCBhdCBvbmNlLlxuICAgICAqL1xuICAgIG1haW5Mb29wICs9IGBcbiAgICBmb3IgKGludCByID0gMDsgciA8ICR7ZmlsdGVySGVpZ2h0fTsgcisrKSB7XG4gICAgICBgO1xuICAgIGZvciAobGV0IGMgPSAwOyBjIDwgZmlsdGVyV2lkdGg7IGMrKykge1xuICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgIHhUZXhlbEMke2MgKiAyfSA9IHZlYzQoMC4wKTtcbiAgICAgICAgICB4VGV4ZWxDJHtjICogMn1SZWFkeSA9IDA7XG4gICAgICAgICAgeFRleGVsQyR7YyAqIDIgKyAxfSA9IHZlYzQoMC4wKTtcbiAgICAgICAgICB4VGV4ZWxDJHtjICogMiArIDF9UmVhZHkgPSAwO1xuICAgICAgICAgIHhDJHtjfSA9IHZlYzQoMC4wKTtgO1xuICAgIH1cbiAgICBtYWluTG9vcCArPSBgXG4gICAgICAgIHhSID0geFJDb3JuZXIgKyByICogZGlsYXRpb25zWzBdO1xuICAgICAgICBpZiAoeFIgPj0wICYmIHhSIDwgaW5EaW1zWzBdKSB7XG4gICAgICBgO1xuXG4gICAgZm9yIChsZXQgdGV4ZWxDID0gMDsgdGV4ZWxDIDwgKHRleGVsc0Fjcm9zcyArIDEpIC8gMjsgdGV4ZWxDKyspIHtcbiAgICAgIGNvbnN0IGNvbEluZGV4ID0gdGV4ZWxDICogMjtcblxuICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgIHhDID0geENDb3JuZXIgKyAke2NvbEluZGV4ICogZGlsYXRpb25XaWR0aH07XG4gICAgICAgICAgYDtcblxuICAgICAgaWYgKHN0cmlkZVdpZHRoID09PSAxKSB7XG4gICAgICAgIGlmIChjb2xJbmRleCA8IGZpbHRlcldpZHRoKSB7XG4gICAgICAgICAgLy8gSWYgcGFkZGluZyBpcyBvZGQsIHRoZSBvdXRlciB0ZXhlbHMgaGF2ZSB0byBiZSBjb21wb3NlZC5cbiAgICAgICAgICBpZiAocGFkTGVmdCAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IEVuc3VyZSB2ZWM0IHByZXZpb3VzIGRvZXMgbm90IHJlc3VsdCBpbiByZWR1bmRhbnQgc2FtcGxlLFxuICAgICAgICAgICAgLy8gYW5kIGF2b2lkIHNldHRpbmcgeFRleGVsUkMncyB0aGF0IGV4Y2VlZCB0aGUgYm91bmRhcnkgaW4gdGhlXG4gICAgICAgICAgICAvLyBmaXJzdCBwbGFjZSByYXRoZXIgdGhhbiByZXNldHRpbmcgdGhlbSB0byB2ZWM0KDApKS5cblxuICAgICAgICAgICAgLy8gVG8gY29tcHV0ZSB4Q09mZnNldDpcbiAgICAgICAgICAgIC8vIC0gSWYgcGFkZGluZyBpcyBvZGQsIHdlIG11c3QgYWRkIDEgdG8gZW5zdXJlIHdlIGFzayBmb3IgYW5cbiAgICAgICAgICAgIC8vIGV2ZW4tbnVtYmVyZWQgcm93LlxuICAgICAgICAgICAgLy8gLSBXZSBzdWJ0cmFjdCAyIHRvIGFjY2VzcyB0aGUgcHJldmlvdXMgdGV4ZWwuXG5cbiAgICAgICAgICAgIG1haW5Mb29wICs9IGBcbiAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgMTtcbiAgICAgICAgICAgICAgICBpZiAoeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IGluRGltc1sxXSAmJiB4VGV4ZWxDJHtcbiAgICAgICAgICAgICAgICBjb2xJbmRleH1SZWFkeSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleH0gPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcblxuICAgICAgICAgICAgICAgICAgLy8gTmVlZCB0byBtYW51YWxseSBjbGVhciB1bnVzZWQgY2hhbm5lbHMgaW4gY2FzZVxuICAgICAgICAgICAgICAgICAgLy8gd2UncmUgcmVhZGluZyBmcm9tIHJlY3ljbGVkIHRleHR1cmUuXG4gICAgICAgICAgICAgICAgICBpZiAoeENPZmZzZXQgKyAxID49IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleH0uencgPSB2ZWMyKDAuMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleH1SZWFkeSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBgO1xuICAgICAgICAgICAgLy8gVGhpcyB0ZXhlbCBoYXMgYmVlbiByZWFkIGluIHByZXZpb3VzIGl0ZXJhdGlvbiBpZiB0aGUgZGlsYXRpb25cbiAgICAgICAgICAgIC8vIGlzIDEuXG4gICAgICAgICAgICBpZiAoZGlsYXRpb25XaWR0aCA9PT0gMSAmJiBjb2xJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgICAgICAgIHhDJHtjb2xJbmRleH0gPSB2ZWM0KHhUZXhlbEMke2NvbEluZGV4IC0gMn0uencsIHhUZXhlbEMke1xuICAgICAgICAgICAgICAgICAgY29sSW5kZXh9Lnh5KTtcbiAgICAgICAgICAgICAgICBgO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIDEgLSAyO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gbWFudWFsbHkgY2xlYXIgdW51c2VkIGNoYW5uZWxzIGluIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UncmUgcmVhZGluZyBmcm9tIHJlY3ljbGVkIHRleHR1cmUuXG4gICAgICAgICAgICAgICAgICAgIGlmICh4Q09mZnNldCArIDEgPj0gaW5EaW1zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMuencgPSB2ZWMyKDAuMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB4QyR7Y29sSW5kZXh9ID0gdmVjNChwcmV2aW91cy56dywgeFRleGVsQyR7Y29sSW5kZXh9Lnh5KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHhDJHtjb2xJbmRleH0gPSB2ZWM0KDAuMCwgMC4wLCB4VGV4ZWxDJHtjb2xJbmRleH0ueHkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUGFkZGluZyBpcyBldmVuLCBzbyB4UkMgY29ycmVzcG9uZHMgdG8gYSBzaW5nbGUgdGV4ZWwuXG4gICAgICAgICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICAgICAgICAgaWYgKHhDID49IDAgJiYgeEMgPCBpbkRpbXNbMV0gJiYgeFRleGVsQyR7Y29sSW5kZXh9UmVhZHkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXh9ID0gZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSk7XG4gICAgICAgICAgICAgICAgICBpZiAoeEMgKyAxID49IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleH0uencgPSB2ZWMyKDAuMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleH1SZWFkeSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgeEMke2NvbEluZGV4fSA9IHhUZXhlbEMke2NvbEluZGV4fTtcbiAgICAgICAgICAgICAgICBgO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb2xJbmRleCArIDEgPCBmaWx0ZXJXaWR0aCkge1xuICAgICAgICAgICAgLy8gSWYgZGlsYXRpb24gaXMgZXZlbiwgdGhlIHNlY29uZCBlbnRyeSBzaG91bGQgbWF0Y2ggdGhlIGZpcnN0XG4gICAgICAgICAgICAvLyAoZWl0aGVyIGJvdGggYXJlIGNvbXBvc2VkIG9yIGJvdGggYXJlIHNpbmdsZSBzYW1wbGVzKS4gQnV0IGlmXG4gICAgICAgICAgICAvLyBkaWxhdGlvbiBpcyBvZGQsIHRoZW4gdGhlIHNlY29uZCBlbnRyeSBzaG91bGQgYmUgdGhlIG9wcG9zaXRlXG4gICAgICAgICAgICAvLyBvZiB0aGUgZmlyc3QgKGlmIHRoZSBmaXJzdCBpcyBjb21wb3NlZCwgdGhlIHNlY29uZCBpcyBhIHNpbmdsZVxuICAgICAgICAgICAgLy8gc2FtcGxlLCBhbmQgdmljZSB2ZXJzYS4pXG5cbiAgICAgICAgICAgIGNvbnN0IG5leHRUZXhlbE9mZnNldCA9IHBhZExlZnQgJSAyID09PSAwID9cbiAgICAgICAgICAgICAgICB1dGlsLm5lYXJlc3RMYXJnZXJFdmVuKGRpbGF0aW9uV2lkdGgpIDpcbiAgICAgICAgICAgICAgICBkaWxhdGlvbldpZHRoO1xuXG4gICAgICAgICAgICBpZiAoKGRpbGF0aW9uV2lkdGggJSAyID09PSAwICYmIHBhZExlZnQgJSAyID09PSAxKSB8fFxuICAgICAgICAgICAgICAgIChkaWxhdGlvbldpZHRoICUgMiAhPT0gMCAmJiBwYWRMZWZ0ICUgMiAhPT0gMSkpIHtcbiAgICAgICAgICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIGltb2QocGFkc1sxXSwgMikgKyAke25leHRUZXhlbE9mZnNldH07XG5cbiAgICAgICAgICAgICAgICAgIGlmICh4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgaW5EaW1zWzFdICYmIHhUZXhlbEMke1xuICAgICAgICAgICAgICAgICAgY29sSW5kZXggKyAxfVJlYWR5ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXggKyAxfSA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gbWFudWFsbHkgY2xlYXIgdW51c2VkIGNoYW5uZWxzIGluIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UncmUgcmVhZGluZyBmcm9tIHJlY3ljbGVkIHRleHR1cmUuXG4gICAgICAgICAgICAgICAgICAgIGlmICh4Q09mZnNldCArIDEgPj0gaW5EaW1zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXggKyAxfS56dyA9IHZlYzIoMC4wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleCArIDF9UmVhZHkgPSAxO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYDtcblxuICAgICAgICAgICAgICAvLyBJZiBkaWxhdGlvbiA+IDEgdGhlbiB0aGUgeFJDJ3Mgd2lsbCBub3QgYmUgYWJsZSB0byBzaGFyZSBhbnlcbiAgICAgICAgICAgICAgLy8gdmFsdWVzLCBzbyBlYWNoIHhSQyB3aWxsIHJlcXVpcmUgdHdvIHVuaXF1ZSBjYWxscyB0byBnZXRYLlxuICAgICAgICAgICAgICBpZiAoZGlsYXRpb25XaWR0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0IC09IDI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgaW5EaW1zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xuICAgICAgICAgICAgICAgICAgICAgeEMke2NvbEluZGV4ICsgMX0gPSB2ZWM0KHByZXZpb3VzLnp3LCB4VGV4ZWxDJHtcbiAgICAgICAgICAgICAgICAgICAgICAgY29sSW5kZXggKyAxfS54eSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICB4QyR7Y29sSW5kZXggKyAxfSA9IHZlYzQoMC4wLCAwLjAsIHhUZXhlbEMke1xuICAgICAgICAgICAgICAgICAgICAgICBjb2xJbmRleCArIDF9Lnh5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBgO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1haW5Mb29wICs9IGBcbiAgICAgICAgICAgICAgICAgICAgeEMke2NvbEluZGV4ICsgMX0gPSB2ZWM0KHhUZXhlbEMke2NvbEluZGV4fS56dywgeFRleGVsQyR7XG4gICAgICAgICAgICAgICAgICAgIGNvbEluZGV4ICsgMX0ueHkpO1xuICAgICAgICAgICAgICAgICAgICBgO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBJZiBkaWxhdGlvbiBpcyAxIGFuZCBwYWRkaW5nIGlzIG9kZCwgd2UgaGF2ZSBhbHJlYWR5IHJlYWQgdGhlXG4gICAgICAgICAgICAgIC8vIHRleGVsIHdoZW4gY29uc3RydWN0aW5nIHRoZSBwcmV2aW91cyB4IHZhbHVlLiBIZXJlIHdlIGNhblxuICAgICAgICAgICAgICAvLyBzaW1wbHkgc2tpcCB0aGUgdGV4dHVyZSByZWFkLlxuICAgICAgICAgICAgICBpZiAobmV4dFRleGVsT2Zmc2V0ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgICAgICAgICAgICB4QyR7Y29sSW5kZXggKyAxfSA9IHhUZXhlbEMke2NvbEluZGV4fTtcbiAgICAgICAgICAgICAgICAgICAgYDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyAke25leHRUZXhlbE9mZnNldH07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBpbkRpbXNbMV0gJiYgeFRleGVsQyR7XG4gICAgICAgICAgICAgICAgICAgIGNvbEluZGV4ICsgMX1SZWFkeSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXggKyAxfSA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh4Q09mZnNldCArIDEgPj0gaW5EaW1zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleCArIDF9Lnp3ID0gdmVjMigwLjApO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleCArIDF9UmVhZHkgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgeEMke2NvbEluZGV4ICsgMX0gPSB4VGV4ZWxDJHtjb2xJbmRleCArIDF9O1xuICAgICAgICAgICAgICAgICAgICBgO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgeyAgLy8gc3RyaWRlID09PSAyXG4gICAgICAgIGlmIChjb2xJbmRleCA8IGZpbHRlcldpZHRoKSB7XG4gICAgICAgICAgLy8gRGVwZW5kaW5nIG9uIHdoZXRoZXIgcGFkTGVmdCBpcyBldmVuIG9yIG9kZCwgd2Ugd2FudCBlaXRoZXIgdGhlXG4gICAgICAgICAgLy8geHkgb3IgencgY2hhbm5lbHMgZnJvbSBYIHRleGVscyBmb3IgeEMke2NvbEluZGV4fS4gSWYgcGFkTGVmdCBpc1xuICAgICAgICAgIC8vIGV2ZW4sIHhDJHtjb2xJbmRleCArMX0gaXMgc2ltcGx5IHRoZSB6dyBjaGFubmVscyBvZiB0ZXhlbHMgd2UndmVcbiAgICAgICAgICAvLyBhbHJlYWR5IHNhbXBsZWQuIEJ1dCBpZiBwYWRMZWZ0IGlzIG9kZCwgeEN7JGMgKyAxfS56dyB3aWxsXG4gICAgICAgICAgLy8gbmVlZCB0byBjb21lIGZyb20gdGhlIHh5IGNoYW5uZWxzIG9mIGEgbmV3IHRleGVsLCBoZW5jZSB0aGUgYFxuICAgICAgICAgIC8vIHZlYzRcbiAgICAgICAgICAvLyBmaW5hbGAgaW5pdGlhbGl6ZWQgYmVsb3cuXG4gICAgICAgICAgaWYgKHBhZExlZnQgJSAyID09PSAxKSB7XG4gICAgICAgICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIDEgLSBzdHJpZGVzWzFdO1xuICAgICAgICAgICAgICAgIGlmKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBpbkRpbXNbMV0gJiYgeFRleGVsQyR7XG4gICAgICAgICAgICAgICAgY29sSW5kZXh9UmVhZHkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXh9ID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XG4gICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIG1hbnVhbGx5IGNsZWFyIHVudXNlZCBjaGFubmVscyBpbiBjYXNlXG4gICAgICAgICAgICAgICAgICAvLyB3ZSdyZSByZWFkaW5nIGZyb20gcmVjeWNsZWQgdGV4dHVyZS5cbiAgICAgICAgICAgICAgICAgIGlmICh4Q09mZnNldCArIDEgPj0gaW5EaW1zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2NvbEluZGV4fS56dyA9IHZlYzIoMC4wKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2NvbEluZGV4fVJlYWR5ID0gMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZih4QyArIDEgPj0gMCAmJiB4QyArIDEgPCBpbkRpbXNbMV0gJiYgeFRleGVsQyR7XG4gICAgICAgICAgICAgICAgY29sSW5kZXggKyAxfVJlYWR5ID09IDApIHtcbiAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2NvbEluZGV4ICsgMX0gPSBnZXRYKGJhdGNoLCB4UiwgeEMgKyAxLCBkMSk7XG4gICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIG1hbnVhbGx5IGNsZWFyIHVudXNlZCBjaGFubmVscyBpbiBjYXNlXG4gICAgICAgICAgICAgICAgICAvLyB3ZSdyZSByZWFkaW5nIGZyb20gcmVjeWNsZWQgdGV4dHVyZS5cbiAgICAgICAgICAgICAgICAgIGlmICh4QyArIDIgPj0gaW5EaW1zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2NvbEluZGV4ICsgMX0uencgPSB2ZWMyKDAuMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleCArIDF9UmVhZHkgPSAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHhDJHtjb2xJbmRleH0gPSB2ZWM0KHhUZXhlbEMke2NvbEluZGV4fS56dywgeFRleGVsQyR7XG4gICAgICAgICAgICAgICAgY29sSW5kZXggKyAxfS56dyk7XG4gICAgICAgICAgICAgIGA7XG5cbiAgICAgICAgICAgIGlmIChjb2xJbmRleCArIDEgPCBmaWx0ZXJXaWR0aCkge1xuICAgICAgICAgICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICAgICAgICAgICBmaW5hbCA9IHZlYzQoMC4wKTtcbiAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyAxICsgc3RyaWRlc1sxXTtcbiAgICAgICAgICAgICAgICAgIGlmKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWwgPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHhDJHtjb2xJbmRleCArIDF9ID0gdmVjNCh4VGV4ZWxDJHtjb2xJbmRleCArIDF9Lnh5LCBmaW5hbC54eSk7XG4gICAgICAgICAgICAgICAgYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgICAgICAgIGlmKHhDID49IDAgJiYgeEMgPCBpbkRpbXNbMV0gJiYgeFRleGVsQyR7Y29sSW5kZXh9UmVhZHkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXh9ID0gZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSk7XG4gICAgICAgICAgICAgICAgICBpZiAoeEMgKyAxID49IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleH0uencgPSB2ZWMyKDAuMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleH1SZWFkeSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIHN0cmlkZXNbMV07XG4gICAgICAgICAgICAgICAgaWYoeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IGluRGltc1sxXSAmJiB4VGV4ZWxDJHtcbiAgICAgICAgICAgICAgICBjb2xJbmRleCArIDF9UmVhZHkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXggKyAxfSA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xuICAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ICsgMSA+PSBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXggKyAxfS56dyA9IHZlYzIoMC4pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXggKyAxfVJlYWR5ID0gMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB4QyR7Y29sSW5kZXh9ID0gdmVjNChcbiAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2NvbEluZGV4fS54eSwgeFRleGVsQyR7Y29sSW5kZXggKyAxfS54eSk7XG4gICAgICAgICAgICAgIGA7XG5cbiAgICAgICAgICAgIGlmIChjb2xJbmRleCArIDEgPCBmaWx0ZXJXaWR0aCkge1xuICAgICAgICAgICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICAgICAgICAgICB4QyR7Y29sSW5kZXggKyAxfSA9IHZlYzQoeFRleGVsQyR7Y29sSW5kZXh9Lnp3LCB4VGV4ZWxDJHtcbiAgICAgICAgICAgICAgICAgIGNvbEluZGV4ICsgMX0uencpO1xuICAgICAgICAgICAgICAgIGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGxvY2FsaXplIHRoZSBkb3RQcm9kIGFjY3VtdWxhdGlvbiB3aXRoaW4gdGhlIGxvb3AsIHRoZSB0aGVvcnkgaXMgZm9yXG4gICAgICAvLyBHUFUgd2l0aCBsaW1pdGVkIGNhY2hlLCBhY2N1bXVsYXRlIHN1bSBhY3Jvc3MgbGFyZ2UgYW1vdW50IG9mXG4gICAgICAvLyB2ZXJpYWJsZXMgd2lsbCBjYXVzZSBsb3RzIG9mIGNhY2hlIG1pc3Nlcy4gKGkuZS4gNXg1IGZpbHRlciB3aWxsIGhhdmVcbiAgICAgIC8vIDUwIHZhcmlhYmxlcylcbiAgICAgIGlmIChjb2xJbmRleCA8IGZpbHRlcldpZHRoKSB7XG4gICAgICAgIG1haW5Mb29wICs9IGBcbiAgICAgICAgICAgIHdUZXhlbCA9IGdldFcociwgJHtjb2xJbmRleH0sIGQxLCBxKTtcbiAgICAgICAgICAgIGRvdFByb2QgKz0geEMke2NvbEluZGV4fSAqIHZlYzQod1RleGVsLnh6LCB3VGV4ZWwueHopO1xuICAgICAgICAgIGA7XG5cbiAgICAgICAgaWYgKGNvbEluZGV4ICsgMSA8IGZpbHRlcldpZHRoKSB7XG4gICAgICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgICAgICB3VGV4ZWwgPSBnZXRXKHIsICR7Y29sSW5kZXggKyAxfSwgZDEsIHEpO1xuICAgICAgICAgICAgICBkb3RQcm9kICs9IHhDJHtjb2xJbmRleCArIDF9ICogdmVjNCh3VGV4ZWwueHosIHdUZXhlbC54eik7XG4gICAgICAgICAgICBgO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG1haW5Mb29wICs9IGBcbiAgICB9XG4gIGA7XG4gICAgbWFpbkxvb3AgKz0gYFxuICAgICAgfVxuICAgIGA7XG5cbiAgICBsZXQgYWN0aXZhdGlvblNuaXBwZXQgPSAnJywgYXBwbHlBY3RpdmF0aW9uU25pcHBldCA9ICcnO1xuICAgIGlmIChhY3RpdmF0aW9uKSB7XG4gICAgICBpZiAoaGFzUHJlbHVBY3RpdmF0aW9uKSB7XG4gICAgICAgIGFjdGl2YXRpb25TbmlwcGV0ID0gYHZlYzQgYWN0aXZhdGlvbih2ZWM0IGEpIHtcbiAgICAgICAgICB2ZWM0IGIgPSBnZXRQcmVsdUFjdGl2YXRpb25XZWlnaHRzQXRPdXRDb29yZHMoKTtcbiAgICAgICAgICAke2FjdGl2YXRpb259XG4gICAgICAgIH1gO1xuICAgICAgfSBlbHNlIGlmIChoYXNMZWFreVJlbHVBbHBoYSkge1xuICAgICAgICBhY3RpdmF0aW9uU25pcHBldCA9IGB2ZWM0IGFjdGl2YXRpb24odmVjNCBhKSB7XG4gICAgICAgICAgdmVjNCBiID0gZ2V0TGVha3lyZWx1QWxwaGFBdE91dENvb3JkcygpO1xuICAgICAgICAgICR7YWN0aXZhdGlvbn1cbiAgICAgICAgfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmF0aW9uU25pcHBldCA9IGB2ZWM0IGFjdGl2YXRpb24odmVjNCB4KSB7XG4gICAgICAgICAgJHthY3RpdmF0aW9ufVxuICAgICAgICB9YDtcbiAgICAgIH1cblxuICAgICAgYXBwbHlBY3RpdmF0aW9uU25pcHBldCA9IGByZXN1bHQgPSBhY3RpdmF0aW9uKHJlc3VsdCk7YDtcbiAgICB9XG5cbiAgICBjb25zdCBhZGRCaWFzU25pcHBldCA9IGFkZEJpYXMgPyAncmVzdWx0ICs9IGdldEJpYXNBdE91dENvb3JkcygpOycgOiAnJztcbiAgICBpZiAoYWRkQmlhcykge1xuICAgICAgdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goJ2JpYXMnKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzUHJlbHVBY3RpdmF0aW9uKSB7XG4gICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgncHJlbHVBY3RpdmF0aW9uV2VpZ2h0cycpO1xuICAgIH1cbiAgICBpZiAoaGFzTGVha3lSZWx1QWxwaGEpIHtcbiAgICAgIHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKCdsZWFreXJlbHVBbHBoYScpO1xuICAgIH1cblxuICAgIHRoaXMudXNlckNvZGUgPSBgXG4gICAgICAke2FjdGl2YXRpb25TbmlwcGV0fVxuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcbiAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy53O1xuICAgICAgICBpbnQgZDEgPSBkMiAvICR7Y2hhbm5lbE11bH07XG4gICAgICAgIGludCBxID0gZDIgLSBkMSAqICR7Y2hhbm5lbE11bH07XG4gICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xuICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcblxuICAgICAgICAvL2ludGlhbGl6ZSBkb3RQcm9kIHdpdGggYSBzbWFsbCBlcHNpbG9uIHNlZW1zIHRvIHJlZHVjZSBHUFUgYWNjdXJhY3kgbG9zcy5cbiAgICAgICAgdmVjNCBkb3RQcm9kID0gdmVjNCgwLjAwMDAwMDAwMDAwMDAwMSk7XG5cbiAgICAgICAgJHttYWluTG9vcH1cblxuICAgICAgICB2ZWM0IHJlc3VsdCA9IGRvdFByb2QgLSB2ZWM0KDAuMDAwMDAwMDAwMDAwMDAxKTtcbiAgICAgICAgJHthZGRCaWFzU25pcHBldH1cbiAgICAgICAgJHthcHBseUFjdGl2YXRpb25TbmlwcGV0fVxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG59XG4iXX0=","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class CropAndResizeProgram {\n    constructor(imageShape, boxShape, cropSize, method, extrapolationValue) {\n        this.variableNames = ['Image', 'Boxes', 'BoxInd'];\n        this.outputShape = [];\n        const [batch, imageHeight, imageWidth, depth] = imageShape;\n        const [numBoxes,] = boxShape;\n        const [cropHeight, cropWidth] = cropSize;\n        this.outputShape = [numBoxes, cropHeight, cropWidth, depth];\n        const methodId = method === 'bilinear' ? 1 : 0;\n        const [inputHeightFloat, inputWidthFloat] = [`${imageHeight - 1}.0`, `${imageWidth - 1}.0`];\n        const [heightRatio, heightScale, inY] = cropHeight > 1 ?\n            [\n                `${(imageHeight - 1) / (cropHeight - 1)}`,\n                '(y2-y1) * height_ratio',\n                `y1*${inputHeightFloat} + float(y)*(height_scale)`,\n            ] :\n            [\n                '0.0',\n                '0.0',\n                `0.5 * (y1+y2) * ${inputHeightFloat}`,\n            ];\n        const [widthRatio, widthScale, inX] = cropWidth > 1 ?\n            [\n                `${(imageWidth - 1) / (cropWidth - 1)}`,\n                '(x2-x1) * width_ratio',\n                `x1*${inputWidthFloat} + float(x)*(width_scale)`,\n            ] :\n            [\n                '0.0',\n                '0.0',\n                `0.5 * (x1+x2) * ${inputWidthFloat}`,\n            ];\n        // Reference implementation\n        // tslint:disable-next-line:max-line-length\n        // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op_gpu.cu.cc\n        this.userCode = `\n      const float height_ratio = float(${heightRatio});\n      const float width_ratio = float(${widthRatio});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${batch}) {\n          return;\n        }\n\n        float height_scale = ${heightScale};\n        float width_scale = ${widthScale};\n\n        float in_y = ${inY};\n        if( in_y < 0.0 || in_y > ${inputHeightFloat} ) {\n          setOutput(float(${extrapolationValue}));\n          return;\n        }\n        float in_x = ${inX};\n        if( in_x < 0.0 || in_x > ${inputWidthFloat} ) {\n          setOutput(float(${extrapolationValue}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${methodId} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3JvcF9hbmRfcmVzaXplX2dwdS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RmanMtYmFja2VuZC13ZWJnbC9zcmMvY3JvcF9hbmRfcmVzaXplX2dwdS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFJSCxNQUFNLE9BQU8sb0JBQW9CO0lBSy9CLFlBQ0ksVUFBNEMsRUFBRSxRQUEwQixFQUN4RSxRQUEwQixFQUFFLE1BQTRCLEVBQ3hELGtCQUEwQjtRQVA5QixrQkFBYSxHQUFHLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBQztRQUM3QyxnQkFBVyxHQUFhLEVBQUUsQ0FBQztRQU96QixNQUFNLENBQUMsS0FBSyxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQUUsS0FBSyxDQUFDLEdBQUcsVUFBVSxDQUFDO1FBQzNELE1BQU0sQ0FBQyxRQUFRLEVBQUcsR0FBRyxRQUFRLENBQUM7UUFDOUIsTUFBTSxDQUFDLFVBQVUsRUFBRSxTQUFTLENBQUMsR0FBRyxRQUFRLENBQUM7UUFDekMsSUFBSSxDQUFDLFdBQVcsR0FBRyxDQUFDLFFBQVEsRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQzVELE1BQU0sUUFBUSxHQUFHLE1BQU0sS0FBSyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRS9DLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRSxlQUFlLENBQUMsR0FDckMsQ0FBQyxHQUFHLFdBQVcsR0FBRyxDQUFDLElBQUksRUFBRSxHQUFHLFVBQVUsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXBELE1BQU0sQ0FBQyxXQUFXLEVBQUUsV0FBVyxFQUFFLEdBQUcsQ0FBQyxHQUFHLFVBQVUsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNwRDtnQkFDRSxHQUFHLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBVSxHQUFHLENBQUMsQ0FBQyxFQUFFO2dCQUN6Qyx3QkFBd0I7Z0JBQ3hCLE1BQU0sZ0JBQWdCLDRCQUE0QjthQUNuRCxDQUFDLENBQUM7WUFDSDtnQkFDRSxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsbUJBQW1CLGdCQUFnQixFQUFFO2FBQ3RDLENBQUM7UUFDTixNQUFNLENBQUMsVUFBVSxFQUFFLFVBQVUsRUFBRSxHQUFHLENBQUMsR0FBRyxTQUFTLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDakQ7Z0JBQ0UsR0FBRyxDQUFDLFVBQVUsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUMsRUFBRTtnQkFDdkMsdUJBQXVCO2dCQUN2QixNQUFNLGVBQWUsMkJBQTJCO2FBQ2pELENBQUMsQ0FBQztZQUNIO2dCQUNFLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxtQkFBbUIsZUFBZSxFQUFFO2FBQ3JDLENBQUM7UUFFTiwyQkFBMkI7UUFDM0IsMkNBQTJDO1FBQzNDLDRHQUE0RztRQUM1RyxJQUFJLENBQUMsUUFBUSxHQUFHO3lDQUNxQixXQUFXO3dDQUNaLFVBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7aUNBZ0JqQixLQUFLOzs7OytCQUlQLFdBQVc7OEJBQ1osVUFBVTs7dUJBRWpCLEdBQUc7bUNBQ1MsZ0JBQWdCOzRCQUN2QixrQkFBa0I7Ozt1QkFHdkIsR0FBRzttQ0FDUyxlQUFlOzRCQUN0QixrQkFBa0I7Ozs7O2FBS2pDLFFBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXdCaEIsQ0FBQztJQUNKLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtHUEdQVVByb2dyYW19IGZyb20gJy4vZ3BncHVfbWF0aCc7XG5cbmV4cG9ydCBjbGFzcyBDcm9wQW5kUmVzaXplUHJvZ3JhbSBpbXBsZW1lbnRzIEdQR1BVUHJvZ3JhbSB7XG4gIHZhcmlhYmxlTmFtZXMgPSBbJ0ltYWdlJywgJ0JveGVzJywgJ0JveEluZCddO1xuICBvdXRwdXRTaGFwZTogbnVtYmVyW10gPSBbXTtcbiAgdXNlckNvZGU6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihcbiAgICAgIGltYWdlU2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLCBib3hTaGFwZTogW251bWJlciwgbnVtYmVyXSxcbiAgICAgIGNyb3BTaXplOiBbbnVtYmVyLCBudW1iZXJdLCBtZXRob2Q6ICdiaWxpbmVhcid8J25lYXJlc3QnLFxuICAgICAgZXh0cmFwb2xhdGlvblZhbHVlOiBudW1iZXIpIHtcbiAgICBjb25zdCBbYmF0Y2gsIGltYWdlSGVpZ2h0LCBpbWFnZVdpZHRoLCBkZXB0aF0gPSBpbWFnZVNoYXBlO1xuICAgIGNvbnN0IFtudW1Cb3hlcywgXSA9IGJveFNoYXBlO1xuICAgIGNvbnN0IFtjcm9wSGVpZ2h0LCBjcm9wV2lkdGhdID0gY3JvcFNpemU7XG4gICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtudW1Cb3hlcywgY3JvcEhlaWdodCwgY3JvcFdpZHRoLCBkZXB0aF07XG4gICAgY29uc3QgbWV0aG9kSWQgPSBtZXRob2QgPT09ICdiaWxpbmVhcicgPyAxIDogMDtcblxuICAgIGNvbnN0IFtpbnB1dEhlaWdodEZsb2F0LCBpbnB1dFdpZHRoRmxvYXRdID1cbiAgICAgICAgW2Ake2ltYWdlSGVpZ2h0IC0gMX0uMGAsIGAke2ltYWdlV2lkdGggLSAxfS4wYF07XG5cbiAgICBjb25zdCBbaGVpZ2h0UmF0aW8sIGhlaWdodFNjYWxlLCBpblldID0gY3JvcEhlaWdodCA+IDEgP1xuICAgICAgICBbXG4gICAgICAgICAgYCR7KGltYWdlSGVpZ2h0IC0gMSkgLyAoY3JvcEhlaWdodCAtIDEpfWAsXG4gICAgICAgICAgJyh5Mi15MSkgKiBoZWlnaHRfcmF0aW8nLFxuICAgICAgICAgIGB5MSoke2lucHV0SGVpZ2h0RmxvYXR9ICsgZmxvYXQoeSkqKGhlaWdodF9zY2FsZSlgLFxuICAgICAgICBdIDpcbiAgICAgICAgW1xuICAgICAgICAgICcwLjAnLFxuICAgICAgICAgICcwLjAnLFxuICAgICAgICAgIGAwLjUgKiAoeTEreTIpICogJHtpbnB1dEhlaWdodEZsb2F0fWAsXG4gICAgICAgIF07XG4gICAgY29uc3QgW3dpZHRoUmF0aW8sIHdpZHRoU2NhbGUsIGluWF0gPSBjcm9wV2lkdGggPiAxID9cbiAgICAgICAgW1xuICAgICAgICAgIGAkeyhpbWFnZVdpZHRoIC0gMSkgLyAoY3JvcFdpZHRoIC0gMSl9YCxcbiAgICAgICAgICAnKHgyLXgxKSAqIHdpZHRoX3JhdGlvJyxcbiAgICAgICAgICBgeDEqJHtpbnB1dFdpZHRoRmxvYXR9ICsgZmxvYXQoeCkqKHdpZHRoX3NjYWxlKWAsXG4gICAgICAgIF0gOlxuICAgICAgICBbXG4gICAgICAgICAgJzAuMCcsXG4gICAgICAgICAgJzAuMCcsXG4gICAgICAgICAgYDAuNSAqICh4MSt4MikgKiAke2lucHV0V2lkdGhGbG9hdH1gLFxuICAgICAgICBdO1xuXG4gICAgLy8gUmVmZXJlbmNlIGltcGxlbWVudGF0aW9uXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1saW5lLWxlbmd0aFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90ZW5zb3JmbG93L3RlbnNvcmZsb3cvYmxvYi9tYXN0ZXIvdGVuc29yZmxvdy9jb3JlL2tlcm5lbHMvY3JvcF9hbmRfcmVzaXplX29wX2dwdS5jdS5jY1xuICAgIHRoaXMudXNlckNvZGUgPSBgXG4gICAgICBjb25zdCBmbG9hdCBoZWlnaHRfcmF0aW8gPSBmbG9hdCgke2hlaWdodFJhdGlvfSk7XG4gICAgICBjb25zdCBmbG9hdCB3aWR0aF9yYXRpbyA9IGZsb2F0KCR7d2lkdGhSYXRpb30pO1xuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XG4gICAgICAgIGludCB5ID0gY29vcmRzWzFdO1xuICAgICAgICBpbnQgeCA9IGNvb3Jkc1syXTtcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XG5cbiAgICAgICAgLy8gZ2V0IGJveCB2YWxzXG4gICAgICAgIGZsb2F0IHkxID0gZ2V0Qm94ZXMoYiwwKTtcbiAgICAgICAgZmxvYXQgeDEgPSBnZXRCb3hlcyhiLDEpO1xuICAgICAgICBmbG9hdCB5MiA9IGdldEJveGVzKGIsMik7XG4gICAgICAgIGZsb2F0IHgyID0gZ2V0Qm94ZXMoYiwzKTtcblxuICAgICAgICAvLyBnZXQgaW1hZ2UgaW4gYmF0Y2ggaW5kZXhcbiAgICAgICAgaW50IGJJbmQgPSByb3VuZChnZXRCb3hJbmQoYikpO1xuICAgICAgICBpZihiSW5kIDwgMCB8fCBiSW5kID49ICR7YmF0Y2h9KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZmxvYXQgaGVpZ2h0X3NjYWxlID0gJHtoZWlnaHRTY2FsZX07XG4gICAgICAgIGZsb2F0IHdpZHRoX3NjYWxlID0gJHt3aWR0aFNjYWxlfTtcblxuICAgICAgICBmbG9hdCBpbl95ID0gJHtpbll9O1xuICAgICAgICBpZiggaW5feSA8IDAuMCB8fCBpbl95ID4gJHtpbnB1dEhlaWdodEZsb2F0fSApIHtcbiAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQoJHtleHRyYXBvbGF0aW9uVmFsdWV9KSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZsb2F0IGluX3ggPSAke2luWH07XG4gICAgICAgIGlmKCBpbl94IDwgMC4wIHx8IGluX3ggPiAke2lucHV0V2lkdGhGbG9hdH0gKSB7XG4gICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KCR7ZXh0cmFwb2xhdGlvblZhbHVlfSkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZlYzIgc291cmNlRnJhY0luZGV4Q1IgPSB2ZWMyKGluX3gsaW5feSk7XG4gICAgICAgIGlmKCR7bWV0aG9kSWR9ID09IDEpIHtcbiAgICAgICAgICAvLyBDb21wdXRlIHRoZSBmb3VyIGludGVnZXIgaW5kaWNlcy5cbiAgICAgICAgICBpdmVjMiBzb3VyY2VGbG9vckNSID0gaXZlYzIoc291cmNlRnJhY0luZGV4Q1IpO1xuICAgICAgICAgIGl2ZWMyIHNvdXJjZUNlaWxDUiA9IGl2ZWMyKGNlaWwoc291cmNlRnJhY0luZGV4Q1IpKTtcblxuICAgICAgICAgIGZsb2F0IHRvcExlZnQgPSBnZXRJbWFnZShiLCBzb3VyY2VGbG9vckNSLnksIHNvdXJjZUZsb29yQ1IueCwgZCk7XG4gICAgICAgICAgZmxvYXQgYm90dG9tTGVmdCA9IGdldEltYWdlKGIsIHNvdXJjZUNlaWxDUi55LCBzb3VyY2VGbG9vckNSLngsIGQpO1xuICAgICAgICAgIGZsb2F0IHRvcFJpZ2h0ID0gZ2V0SW1hZ2UoYiwgc291cmNlRmxvb3JDUi55LCBzb3VyY2VDZWlsQ1IueCwgZCk7XG4gICAgICAgICAgZmxvYXQgYm90dG9tUmlnaHQgPSBnZXRJbWFnZShiLCBzb3VyY2VDZWlsQ1IueSwgc291cmNlQ2VpbENSLngsIGQpO1xuXG4gICAgICAgICAgdmVjMiBmcmFjQ1IgPSBzb3VyY2VGcmFjSW5kZXhDUiAtIHZlYzIoc291cmNlRmxvb3JDUik7XG5cbiAgICAgICAgICBmbG9hdCB0b3AgPSB0b3BMZWZ0ICsgKHRvcFJpZ2h0IC0gdG9wTGVmdCkgKiBmcmFjQ1IueDtcbiAgICAgICAgICBmbG9hdCBib3R0b20gPSBib3R0b21MZWZ0ICsgKGJvdHRvbVJpZ2h0IC0gYm90dG9tTGVmdCkgKiBmcmFjQ1IueDtcbiAgICAgICAgICBmbG9hdCBuZXdWYWx1ZSA9IHRvcCArIChib3R0b20gLSB0b3ApICogZnJhY0NSLnk7XG4gICAgICAgICAgc2V0T3V0cHV0KG5ld1ZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDb21wdXRlIHRoZSBjb29yZGluYXRvcnMgb2YgbmVhcmVzdCBuZWlnaGJvciBwb2ludC5cbiAgICAgICAgICBpdmVjMiBzb3VyY2VOZWFyZXN0Q1IgPSBpdmVjMihmbG9vcihcbiAgICAgICAgICAgIHNvdXJjZUZyYWNJbmRleENSICsgdmVjMigwLjUsMC41KSkpO1xuICAgICAgICAgIGZsb2F0IG5ld1ZhbHVlID0gZ2V0SW1hZ2UoYiwgc291cmNlTmVhcmVzdENSLnksIHNvdXJjZU5lYXJlc3RDUi54LCBkKTtcbiAgICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgYDtcbiAgfVxufVxuIl19","import { getCoordsDataType } from './shader_compiler';\nexport var CumOpType;\n(function (CumOpType) {\n    CumOpType[\"Prod\"] = \"*\";\n    CumOpType[\"Sum\"] = \"+\";\n})(CumOpType || (CumOpType = {}));\nexport class CumProgram {\n    constructor(op, outputShape, exclusive, reverse) {\n        this.op = op;\n        this.outputShape = outputShape;\n        this.variableNames = ['x'];\n        this.customUniforms = [{ name: 'index', type: 'float' }];\n        const rank = this.outputShape.length;\n        const initVal = this.op === CumOpType.Prod ? '1.0' : '0.0';\n        const val = exclusive ? initVal : `getX(${getCoords(rank, 'coords', this.op)})`;\n        const length = this.outputShape[this.outputShape.length - 1];\n        let condition = '';\n        let idxString = '';\n        // When exclusive is set, the cum op becomes roll op that copies the\n        // value from the previous index based on the direction specified by the\n        // reverse flag.\n        if (exclusive) {\n            condition = reverse ? `end != ${length - 1}` : 'end != 0';\n            idxString = reverse ? 'end + 1' : 'end - 1';\n        }\n        else {\n            condition = reverse ? `end + pow2 < ${length}` : 'end >= pow2';\n            idxString = (reverse ? 'end + pow2' : 'end - pow2');\n        }\n        this.userCode = `\n      void main() {\n        ${getCoordsDataType(rank)} coords = getOutputCoords();\n        int end = ${getFinalCoord(rank, 'coords', this.op)};\n        float val = ${val};\n        int pow2 = int(pow(2.0, index));\n        if (${condition}) {\n          int idx = ${idxString};\n          ${getFinalCoord(rank, 'coords', this.op)} = idx;\n          val ${this.op}= getX(${getCoords(rank, 'coords', this.op)});\n        }\n        setOutput(val);\n      }\n    `;\n    }\n}\nfunction getCoords(rank, name, op) {\n    if (rank === 1) {\n        return `${name}`;\n    }\n    else if (rank === 2) {\n        return `${name}.x, ${name}.y`;\n    }\n    else if (rank === 3) {\n        return `${name}.x, ${name}.y, ${name}.z`;\n    }\n    else if (rank === 4) {\n        return `${name}.x, ${name}.y, ${name}.z, ${name}.w`;\n    }\n    else {\n        throw new Error(`Cumulative ${op} for rank ${rank} is not yet supported`);\n    }\n}\nfunction getFinalCoord(rank, name, op) {\n    if (rank === 1) {\n        return `${name}`;\n    }\n    else if (rank === 2) {\n        return `${name}.y`;\n    }\n    else if (rank === 3) {\n        return `${name}.z`;\n    }\n    else if (rank === 4) {\n        return `${name}.w`;\n    }\n    else {\n        throw new Error(`Cumulative ${op} for rank ${rank} is not yet supported`);\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3VtX2dwdS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RmanMtYmFja2VuZC13ZWJnbC9zcmMvY3VtX2dwdS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFpQkEsT0FBTyxFQUFDLGlCQUFpQixFQUFjLE1BQU0sbUJBQW1CLENBQUM7QUFFakUsTUFBTSxDQUFOLElBQVksU0FHWDtBQUhELFdBQVksU0FBUztJQUNuQix1QkFBVSxDQUFBO0lBQ1Ysc0JBQVMsQ0FBQTtBQUNYLENBQUMsRUFIVyxTQUFTLEtBQVQsU0FBUyxRQUdwQjtBQUVELE1BQU0sT0FBTyxVQUFVO0lBS3JCLFlBQ1csRUFBYSxFQUFTLFdBQXFCLEVBQUUsU0FBa0IsRUFDdEUsT0FBZ0I7UUFEVCxPQUFFLEdBQUYsRUFBRSxDQUFXO1FBQVMsZ0JBQVcsR0FBWCxXQUFXLENBQVU7UUFMdEQsa0JBQWEsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRXRCLG1CQUFjLEdBQUcsQ0FBQyxFQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE9BQXNCLEVBQUMsQ0FBQyxDQUFDO1FBSy9ELE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDO1FBQ3JDLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxFQUFFLEtBQUssU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7UUFDM0QsTUFBTSxHQUFHLEdBQ0wsU0FBUyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLFFBQVEsU0FBUyxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUM7UUFDeEUsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztRQUM3RCxJQUFJLFNBQVMsR0FBRyxFQUFFLENBQUM7UUFDbkIsSUFBSSxTQUFTLEdBQUcsRUFBRSxDQUFDO1FBQ25CLG9FQUFvRTtRQUNwRSx3RUFBd0U7UUFDeEUsZ0JBQWdCO1FBQ2hCLElBQUksU0FBUyxFQUFFO1lBQ2IsU0FBUyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsVUFBVSxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQztZQUMxRCxTQUFTLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztTQUM3QzthQUFNO1lBQ0wsU0FBUyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsZ0JBQWdCLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUM7WUFDL0QsU0FBUyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDO1NBQ3JEO1FBRUQsSUFBSSxDQUFDLFFBQVEsR0FBRzs7VUFFVixpQkFBaUIsQ0FBQyxJQUFJLENBQUM7b0JBQ2IsYUFBYSxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQztzQkFDcEMsR0FBRzs7Y0FFWCxTQUFTO3NCQUNELFNBQVM7WUFDbkIsYUFBYSxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQztnQkFDbEMsSUFBSSxDQUFDLEVBQUUsVUFBVSxTQUFTLENBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDOzs7O0tBSTlELENBQUM7SUFDSixDQUFDO0NBQ0Y7QUFFRCxTQUFTLFNBQVMsQ0FBQyxJQUFZLEVBQUUsSUFBWSxFQUFFLEVBQWE7SUFDMUQsSUFBSSxJQUFJLEtBQUssQ0FBQyxFQUFFO1FBQ2QsT0FBTyxHQUFHLElBQUksRUFBRSxDQUFDO0tBQ2xCO1NBQU0sSUFBSSxJQUFJLEtBQUssQ0FBQyxFQUFFO1FBQ3JCLE9BQU8sR0FBRyxJQUFJLE9BQU8sSUFBSSxJQUFJLENBQUM7S0FDL0I7U0FBTSxJQUFJLElBQUksS0FBSyxDQUFDLEVBQUU7UUFDckIsT0FBTyxHQUFHLElBQUksT0FBTyxJQUFJLE9BQU8sSUFBSSxJQUFJLENBQUM7S0FDMUM7U0FBTSxJQUFJLElBQUksS0FBSyxDQUFDLEVBQUU7UUFDckIsT0FBTyxHQUFHLElBQUksT0FBTyxJQUFJLE9BQU8sSUFBSSxPQUFPLElBQUksSUFBSSxDQUFDO0tBQ3JEO1NBQU07UUFDTCxNQUFNLElBQUksS0FBSyxDQUFDLGNBQWMsRUFBRSxhQUFhLElBQUksdUJBQXVCLENBQUMsQ0FBQztLQUMzRTtBQUNILENBQUM7QUFFRCxTQUFTLGFBQWEsQ0FBQyxJQUFZLEVBQUUsSUFBWSxFQUFFLEVBQWE7SUFDOUQsSUFBSSxJQUFJLEtBQUssQ0FBQyxFQUFFO1FBQ2QsT0FBTyxHQUFHLElBQUksRUFBRSxDQUFDO0tBQ2xCO1NBQU0sSUFBSSxJQUFJLEtBQUssQ0FBQyxFQUFFO1FBQ3JCLE9BQU8sR0FBRyxJQUFJLElBQUksQ0FBQztLQUNwQjtTQUFNLElBQUksSUFBSSxLQUFLLENBQUMsRUFBRTtRQUNyQixPQUFPLEdBQUcsSUFBSSxJQUFJLENBQUM7S0FDcEI7U0FBTSxJQUFJLElBQUksS0FBSyxDQUFDLEVBQUU7UUFDckIsT0FBTyxHQUFHLElBQUksSUFBSSxDQUFDO0tBQ3BCO1NBQU07UUFDTCxNQUFNLElBQUksS0FBSyxDQUFDLGNBQWMsRUFBRSxhQUFhLElBQUksdUJBQXVCLENBQUMsQ0FBQztLQUMzRTtBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5pbXBvcnQge0dQR1BVUHJvZ3JhbX0gZnJvbSAnLi9ncGdwdV9tYXRoJztcbmltcG9ydCB7Z2V0Q29vcmRzRGF0YVR5cGUsIFVuaWZvcm1UeXBlfSBmcm9tICcuL3NoYWRlcl9jb21waWxlcic7XG5cbmV4cG9ydCBlbnVtIEN1bU9wVHlwZSB7XG4gIFByb2QgPSAnKicsXG4gIFN1bSA9ICcrJyxcbn1cblxuZXhwb3J0IGNsYXNzIEN1bVByb2dyYW0gaW1wbGVtZW50cyBHUEdQVVByb2dyYW0ge1xuICB2YXJpYWJsZU5hbWVzID0gWyd4J107XG4gIHVzZXJDb2RlOiBzdHJpbmc7XG4gIGN1c3RvbVVuaWZvcm1zID0gW3tuYW1lOiAnaW5kZXgnLCB0eXBlOiAnZmxvYXQnIGFzIFVuaWZvcm1UeXBlfV07XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBwdWJsaWMgb3A6IEN1bU9wVHlwZSwgcHVibGljIG91dHB1dFNoYXBlOiBudW1iZXJbXSwgZXhjbHVzaXZlOiBib29sZWFuLFxuICAgICAgcmV2ZXJzZTogYm9vbGVhbikge1xuICAgIGNvbnN0IHJhbmsgPSB0aGlzLm91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBpbml0VmFsID0gdGhpcy5vcCA9PT0gQ3VtT3BUeXBlLlByb2QgPyAnMS4wJyA6ICcwLjAnO1xuICAgIGNvbnN0IHZhbCA9XG4gICAgICAgIGV4Y2x1c2l2ZSA/IGluaXRWYWwgOiBgZ2V0WCgke2dldENvb3JkcyhyYW5rLCAnY29vcmRzJywgdGhpcy5vcCl9KWA7XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5vdXRwdXRTaGFwZVt0aGlzLm91dHB1dFNoYXBlLmxlbmd0aCAtIDFdO1xuICAgIGxldCBjb25kaXRpb24gPSAnJztcbiAgICBsZXQgaWR4U3RyaW5nID0gJyc7XG4gICAgLy8gV2hlbiBleGNsdXNpdmUgaXMgc2V0LCB0aGUgY3VtIG9wIGJlY29tZXMgcm9sbCBvcCB0aGF0IGNvcGllcyB0aGVcbiAgICAvLyB2YWx1ZSBmcm9tIHRoZSBwcmV2aW91cyBpbmRleCBiYXNlZCBvbiB0aGUgZGlyZWN0aW9uIHNwZWNpZmllZCBieSB0aGVcbiAgICAvLyByZXZlcnNlIGZsYWcuXG4gICAgaWYgKGV4Y2x1c2l2ZSkge1xuICAgICAgY29uZGl0aW9uID0gcmV2ZXJzZSA/IGBlbmQgIT0gJHtsZW5ndGggLSAxfWAgOiAnZW5kICE9IDAnO1xuICAgICAgaWR4U3RyaW5nID0gcmV2ZXJzZSA/ICdlbmQgKyAxJyA6ICdlbmQgLSAxJztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZGl0aW9uID0gcmV2ZXJzZSA/IGBlbmQgKyBwb3cyIDwgJHtsZW5ndGh9YCA6ICdlbmQgPj0gcG93Mic7XG4gICAgICBpZHhTdHJpbmcgPSAocmV2ZXJzZSA/ICdlbmQgKyBwb3cyJyA6ICdlbmQgLSBwb3cyJyk7XG4gICAgfVxuXG4gICAgdGhpcy51c2VyQ29kZSA9IGBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgJHtnZXRDb29yZHNEYXRhVHlwZShyYW5rKX0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCBlbmQgPSAke2dldEZpbmFsQ29vcmQocmFuaywgJ2Nvb3JkcycsIHRoaXMub3ApfTtcbiAgICAgICAgZmxvYXQgdmFsID0gJHt2YWx9O1xuICAgICAgICBpbnQgcG93MiA9IGludChwb3coMi4wLCBpbmRleCkpO1xuICAgICAgICBpZiAoJHtjb25kaXRpb259KSB7XG4gICAgICAgICAgaW50IGlkeCA9ICR7aWR4U3RyaW5nfTtcbiAgICAgICAgICAke2dldEZpbmFsQ29vcmQocmFuaywgJ2Nvb3JkcycsIHRoaXMub3ApfSA9IGlkeDtcbiAgICAgICAgICB2YWwgJHt0aGlzLm9wfT0gZ2V0WCgke2dldENvb3JkcyhyYW5rLCAnY29vcmRzJywgdGhpcy5vcCl9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRPdXRwdXQodmFsKTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldENvb3JkcyhyYW5rOiBudW1iZXIsIG5hbWU6IHN0cmluZywgb3A6IEN1bU9wVHlwZSk6IHN0cmluZyB7XG4gIGlmIChyYW5rID09PSAxKSB7XG4gICAgcmV0dXJuIGAke25hbWV9YDtcbiAgfSBlbHNlIGlmIChyYW5rID09PSAyKSB7XG4gICAgcmV0dXJuIGAke25hbWV9LngsICR7bmFtZX0ueWA7XG4gIH0gZWxzZSBpZiAocmFuayA9PT0gMykge1xuICAgIHJldHVybiBgJHtuYW1lfS54LCAke25hbWV9LnksICR7bmFtZX0uemA7XG4gIH0gZWxzZSBpZiAocmFuayA9PT0gNCkge1xuICAgIHJldHVybiBgJHtuYW1lfS54LCAke25hbWV9LnksICR7bmFtZX0ueiwgJHtuYW1lfS53YDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEN1bXVsYXRpdmUgJHtvcH0gZm9yIHJhbmsgJHtyYW5rfSBpcyBub3QgeWV0IHN1cHBvcnRlZGApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEZpbmFsQ29vcmQocmFuazogbnVtYmVyLCBuYW1lOiBzdHJpbmcsIG9wOiBDdW1PcFR5cGUpOiBzdHJpbmcge1xuICBpZiAocmFuayA9PT0gMSkge1xuICAgIHJldHVybiBgJHtuYW1lfWA7XG4gIH0gZWxzZSBpZiAocmFuayA9PT0gMikge1xuICAgIHJldHVybiBgJHtuYW1lfS55YDtcbiAgfSBlbHNlIGlmIChyYW5rID09PSAzKSB7XG4gICAgcmV0dXJuIGAke25hbWV9LnpgO1xuICB9IGVsc2UgaWYgKHJhbmsgPT09IDQpIHtcbiAgICByZXR1cm4gYCR7bmFtZX0ud2A7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDdW11bGF0aXZlICR7b3B9IGZvciByYW5rICR7cmFua30gaXMgbm90IHlldCBzdXBwb3J0ZWRgKTtcbiAgfVxufVxuIl19"],"names":["ConcatProgram","constructor","shapes","this","outputShape","variableNames","map","_","i","offsets","Array","length","snippets","shift","push","lastIndex","lastShift","userCode","join","ConcatPackedProgram","axis","packedInputs","packedOutput","shape","rank","dtype","coords","channels","slice","channel","lastChannels","allChannels","getValueSnippet","shiftedChannels","x","channelIdx","indexOf","res","c","idx","Conv2DDerFilterProgram","convInfo","filterShape","strideHeight","strideWidth","padTop","padInfo","top","padLeft","left","isChannelsLast","dataFormat","batchSize","outHeight","inHeight","outWidth","inWidth","Conv2DDerInputProgram","inShape","filterHeight","filterWidth","rowDim","colDim","channelDim","outChannels","Conv3DDerFilterProgram","strideDepth","padFront","front","outDepth","inDepth","Conv3DDerInputProgram","filterDepth","DepthwiseConv2DDerFilterProgram","channelMul","inChannels","DepthwiseConv2DDerInputProgram","Conv2DDerInputPackedProgram","customUniforms","name","type","enableShapeUniforms","Conv2DProgram","addBias","activation","hasPreluActivationWeights","hasLeakyreluAlpha","outShape","dilationHeight","dilationWidth","inputDepthNearestVec4","Math","floor","inputDepthVec4Remainder","activationSnippet","applyActivationSnippet","addBiasSnippet","Conv3DProgram","dilationDepth","DepthwiseConv2DProgram","hasPreluActivation","hasLeakyReluAlpha","Conv2DPackedProgram","texelsAcross","mainLoop","texelC","colIndex","nextTexelOffset","DepthwiseConvPacked2DProgram","CropAndResizeProgram","imageShape","boxShape","cropSize","method","extrapolationValue","batch","imageHeight","imageWidth","depth","numBoxes","cropHeight","cropWidth","methodId","inputHeightFloat","inputWidthFloat","heightRatio","heightScale","inY","widthRatio","widthScale","inX","CumOpType","CumProgram","op","exclusive","reverse","initVal","Prod","val","getCoords","condition","idxString","getFinalCoord","Error"],"sourceRoot":""}