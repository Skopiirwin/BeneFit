{"version":3,"file":"js/chunk-vendors-df3a2acc.a1fdf0c4.js","mappings":"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","sources":["webpack://benefit/./node_modules/@tensorflow/tfjs-core/dist/index.js","webpack://benefit/./node_modules/@tensorflow/tfjs-core/dist/io/browser_files.js","webpack://benefit/./node_modules/@tensorflow/tfjs-core/dist/io/composite_array_buffer.js"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// Required side effectful code.\nimport './base_side_effects';\n// TODO(mattSoulanille): Move this to base_side_effects.ts\n// It is here for now because custom bundles need to avoid calling it, and they\n// only replace the index.js file, not the base_side_effects file.\nimport { registerOptimizers } from './optimizers/register_optimizers';\nregisterOptimizers();\n// All exports from this package should be in base.\nexport * from './base';\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi90ZmpzLWNvcmUvc3JjL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUVILGdDQUFnQztBQUNoQyxPQUFPLHFCQUFxQixDQUFDO0FBRTdCLDBEQUEwRDtBQUMxRCwrRUFBK0U7QUFDL0Usa0VBQWtFO0FBQ2xFLE9BQU8sRUFBQyxrQkFBa0IsRUFBQyxNQUFNLGtDQUFrQyxDQUFDO0FBQ3BFLGtCQUFrQixFQUFFLENBQUM7QUFFckIsbURBQW1EO0FBQ25ELGNBQWMsUUFBUSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vLyBSZXF1aXJlZCBzaWRlIGVmZmVjdGZ1bCBjb2RlLlxuaW1wb3J0ICcuL2Jhc2Vfc2lkZV9lZmZlY3RzJztcblxuLy8gVE9ETyhtYXR0U291bGFuaWxsZSk6IE1vdmUgdGhpcyB0byBiYXNlX3NpZGVfZWZmZWN0cy50c1xuLy8gSXQgaXMgaGVyZSBmb3Igbm93IGJlY2F1c2UgY3VzdG9tIGJ1bmRsZXMgbmVlZCB0byBhdm9pZCBjYWxsaW5nIGl0LCBhbmQgdGhleVxuLy8gb25seSByZXBsYWNlIHRoZSBpbmRleC5qcyBmaWxlLCBub3QgdGhlIGJhc2Vfc2lkZV9lZmZlY3RzIGZpbGUuXG5pbXBvcnQge3JlZ2lzdGVyT3B0aW1pemVyc30gZnJvbSAnLi9vcHRpbWl6ZXJzL3JlZ2lzdGVyX29wdGltaXplcnMnO1xucmVnaXN0ZXJPcHRpbWl6ZXJzKCk7XG5cbi8vIEFsbCBleHBvcnRzIGZyb20gdGhpcyBwYWNrYWdlIHNob3VsZCBiZSBpbiBiYXNlLlxuZXhwb3J0ICogZnJvbSAnLi9iYXNlJztcbiJdfQ==","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * IOHandlers related to files, such as browser-triggered file downloads,\n * user-selected files in browser.\n */\nimport '../flags';\nimport { env } from '../environment';\nimport { basename, getModelArtifactsForJSON, getModelArtifactsInfoForJSON, getModelJSONForModelArtifacts } from './io_utils';\nimport { IORouterRegistry } from './router_registry';\nimport { CompositeArrayBuffer } from './composite_array_buffer';\nconst DEFAULT_FILE_NAME_PREFIX = 'model';\nconst DEFAULT_JSON_EXTENSION_NAME = '.json';\nconst DEFAULT_WEIGHT_DATA_EXTENSION_NAME = '.weights.bin';\nfunction defer(f) {\n    return new Promise(resolve => setTimeout(resolve)).then(f);\n}\nclass BrowserDownloads {\n    constructor(fileNamePrefix) {\n        if (!env().getBool('IS_BROWSER')) {\n            // TODO(cais): Provide info on what IOHandlers are available under the\n            //   current environment.\n            throw new Error('browserDownloads() cannot proceed because the current environment ' +\n                'is not a browser.');\n        }\n        if (fileNamePrefix.startsWith(BrowserDownloads.URL_SCHEME)) {\n            fileNamePrefix = fileNamePrefix.slice(BrowserDownloads.URL_SCHEME.length);\n        }\n        if (fileNamePrefix == null || fileNamePrefix.length === 0) {\n            fileNamePrefix = DEFAULT_FILE_NAME_PREFIX;\n        }\n        this.modelJsonFileName = fileNamePrefix + DEFAULT_JSON_EXTENSION_NAME;\n        this.weightDataFileName =\n            fileNamePrefix + DEFAULT_WEIGHT_DATA_EXTENSION_NAME;\n    }\n    async save(modelArtifacts) {\n        if (typeof (document) === 'undefined') {\n            throw new Error('Browser downloads are not supported in ' +\n                'this environment since `document` is not present');\n        }\n        // TODO(mattsoulanille): Support saving models over 2GB that exceed\n        // Chrome's ArrayBuffer size limit.\n        const weightBuffer = CompositeArrayBuffer.join(modelArtifacts.weightData);\n        const weightsURL = window.URL.createObjectURL(new Blob([weightBuffer], { type: 'application/octet-stream' }));\n        if (modelArtifacts.modelTopology instanceof ArrayBuffer) {\n            throw new Error('BrowserDownloads.save() does not support saving model topology ' +\n                'in binary formats yet.');\n        }\n        else {\n            const weightsManifest = [{\n                    paths: ['./' + this.weightDataFileName],\n                    weights: modelArtifacts.weightSpecs\n                }];\n            const modelJSON = getModelJSONForModelArtifacts(modelArtifacts, weightsManifest);\n            const modelJsonURL = window.URL.createObjectURL(new Blob([JSON.stringify(modelJSON)], { type: 'application/json' }));\n            // If anchor elements are not provided, create them without attaching them\n            // to parents, so that the downloaded file names can be controlled.\n            const jsonAnchor = this.modelJsonAnchor == null ?\n                document.createElement('a') :\n                this.modelJsonAnchor;\n            jsonAnchor.download = this.modelJsonFileName;\n            jsonAnchor.href = modelJsonURL;\n            // Trigger downloads by evoking a click event on the download anchors.\n            // When multiple downloads are started synchronously, Firefox will only\n            // save the last one.\n            await defer(() => jsonAnchor.dispatchEvent(new MouseEvent('click')));\n            if (modelArtifacts.weightData != null) {\n                const weightDataAnchor = this.weightDataAnchor == null ?\n                    document.createElement('a') :\n                    this.weightDataAnchor;\n                weightDataAnchor.download = this.weightDataFileName;\n                weightDataAnchor.href = weightsURL;\n                await defer(() => weightDataAnchor.dispatchEvent(new MouseEvent('click')));\n            }\n            return { modelArtifactsInfo: getModelArtifactsInfoForJSON(modelArtifacts) };\n        }\n    }\n}\nBrowserDownloads.URL_SCHEME = 'downloads://';\nexport { BrowserDownloads };\nclass BrowserFiles {\n    constructor(files) {\n        if (files == null || files.length < 1) {\n            throw new Error(`When calling browserFiles, at least 1 file is required, ` +\n                `but received ${files}`);\n        }\n        this.jsonFile = files[0];\n        this.weightsFiles = files.slice(1);\n    }\n    async load() {\n        return new Promise((resolve, reject) => {\n            const jsonReader = new FileReader();\n            jsonReader.onload = (event) => {\n                // tslint:disable-next-line:no-any\n                const modelJSON = JSON.parse(event.target.result);\n                const modelTopology = modelJSON.modelTopology;\n                if (modelTopology == null) {\n                    reject(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));\n                    return;\n                }\n                const weightsManifest = modelJSON.weightsManifest;\n                if (weightsManifest == null) {\n                    reject(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));\n                    return;\n                }\n                if (this.weightsFiles.length === 0) {\n                    resolve({ modelTopology });\n                    return;\n                }\n                const modelArtifactsPromise = getModelArtifactsForJSON(modelJSON, (weightsManifest) => this.loadWeights(weightsManifest));\n                resolve(modelArtifactsPromise);\n            };\n            jsonReader.onerror = error => reject(`Failed to read model topology and weights manifest JSON ` +\n                `from file '${this.jsonFile.name}'. BrowserFiles supports loading ` +\n                `Keras-style tf.Model artifacts only.`);\n            jsonReader.readAsText(this.jsonFile);\n        });\n    }\n    loadWeights(weightsManifest) {\n        const weightSpecs = [];\n        const paths = [];\n        for (const entry of weightsManifest) {\n            weightSpecs.push(...entry.weights);\n            paths.push(...entry.paths);\n        }\n        const pathToFile = this.checkManifestAndWeightFiles(weightsManifest);\n        const promises = paths.map(path => this.loadWeightsFile(path, pathToFile[path]));\n        return Promise.all(promises).then(buffers => [weightSpecs, buffers]);\n    }\n    loadWeightsFile(path, file) {\n        return new Promise((resolve, reject) => {\n            const weightFileReader = new FileReader();\n            weightFileReader.onload = (event) => {\n                // tslint:disable-next-line:no-any\n                const weightData = event.target.result;\n                resolve(weightData);\n            };\n            weightFileReader.onerror = error => reject(`Failed to weights data from file of path '${path}'.`);\n            weightFileReader.readAsArrayBuffer(file);\n        });\n    }\n    /**\n     * Check the compatibility between weights manifest and weight files.\n     */\n    checkManifestAndWeightFiles(manifest) {\n        const basenames = [];\n        const fileNames = this.weightsFiles.map(file => basename(file.name));\n        const pathToFile = {};\n        for (const group of manifest) {\n            group.paths.forEach(path => {\n                const pathBasename = basename(path);\n                if (basenames.indexOf(pathBasename) !== -1) {\n                    throw new Error(`Duplicate file basename found in weights manifest: ` +\n                        `'${pathBasename}'`);\n                }\n                basenames.push(pathBasename);\n                if (fileNames.indexOf(pathBasename) === -1) {\n                    throw new Error(`Weight file with basename '${pathBasename}' is not provided.`);\n                }\n                else {\n                    pathToFile[path] = this.weightsFiles[fileNames.indexOf(pathBasename)];\n                }\n            });\n        }\n        if (basenames.length !== this.weightsFiles.length) {\n            throw new Error(`Mismatch in the number of files in weights manifest ` +\n                `(${basenames.length}) and the number of weight files provided ` +\n                `(${this.weightsFiles.length}).`);\n        }\n        return pathToFile;\n    }\n}\nexport const browserDownloadsRouter = (url) => {\n    if (!env().getBool('IS_BROWSER')) {\n        return null;\n    }\n    else {\n        if (!Array.isArray(url) && url.startsWith(BrowserDownloads.URL_SCHEME)) {\n            return browserDownloads(url.slice(BrowserDownloads.URL_SCHEME.length));\n        }\n        else {\n            return null;\n        }\n    }\n};\nIORouterRegistry.registerSaveRouter(browserDownloadsRouter);\n/**\n * Creates an IOHandler that triggers file downloads from the browser.\n *\n * The returned `IOHandler` instance can be used as model exporting methods such\n * as `tf.Model.save` and supports only saving.\n *\n * ```js\n * const model = tf.sequential();\n * model.add(tf.layers.dense(\n *     {units: 1, inputShape: [10], activation: 'sigmoid'}));\n * const saveResult = await model.save('downloads://mymodel');\n * // This will trigger downloading of two files:\n * //   'mymodel.json' and 'mymodel.weights.bin'.\n * console.log(saveResult);\n * ```\n *\n * @param fileNamePrefix Prefix name of the files to be downloaded. For use with\n *   `tf.Model`, `fileNamePrefix` should follow either of the following two\n *   formats:\n *   1. `null` or `undefined`, in which case the default file\n *      names will be used:\n *      - 'model.json' for the JSON file containing the model topology and\n *        weights manifest.\n *      - 'model.weights.bin' for the binary file containing the binary weight\n *        values.\n *   2. A single string or an Array of a single string, as the file name prefix.\n *      For example, if `'foo'` is provided, the downloaded JSON\n *      file and binary weights file will be named 'foo.json' and\n *      'foo.weights.bin', respectively.\n * @param config Additional configuration for triggering downloads.\n * @returns An instance of `BrowserDownloads` `IOHandler`.\n *\n * @doc {\n *   heading: 'Models',\n *   subheading: 'Loading',\n *   namespace: 'io',\n *   ignoreCI: true\n * }\n */\nexport function browserDownloads(fileNamePrefix = 'model') {\n    return new BrowserDownloads(fileNamePrefix);\n}\n/**\n * Creates an IOHandler that loads model artifacts from user-selected files.\n *\n * This method can be used for loading from files such as user-selected files\n * in the browser.\n * When used in conjunction with `tf.loadLayersModel`, an instance of\n * `tf.LayersModel` (Keras-style) can be constructed from the loaded artifacts.\n *\n * ```js\n * // Note: This code snippet won't run properly without the actual file input\n * //   elements in the HTML DOM.\n *\n * // Suppose there are two HTML file input (`<input type=\"file\" ...>`)\n * // elements.\n * const uploadJSONInput = document.getElementById('upload-json');\n * const uploadWeightsInput = document.getElementById('upload-weights');\n * const model = await tf.loadLayersModel(tf.io.browserFiles(\n *     [uploadJSONInput.files[0], uploadWeightsInput.files[0]]));\n * ```\n *\n * @param files `File`s to load from. Currently, this function supports only\n *   loading from files that contain Keras-style models (i.e., `tf.Model`s), for\n *   which an `Array` of `File`s is expected (in that order):\n *   - A JSON file containing the model topology and weight manifest.\n *   - Optionally, one or more binary files containing the binary weights.\n *     These files must have names that match the paths in the `weightsManifest`\n *     contained by the aforementioned JSON file, or errors will be thrown\n *     during loading. These weights files have the same format as the ones\n *     generated by `tensorflowjs_converter` that comes with the `tensorflowjs`\n *     Python PIP package. If no weights files are provided, only the model\n *     topology will be loaded from the JSON file above.\n * @returns An instance of `Files` `IOHandler`.\n *\n * @doc {\n *   heading: 'Models',\n *   subheading: 'Loading',\n *   namespace: 'io',\n *   ignoreCI: true\n * }\n */\nexport function browserFiles(files) {\n    return new BrowserFiles(files);\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnJvd3Nlcl9maWxlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtY29yZS9zcmMvaW8vYnJvd3Nlcl9maWxlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSDs7O0dBR0c7QUFFSCxPQUFPLFVBQVUsQ0FBQztBQUNsQixPQUFPLEVBQUMsR0FBRyxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFFbkMsT0FBTyxFQUFDLFFBQVEsRUFBRSx3QkFBd0IsRUFBRSw0QkFBNEIsRUFBRSw2QkFBNkIsRUFBQyxNQUFNLFlBQVksQ0FBQztBQUMzSCxPQUFPLEVBQVcsZ0JBQWdCLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUU3RCxPQUFPLEVBQUMsb0JBQW9CLEVBQUMsTUFBTSwwQkFBMEIsQ0FBQztBQUU5RCxNQUFNLHdCQUF3QixHQUFHLE9BQU8sQ0FBQztBQUN6QyxNQUFNLDJCQUEyQixHQUFHLE9BQU8sQ0FBQztBQUM1QyxNQUFNLGtDQUFrQyxHQUFHLGNBQWMsQ0FBQztBQUUxRCxTQUFTLEtBQUssQ0FBSSxDQUFVO0lBQzFCLE9BQU8sSUFBSSxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDN0QsQ0FBQztBQUVELE1BQWEsZ0JBQWdCO0lBUTNCLFlBQVksY0FBdUI7UUFDakMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsRUFBRTtZQUNoQyxzRUFBc0U7WUFDdEUseUJBQXlCO1lBQ3pCLE1BQU0sSUFBSSxLQUFLLENBQ1gsb0VBQW9FO2dCQUNwRSxtQkFBbUIsQ0FBQyxDQUFDO1NBQzFCO1FBRUQsSUFBSSxjQUFjLENBQUMsVUFBVSxDQUFDLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQzFELGNBQWMsR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUMzRTtRQUNELElBQUksY0FBYyxJQUFJLElBQUksSUFBSSxjQUFjLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUN6RCxjQUFjLEdBQUcsd0JBQXdCLENBQUM7U0FDM0M7UUFFRCxJQUFJLENBQUMsaUJBQWlCLEdBQUcsY0FBYyxHQUFHLDJCQUEyQixDQUFDO1FBQ3RFLElBQUksQ0FBQyxrQkFBa0I7WUFDbkIsY0FBYyxHQUFHLGtDQUFrQyxDQUFDO0lBQzFELENBQUM7SUFFRCxLQUFLLENBQUMsSUFBSSxDQUFDLGNBQThCO1FBQ3ZDLElBQUksT0FBTyxDQUFDLFFBQVEsQ0FBQyxLQUFLLFdBQVcsRUFBRTtZQUNyQyxNQUFNLElBQUksS0FBSyxDQUNYLHlDQUF5QztnQkFDekMsa0RBQWtELENBQUMsQ0FBQztTQUN6RDtRQUVELG1FQUFtRTtRQUNuRSxtQ0FBbUM7UUFDbkMsTUFBTSxZQUFZLEdBQUcsb0JBQW9CLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUUxRSxNQUFNLFVBQVUsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQyxJQUFJLElBQUksQ0FDbEQsQ0FBQyxZQUFZLENBQUMsRUFBRSxFQUFDLElBQUksRUFBRSwwQkFBMEIsRUFBQyxDQUFDLENBQUMsQ0FBQztRQUV6RCxJQUFJLGNBQWMsQ0FBQyxhQUFhLFlBQVksV0FBVyxFQUFFO1lBQ3ZELE1BQU0sSUFBSSxLQUFLLENBQ1gsaUVBQWlFO2dCQUNqRSx3QkFBd0IsQ0FBQyxDQUFDO1NBQy9CO2FBQU07WUFDTCxNQUFNLGVBQWUsR0FBMEIsQ0FBQztvQkFDOUMsS0FBSyxFQUFFLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQztvQkFDdkMsT0FBTyxFQUFFLGNBQWMsQ0FBQyxXQUFXO2lCQUNwQyxDQUFDLENBQUM7WUFDSCxNQUFNLFNBQVMsR0FDWCw2QkFBNkIsQ0FBQyxjQUFjLEVBQUUsZUFBZSxDQUFDLENBQUM7WUFFbkUsTUFBTSxZQUFZLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQzNDLElBQUksSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLEVBQUMsSUFBSSxFQUFFLGtCQUFrQixFQUFDLENBQUMsQ0FBQyxDQUFDO1lBRXZFLDBFQUEwRTtZQUMxRSxtRUFBbUU7WUFDbkUsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLGVBQWUsSUFBSSxJQUFJLENBQUMsQ0FBQztnQkFDN0MsUUFBUSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO2dCQUM3QixJQUFJLENBQUMsZUFBZSxDQUFDO1lBQ3pCLFVBQVUsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDO1lBQzdDLFVBQVUsQ0FBQyxJQUFJLEdBQUcsWUFBWSxDQUFDO1lBQy9CLHNFQUFzRTtZQUN0RSx1RUFBdUU7WUFDdkUscUJBQXFCO1lBQ3JCLE1BQU0sS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsSUFBSSxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRXJFLElBQUksY0FBYyxDQUFDLFVBQVUsSUFBSSxJQUFJLEVBQUU7Z0JBQ3JDLE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixJQUFJLElBQUksQ0FBQyxDQUFDO29CQUNwRCxRQUFRLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7b0JBQzdCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQztnQkFDMUIsZ0JBQWdCLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQztnQkFDcEQsZ0JBQWdCLENBQUMsSUFBSSxHQUFHLFVBQVUsQ0FBQztnQkFDbkMsTUFBTSxLQUFLLENBQ1AsR0FBRyxFQUFFLENBQUMsZ0JBQWdCLENBQUMsYUFBYSxDQUFDLElBQUksVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNwRTtZQUVELE9BQU8sRUFBQyxrQkFBa0IsRUFBRSw0QkFBNEIsQ0FBQyxjQUFjLENBQUMsRUFBQyxDQUFDO1NBQzNFO0lBQ0gsQ0FBQzs7QUE1RWUsMkJBQVUsR0FBRyxjQUFjLENBQUM7U0FOakMsZ0JBQWdCO0FBcUY3QixNQUFNLFlBQVk7SUFJaEIsWUFBWSxLQUFhO1FBQ3ZCLElBQUksS0FBSyxJQUFJLElBQUksSUFBSSxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUNyQyxNQUFNLElBQUksS0FBSyxDQUNYLDBEQUEwRDtnQkFDMUQsZ0JBQWdCLEtBQUssRUFBRSxDQUFDLENBQUM7U0FDOUI7UUFDRCxJQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN6QixJQUFJLENBQUMsWUFBWSxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVELEtBQUssQ0FBQyxJQUFJO1FBQ1IsT0FBTyxJQUFJLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsRUFBRTtZQUNyQyxNQUFNLFVBQVUsR0FBRyxJQUFJLFVBQVUsRUFBRSxDQUFDO1lBQ3BDLFVBQVUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxLQUFZLEVBQUUsRUFBRTtnQkFDbkMsa0NBQWtDO2dCQUNsQyxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFFLEtBQUssQ0FBQyxNQUFjLENBQUMsTUFBTSxDQUFjLENBQUM7Z0JBRXhFLE1BQU0sYUFBYSxHQUFHLFNBQVMsQ0FBQyxhQUFhLENBQUM7Z0JBQzlDLElBQUksYUFBYSxJQUFJLElBQUksRUFBRTtvQkFDekIsTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLDRDQUNiLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO29CQUMzQixPQUFPO2lCQUNSO2dCQUVELE1BQU0sZUFBZSxHQUFHLFNBQVMsQ0FBQyxlQUFlLENBQUM7Z0JBQ2xELElBQUksZUFBZSxJQUFJLElBQUksRUFBRTtvQkFDM0IsTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLDZDQUNiLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO29CQUMzQixPQUFPO2lCQUNSO2dCQUVELElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO29CQUNsQyxPQUFPLENBQUMsRUFBQyxhQUFhLEVBQUMsQ0FBQyxDQUFDO29CQUN6QixPQUFPO2lCQUNSO2dCQUVELE1BQU0scUJBQXFCLEdBQUcsd0JBQXdCLENBQ2xELFNBQVMsRUFBRSxDQUFDLGVBQWUsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDO2dCQUN2RSxPQUFPLENBQUMscUJBQXFCLENBQUMsQ0FBQztZQUNqQyxDQUFDLENBQUM7WUFFRixVQUFVLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUNoQywwREFBMEQ7Z0JBQzFELGNBQWMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLG1DQUFtQztnQkFDbkUsc0NBQXNDLENBQUMsQ0FBQztZQUM1QyxVQUFVLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUN2QyxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFTyxXQUFXLENBQUMsZUFBc0M7UUFHeEQsTUFBTSxXQUFXLEdBQTJCLEVBQUUsQ0FBQztRQUMvQyxNQUFNLEtBQUssR0FBYSxFQUFFLENBQUM7UUFDM0IsS0FBSyxNQUFNLEtBQUssSUFBSSxlQUFlLEVBQUU7WUFDbkMsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNuQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQzVCO1FBRUQsTUFBTSxVQUFVLEdBQ1osSUFBSSxDQUFDLDJCQUEyQixDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBRXRELE1BQU0sUUFBUSxHQUNWLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRXBFLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQzdCLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBRU8sZUFBZSxDQUFDLElBQVksRUFBRSxJQUFVO1FBQzlDLE9BQU8sSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLEVBQUU7WUFDckMsTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLFVBQVUsRUFBRSxDQUFDO1lBQzFDLGdCQUFnQixDQUFDLE1BQU0sR0FBRyxDQUFDLEtBQVksRUFBRSxFQUFFO2dCQUN6QyxrQ0FBa0M7Z0JBQ2xDLE1BQU0sVUFBVSxHQUFJLEtBQUssQ0FBQyxNQUFjLENBQUMsTUFBcUIsQ0FBQztnQkFDL0QsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ3RCLENBQUMsQ0FBQztZQUNGLGdCQUFnQixDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUMsRUFBRSxDQUMvQixNQUFNLENBQUMsNkNBQTZDLElBQUksSUFBSSxDQUFDLENBQUM7WUFDbEUsZ0JBQWdCLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDM0MsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQ7O09BRUc7SUFDSywyQkFBMkIsQ0FBQyxRQUErQjtRQUVqRSxNQUFNLFNBQVMsR0FBYSxFQUFFLENBQUM7UUFDL0IsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDckUsTUFBTSxVQUFVLEdBQTJCLEVBQUUsQ0FBQztRQUM5QyxLQUFLLE1BQU0sS0FBSyxJQUFJLFFBQVEsRUFBRTtZQUM1QixLQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDekIsTUFBTSxZQUFZLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUNwQyxJQUFJLFNBQVMsQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7b0JBQzFDLE1BQU0sSUFBSSxLQUFLLENBQ1gscURBQXFEO3dCQUNyRCxJQUFJLFlBQVksR0FBRyxDQUFDLENBQUM7aUJBQzFCO2dCQUNELFNBQVMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7Z0JBQzdCLElBQUksU0FBUyxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtvQkFDMUMsTUFBTSxJQUFJLEtBQUssQ0FDWCw4QkFBOEIsWUFBWSxvQkFBb0IsQ0FBQyxDQUFDO2lCQUNyRTtxQkFBTTtvQkFDTCxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7aUJBQ3ZFO1lBQ0gsQ0FBQyxDQUFDLENBQUM7U0FDSjtRQUVELElBQUksU0FBUyxDQUFDLE1BQU0sS0FBSyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRTtZQUNqRCxNQUFNLElBQUksS0FBSyxDQUNYLHNEQUFzRDtnQkFDdEQsSUFBSSxTQUFTLENBQUMsTUFBTSw0Q0FBNEM7Z0JBQ2hFLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLElBQUksQ0FBQyxDQUFDO1NBQ3ZDO1FBQ0QsT0FBTyxVQUFVLENBQUM7SUFDcEIsQ0FBQztDQUNGO0FBRUQsTUFBTSxDQUFDLE1BQU0sc0JBQXNCLEdBQWEsQ0FBQyxHQUFvQixFQUFFLEVBQUU7SUFDdkUsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsRUFBRTtRQUNoQyxPQUFPLElBQUksQ0FBQztLQUNiO1NBQU07UUFDTCxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxHQUFHLENBQUMsVUFBVSxDQUFDLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQ3RFLE9BQU8sZ0JBQWdCLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztTQUN4RTthQUFNO1lBQ0wsT0FBTyxJQUFJLENBQUM7U0FDYjtLQUNGO0FBQ0gsQ0FBQyxDQUFDO0FBQ0YsZ0JBQWdCLENBQUMsa0JBQWtCLENBQUMsc0JBQXNCLENBQUMsQ0FBQztBQUU1RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FzQ0c7QUFDSCxNQUFNLFVBQVUsZ0JBQWdCLENBQUMsY0FBYyxHQUFHLE9BQU87SUFDdkQsT0FBTyxJQUFJLGdCQUFnQixDQUFDLGNBQWMsQ0FBQyxDQUFDO0FBQzlDLENBQUM7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBdUNHO0FBQ0gsTUFBTSxVQUFVLFlBQVksQ0FBQyxLQUFhO0lBQ3hDLE9BQU8sSUFBSSxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDakMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuLyoqXG4gKiBJT0hhbmRsZXJzIHJlbGF0ZWQgdG8gZmlsZXMsIHN1Y2ggYXMgYnJvd3Nlci10cmlnZ2VyZWQgZmlsZSBkb3dubG9hZHMsXG4gKiB1c2VyLXNlbGVjdGVkIGZpbGVzIGluIGJyb3dzZXIuXG4gKi9cblxuaW1wb3J0ICcuLi9mbGFncyc7XG5pbXBvcnQge2Vudn0gZnJvbSAnLi4vZW52aXJvbm1lbnQnO1xuXG5pbXBvcnQge2Jhc2VuYW1lLCBnZXRNb2RlbEFydGlmYWN0c0ZvckpTT04sIGdldE1vZGVsQXJ0aWZhY3RzSW5mb0ZvckpTT04sIGdldE1vZGVsSlNPTkZvck1vZGVsQXJ0aWZhY3RzfSBmcm9tICcuL2lvX3V0aWxzJztcbmltcG9ydCB7SU9Sb3V0ZXIsIElPUm91dGVyUmVnaXN0cnl9IGZyb20gJy4vcm91dGVyX3JlZ2lzdHJ5JztcbmltcG9ydCB7SU9IYW5kbGVyLCBNb2RlbEFydGlmYWN0cywgTW9kZWxKU09OLCBTYXZlUmVzdWx0LCBXZWlnaHREYXRhLCBXZWlnaHRzTWFuaWZlc3RDb25maWcsIFdlaWdodHNNYW5pZmVzdEVudHJ5fSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7Q29tcG9zaXRlQXJyYXlCdWZmZXJ9IGZyb20gJy4vY29tcG9zaXRlX2FycmF5X2J1ZmZlcic7XG5cbmNvbnN0IERFRkFVTFRfRklMRV9OQU1FX1BSRUZJWCA9ICdtb2RlbCc7XG5jb25zdCBERUZBVUxUX0pTT05fRVhURU5TSU9OX05BTUUgPSAnLmpzb24nO1xuY29uc3QgREVGQVVMVF9XRUlHSFRfREFUQV9FWFRFTlNJT05fTkFNRSA9ICcud2VpZ2h0cy5iaW4nO1xuXG5mdW5jdGlvbiBkZWZlcjxUPihmOiAoKSA9PiBUKTogUHJvbWlzZTxUPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSkpLnRoZW4oZik7XG59XG5cbmV4cG9ydCBjbGFzcyBCcm93c2VyRG93bmxvYWRzIGltcGxlbWVudHMgSU9IYW5kbGVyIHtcbiAgcHJpdmF0ZSByZWFkb25seSBtb2RlbEpzb25GaWxlTmFtZTogc3RyaW5nO1xuICBwcml2YXRlIHJlYWRvbmx5IHdlaWdodERhdGFGaWxlTmFtZTogc3RyaW5nO1xuICBwcml2YXRlIHJlYWRvbmx5IG1vZGVsSnNvbkFuY2hvcjogSFRNTEFuY2hvckVsZW1lbnQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgd2VpZ2h0RGF0YUFuY2hvcjogSFRNTEFuY2hvckVsZW1lbnQ7XG5cbiAgc3RhdGljIHJlYWRvbmx5IFVSTF9TQ0hFTUUgPSAnZG93bmxvYWRzOi8vJztcblxuICBjb25zdHJ1Y3RvcihmaWxlTmFtZVByZWZpeD86IHN0cmluZykge1xuICAgIGlmICghZW52KCkuZ2V0Qm9vbCgnSVNfQlJPV1NFUicpKSB7XG4gICAgICAvLyBUT0RPKGNhaXMpOiBQcm92aWRlIGluZm8gb24gd2hhdCBJT0hhbmRsZXJzIGFyZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gICAgICAvLyAgIGN1cnJlbnQgZW52aXJvbm1lbnQuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ2Jyb3dzZXJEb3dubG9hZHMoKSBjYW5ub3QgcHJvY2VlZCBiZWNhdXNlIHRoZSBjdXJyZW50IGVudmlyb25tZW50ICcgK1xuICAgICAgICAgICdpcyBub3QgYSBicm93c2VyLicpO1xuICAgIH1cblxuICAgIGlmIChmaWxlTmFtZVByZWZpeC5zdGFydHNXaXRoKEJyb3dzZXJEb3dubG9hZHMuVVJMX1NDSEVNRSkpIHtcbiAgICAgIGZpbGVOYW1lUHJlZml4ID0gZmlsZU5hbWVQcmVmaXguc2xpY2UoQnJvd3NlckRvd25sb2Fkcy5VUkxfU0NIRU1FLmxlbmd0aCk7XG4gICAgfVxuICAgIGlmIChmaWxlTmFtZVByZWZpeCA9PSBudWxsIHx8IGZpbGVOYW1lUHJlZml4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgZmlsZU5hbWVQcmVmaXggPSBERUZBVUxUX0ZJTEVfTkFNRV9QUkVGSVg7XG4gICAgfVxuXG4gICAgdGhpcy5tb2RlbEpzb25GaWxlTmFtZSA9IGZpbGVOYW1lUHJlZml4ICsgREVGQVVMVF9KU09OX0VYVEVOU0lPTl9OQU1FO1xuICAgIHRoaXMud2VpZ2h0RGF0YUZpbGVOYW1lID1cbiAgICAgICAgZmlsZU5hbWVQcmVmaXggKyBERUZBVUxUX1dFSUdIVF9EQVRBX0VYVEVOU0lPTl9OQU1FO1xuICB9XG5cbiAgYXN5bmMgc2F2ZShtb2RlbEFydGlmYWN0czogTW9kZWxBcnRpZmFjdHMpOiBQcm9taXNlPFNhdmVSZXN1bHQ+IHtcbiAgICBpZiAodHlwZW9mIChkb2N1bWVudCkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0Jyb3dzZXIgZG93bmxvYWRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICcgK1xuICAgICAgICAgICd0aGlzIGVudmlyb25tZW50IHNpbmNlIGBkb2N1bWVudGAgaXMgbm90IHByZXNlbnQnKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPKG1hdHRzb3VsYW5pbGxlKTogU3VwcG9ydCBzYXZpbmcgbW9kZWxzIG92ZXIgMkdCIHRoYXQgZXhjZWVkXG4gICAgLy8gQ2hyb21lJ3MgQXJyYXlCdWZmZXIgc2l6ZSBsaW1pdC5cbiAgICBjb25zdCB3ZWlnaHRCdWZmZXIgPSBDb21wb3NpdGVBcnJheUJ1ZmZlci5qb2luKG1vZGVsQXJ0aWZhY3RzLndlaWdodERhdGEpO1xuXG4gICAgY29uc3Qgd2VpZ2h0c1VSTCA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFxuICAgICAgICBbd2VpZ2h0QnVmZmVyXSwge3R5cGU6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nfSkpO1xuXG4gICAgaWYgKG1vZGVsQXJ0aWZhY3RzLm1vZGVsVG9wb2xvZ3kgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdCcm93c2VyRG93bmxvYWRzLnNhdmUoKSBkb2VzIG5vdCBzdXBwb3J0IHNhdmluZyBtb2RlbCB0b3BvbG9neSAnICtcbiAgICAgICAgICAnaW4gYmluYXJ5IGZvcm1hdHMgeWV0LicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB3ZWlnaHRzTWFuaWZlc3Q6IFdlaWdodHNNYW5pZmVzdENvbmZpZyA9IFt7XG4gICAgICAgIHBhdGhzOiBbJy4vJyArIHRoaXMud2VpZ2h0RGF0YUZpbGVOYW1lXSxcbiAgICAgICAgd2VpZ2h0czogbW9kZWxBcnRpZmFjdHMud2VpZ2h0U3BlY3NcbiAgICAgIH1dO1xuICAgICAgY29uc3QgbW9kZWxKU09OOiBNb2RlbEpTT04gPVxuICAgICAgICAgIGdldE1vZGVsSlNPTkZvck1vZGVsQXJ0aWZhY3RzKG1vZGVsQXJ0aWZhY3RzLCB3ZWlnaHRzTWFuaWZlc3QpO1xuXG4gICAgICBjb25zdCBtb2RlbEpzb25VUkwgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChcbiAgICAgICAgICBuZXcgQmxvYihbSlNPTi5zdHJpbmdpZnkobW9kZWxKU09OKV0sIHt0eXBlOiAnYXBwbGljYXRpb24vanNvbid9KSk7XG5cbiAgICAgIC8vIElmIGFuY2hvciBlbGVtZW50cyBhcmUgbm90IHByb3ZpZGVkLCBjcmVhdGUgdGhlbSB3aXRob3V0IGF0dGFjaGluZyB0aGVtXG4gICAgICAvLyB0byBwYXJlbnRzLCBzbyB0aGF0IHRoZSBkb3dubG9hZGVkIGZpbGUgbmFtZXMgY2FuIGJlIGNvbnRyb2xsZWQuXG4gICAgICBjb25zdCBqc29uQW5jaG9yID0gdGhpcy5tb2RlbEpzb25BbmNob3IgPT0gbnVsbCA/XG4gICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpIDpcbiAgICAgICAgICB0aGlzLm1vZGVsSnNvbkFuY2hvcjtcbiAgICAgIGpzb25BbmNob3IuZG93bmxvYWQgPSB0aGlzLm1vZGVsSnNvbkZpbGVOYW1lO1xuICAgICAganNvbkFuY2hvci5ocmVmID0gbW9kZWxKc29uVVJMO1xuICAgICAgLy8gVHJpZ2dlciBkb3dubG9hZHMgYnkgZXZva2luZyBhIGNsaWNrIGV2ZW50IG9uIHRoZSBkb3dubG9hZCBhbmNob3JzLlxuICAgICAgLy8gV2hlbiBtdWx0aXBsZSBkb3dubG9hZHMgYXJlIHN0YXJ0ZWQgc3luY2hyb25vdXNseSwgRmlyZWZveCB3aWxsIG9ubHlcbiAgICAgIC8vIHNhdmUgdGhlIGxhc3Qgb25lLlxuICAgICAgYXdhaXQgZGVmZXIoKCkgPT4ganNvbkFuY2hvci5kaXNwYXRjaEV2ZW50KG5ldyBNb3VzZUV2ZW50KCdjbGljaycpKSk7XG5cbiAgICAgIGlmIChtb2RlbEFydGlmYWN0cy53ZWlnaHREYXRhICE9IG51bGwpIHtcbiAgICAgICAgY29uc3Qgd2VpZ2h0RGF0YUFuY2hvciA9IHRoaXMud2VpZ2h0RGF0YUFuY2hvciA9PSBudWxsID9cbiAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKSA6XG4gICAgICAgICAgICB0aGlzLndlaWdodERhdGFBbmNob3I7XG4gICAgICAgIHdlaWdodERhdGFBbmNob3IuZG93bmxvYWQgPSB0aGlzLndlaWdodERhdGFGaWxlTmFtZTtcbiAgICAgICAgd2VpZ2h0RGF0YUFuY2hvci5ocmVmID0gd2VpZ2h0c1VSTDtcbiAgICAgICAgYXdhaXQgZGVmZXIoXG4gICAgICAgICAgICAoKSA9PiB3ZWlnaHREYXRhQW5jaG9yLmRpc3BhdGNoRXZlbnQobmV3IE1vdXNlRXZlbnQoJ2NsaWNrJykpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHttb2RlbEFydGlmYWN0c0luZm86IGdldE1vZGVsQXJ0aWZhY3RzSW5mb0ZvckpTT04obW9kZWxBcnRpZmFjdHMpfTtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgQnJvd3NlckZpbGVzIGltcGxlbWVudHMgSU9IYW5kbGVyIHtcbiAgcHJpdmF0ZSByZWFkb25seSBqc29uRmlsZTogRmlsZTtcbiAgcHJpdmF0ZSByZWFkb25seSB3ZWlnaHRzRmlsZXM6IEZpbGVbXTtcblxuICBjb25zdHJ1Y3RvcihmaWxlczogRmlsZVtdKSB7XG4gICAgaWYgKGZpbGVzID09IG51bGwgfHwgZmlsZXMubGVuZ3RoIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBXaGVuIGNhbGxpbmcgYnJvd3NlckZpbGVzLCBhdCBsZWFzdCAxIGZpbGUgaXMgcmVxdWlyZWQsIGAgK1xuICAgICAgICAgIGBidXQgcmVjZWl2ZWQgJHtmaWxlc31gKTtcbiAgICB9XG4gICAgdGhpcy5qc29uRmlsZSA9IGZpbGVzWzBdO1xuICAgIHRoaXMud2VpZ2h0c0ZpbGVzID0gZmlsZXMuc2xpY2UoMSk7XG4gIH1cblxuICBhc3luYyBsb2FkKCk6IFByb21pc2U8TW9kZWxBcnRpZmFjdHM+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QganNvblJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICBqc29uUmVhZGVyLm9ubG9hZCA9IChldmVudDogRXZlbnQpID0+IHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgICBjb25zdCBtb2RlbEpTT04gPSBKU09OLnBhcnNlKChldmVudC50YXJnZXQgYXMgYW55KS5yZXN1bHQpIGFzIE1vZGVsSlNPTjtcblxuICAgICAgICBjb25zdCBtb2RlbFRvcG9sb2d5ID0gbW9kZWxKU09OLm1vZGVsVG9wb2xvZ3k7XG4gICAgICAgIGlmIChtb2RlbFRvcG9sb2d5ID09IG51bGwpIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBtb2RlbFRvcG9sb2d5IGZpZWxkIGlzIG1pc3NpbmcgZnJvbSBmaWxlICR7XG4gICAgICAgICAgICAgIHRoaXMuanNvbkZpbGUubmFtZX1gKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgd2VpZ2h0c01hbmlmZXN0ID0gbW9kZWxKU09OLndlaWdodHNNYW5pZmVzdDtcbiAgICAgICAgaWYgKHdlaWdodHNNYW5pZmVzdCA9PSBudWxsKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgd2VpZ2h0TWFuaWZlc3QgZmllbGQgaXMgbWlzc2luZyBmcm9tIGZpbGUgJHtcbiAgICAgICAgICAgICAgdGhpcy5qc29uRmlsZS5uYW1lfWApKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy53ZWlnaHRzRmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmVzb2x2ZSh7bW9kZWxUb3BvbG9neX0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1vZGVsQXJ0aWZhY3RzUHJvbWlzZSA9IGdldE1vZGVsQXJ0aWZhY3RzRm9ySlNPTihcbiAgICAgICAgICAgIG1vZGVsSlNPTiwgKHdlaWdodHNNYW5pZmVzdCkgPT4gdGhpcy5sb2FkV2VpZ2h0cyh3ZWlnaHRzTWFuaWZlc3QpKTtcbiAgICAgICAgcmVzb2x2ZShtb2RlbEFydGlmYWN0c1Byb21pc2UpO1xuICAgICAgfTtcblxuICAgICAganNvblJlYWRlci5vbmVycm9yID0gZXJyb3IgPT4gcmVqZWN0KFxuICAgICAgICAgIGBGYWlsZWQgdG8gcmVhZCBtb2RlbCB0b3BvbG9neSBhbmQgd2VpZ2h0cyBtYW5pZmVzdCBKU09OIGAgK1xuICAgICAgICAgIGBmcm9tIGZpbGUgJyR7dGhpcy5qc29uRmlsZS5uYW1lfScuIEJyb3dzZXJGaWxlcyBzdXBwb3J0cyBsb2FkaW5nIGAgK1xuICAgICAgICAgIGBLZXJhcy1zdHlsZSB0Zi5Nb2RlbCBhcnRpZmFjdHMgb25seS5gKTtcbiAgICAgIGpzb25SZWFkZXIucmVhZEFzVGV4dCh0aGlzLmpzb25GaWxlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgbG9hZFdlaWdodHMod2VpZ2h0c01hbmlmZXN0OiBXZWlnaHRzTWFuaWZlc3RDb25maWcpOiBQcm9taXNlPFtcbiAgICAvKiB3ZWlnaHRTcGVjcyAqLyBXZWlnaHRzTWFuaWZlc3RFbnRyeVtdLCBXZWlnaHREYXRhLFxuICBdPiB7XG4gICAgY29uc3Qgd2VpZ2h0U3BlY3M6IFdlaWdodHNNYW5pZmVzdEVudHJ5W10gPSBbXTtcbiAgICBjb25zdCBwYXRoczogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHdlaWdodHNNYW5pZmVzdCkge1xuICAgICAgd2VpZ2h0U3BlY3MucHVzaCguLi5lbnRyeS53ZWlnaHRzKTtcbiAgICAgIHBhdGhzLnB1c2goLi4uZW50cnkucGF0aHMpO1xuICAgIH1cblxuICAgIGNvbnN0IHBhdGhUb0ZpbGU6IHtbcGF0aDogc3RyaW5nXTogRmlsZX0gPVxuICAgICAgICB0aGlzLmNoZWNrTWFuaWZlc3RBbmRXZWlnaHRGaWxlcyh3ZWlnaHRzTWFuaWZlc3QpO1xuXG4gICAgY29uc3QgcHJvbWlzZXM6IEFycmF5PFByb21pc2U8QXJyYXlCdWZmZXI+PiA9XG4gICAgICAgIHBhdGhzLm1hcChwYXRoID0+IHRoaXMubG9hZFdlaWdodHNGaWxlKHBhdGgsIHBhdGhUb0ZpbGVbcGF0aF0pKTtcblxuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihcbiAgICAgICAgYnVmZmVycyA9PiBbd2VpZ2h0U3BlY3MsIGJ1ZmZlcnNdKTtcbiAgfVxuXG4gIHByaXZhdGUgbG9hZFdlaWdodHNGaWxlKHBhdGg6IHN0cmluZywgZmlsZTogRmlsZSk6IFByb21pc2U8QXJyYXlCdWZmZXI+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3Qgd2VpZ2h0RmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICB3ZWlnaHRGaWxlUmVhZGVyLm9ubG9hZCA9IChldmVudDogRXZlbnQpID0+IHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgICBjb25zdCB3ZWlnaHREYXRhID0gKGV2ZW50LnRhcmdldCBhcyBhbnkpLnJlc3VsdCBhcyBBcnJheUJ1ZmZlcjtcbiAgICAgICAgcmVzb2x2ZSh3ZWlnaHREYXRhKTtcbiAgICAgIH07XG4gICAgICB3ZWlnaHRGaWxlUmVhZGVyLm9uZXJyb3IgPSBlcnJvciA9PlxuICAgICAgICAgIHJlamVjdChgRmFpbGVkIHRvIHdlaWdodHMgZGF0YSBmcm9tIGZpbGUgb2YgcGF0aCAnJHtwYXRofScuYCk7XG4gICAgICB3ZWlnaHRGaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGZpbGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHRoZSBjb21wYXRpYmlsaXR5IGJldHdlZW4gd2VpZ2h0cyBtYW5pZmVzdCBhbmQgd2VpZ2h0IGZpbGVzLlxuICAgKi9cbiAgcHJpdmF0ZSBjaGVja01hbmlmZXN0QW5kV2VpZ2h0RmlsZXMobWFuaWZlc3Q6IFdlaWdodHNNYW5pZmVzdENvbmZpZyk6XG4gICAgICB7W3BhdGg6IHN0cmluZ106IEZpbGV9IHtcbiAgICBjb25zdCBiYXNlbmFtZXM6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgZmlsZU5hbWVzID0gdGhpcy53ZWlnaHRzRmlsZXMubWFwKGZpbGUgPT4gYmFzZW5hbWUoZmlsZS5uYW1lKSk7XG4gICAgY29uc3QgcGF0aFRvRmlsZToge1twYXRoOiBzdHJpbmddOiBGaWxlfSA9IHt9O1xuICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgbWFuaWZlc3QpIHtcbiAgICAgIGdyb3VwLnBhdGhzLmZvckVhY2gocGF0aCA9PiB7XG4gICAgICAgIGNvbnN0IHBhdGhCYXNlbmFtZSA9IGJhc2VuYW1lKHBhdGgpO1xuICAgICAgICBpZiAoYmFzZW5hbWVzLmluZGV4T2YocGF0aEJhc2VuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBEdXBsaWNhdGUgZmlsZSBiYXNlbmFtZSBmb3VuZCBpbiB3ZWlnaHRzIG1hbmlmZXN0OiBgICtcbiAgICAgICAgICAgICAgYCcke3BhdGhCYXNlbmFtZX0nYCk7XG4gICAgICAgIH1cbiAgICAgICAgYmFzZW5hbWVzLnB1c2gocGF0aEJhc2VuYW1lKTtcbiAgICAgICAgaWYgKGZpbGVOYW1lcy5pbmRleE9mKHBhdGhCYXNlbmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgV2VpZ2h0IGZpbGUgd2l0aCBiYXNlbmFtZSAnJHtwYXRoQmFzZW5hbWV9JyBpcyBub3QgcHJvdmlkZWQuYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aFRvRmlsZVtwYXRoXSA9IHRoaXMud2VpZ2h0c0ZpbGVzW2ZpbGVOYW1lcy5pbmRleE9mKHBhdGhCYXNlbmFtZSldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYmFzZW5hbWVzLmxlbmd0aCAhPT0gdGhpcy53ZWlnaHRzRmlsZXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYE1pc21hdGNoIGluIHRoZSBudW1iZXIgb2YgZmlsZXMgaW4gd2VpZ2h0cyBtYW5pZmVzdCBgICtcbiAgICAgICAgICBgKCR7YmFzZW5hbWVzLmxlbmd0aH0pIGFuZCB0aGUgbnVtYmVyIG9mIHdlaWdodCBmaWxlcyBwcm92aWRlZCBgICtcbiAgICAgICAgICBgKCR7dGhpcy53ZWlnaHRzRmlsZXMubGVuZ3RofSkuYCk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoVG9GaWxlO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBicm93c2VyRG93bmxvYWRzUm91dGVyOiBJT1JvdXRlciA9ICh1cmw6IHN0cmluZ3xzdHJpbmdbXSkgPT4ge1xuICBpZiAoIWVudigpLmdldEJvb2woJ0lTX0JST1dTRVInKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh1cmwpICYmIHVybC5zdGFydHNXaXRoKEJyb3dzZXJEb3dubG9hZHMuVVJMX1NDSEVNRSkpIHtcbiAgICAgIHJldHVybiBicm93c2VyRG93bmxvYWRzKHVybC5zbGljZShCcm93c2VyRG93bmxvYWRzLlVSTF9TQ0hFTUUubGVuZ3RoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxufTtcbklPUm91dGVyUmVnaXN0cnkucmVnaXN0ZXJTYXZlUm91dGVyKGJyb3dzZXJEb3dubG9hZHNSb3V0ZXIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gSU9IYW5kbGVyIHRoYXQgdHJpZ2dlcnMgZmlsZSBkb3dubG9hZHMgZnJvbSB0aGUgYnJvd3Nlci5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgYElPSGFuZGxlcmAgaW5zdGFuY2UgY2FuIGJlIHVzZWQgYXMgbW9kZWwgZXhwb3J0aW5nIG1ldGhvZHMgc3VjaFxuICogYXMgYHRmLk1vZGVsLnNhdmVgIGFuZCBzdXBwb3J0cyBvbmx5IHNhdmluZy5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgbW9kZWwgPSB0Zi5zZXF1ZW50aWFsKCk7XG4gKiBtb2RlbC5hZGQodGYubGF5ZXJzLmRlbnNlKFxuICogICAgIHt1bml0czogMSwgaW5wdXRTaGFwZTogWzEwXSwgYWN0aXZhdGlvbjogJ3NpZ21vaWQnfSkpO1xuICogY29uc3Qgc2F2ZVJlc3VsdCA9IGF3YWl0IG1vZGVsLnNhdmUoJ2Rvd25sb2FkczovL215bW9kZWwnKTtcbiAqIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGRvd25sb2FkaW5nIG9mIHR3byBmaWxlczpcbiAqIC8vICAgJ215bW9kZWwuanNvbicgYW5kICdteW1vZGVsLndlaWdodHMuYmluJy5cbiAqIGNvbnNvbGUubG9nKHNhdmVSZXN1bHQpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGZpbGVOYW1lUHJlZml4IFByZWZpeCBuYW1lIG9mIHRoZSBmaWxlcyB0byBiZSBkb3dubG9hZGVkLiBGb3IgdXNlIHdpdGhcbiAqICAgYHRmLk1vZGVsYCwgYGZpbGVOYW1lUHJlZml4YCBzaG91bGQgZm9sbG93IGVpdGhlciBvZiB0aGUgZm9sbG93aW5nIHR3b1xuICogICBmb3JtYXRzOlxuICogICAxLiBgbnVsbGAgb3IgYHVuZGVmaW5lZGAsIGluIHdoaWNoIGNhc2UgdGhlIGRlZmF1bHQgZmlsZVxuICogICAgICBuYW1lcyB3aWxsIGJlIHVzZWQ6XG4gKiAgICAgIC0gJ21vZGVsLmpzb24nIGZvciB0aGUgSlNPTiBmaWxlIGNvbnRhaW5pbmcgdGhlIG1vZGVsIHRvcG9sb2d5IGFuZFxuICogICAgICAgIHdlaWdodHMgbWFuaWZlc3QuXG4gKiAgICAgIC0gJ21vZGVsLndlaWdodHMuYmluJyBmb3IgdGhlIGJpbmFyeSBmaWxlIGNvbnRhaW5pbmcgdGhlIGJpbmFyeSB3ZWlnaHRcbiAqICAgICAgICB2YWx1ZXMuXG4gKiAgIDIuIEEgc2luZ2xlIHN0cmluZyBvciBhbiBBcnJheSBvZiBhIHNpbmdsZSBzdHJpbmcsIGFzIHRoZSBmaWxlIG5hbWUgcHJlZml4LlxuICogICAgICBGb3IgZXhhbXBsZSwgaWYgYCdmb28nYCBpcyBwcm92aWRlZCwgdGhlIGRvd25sb2FkZWQgSlNPTlxuICogICAgICBmaWxlIGFuZCBiaW5hcnkgd2VpZ2h0cyBmaWxlIHdpbGwgYmUgbmFtZWQgJ2Zvby5qc29uJyBhbmRcbiAqICAgICAgJ2Zvby53ZWlnaHRzLmJpbicsIHJlc3BlY3RpdmVseS5cbiAqIEBwYXJhbSBjb25maWcgQWRkaXRpb25hbCBjb25maWd1cmF0aW9uIGZvciB0cmlnZ2VyaW5nIGRvd25sb2Fkcy5cbiAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIGBCcm93c2VyRG93bmxvYWRzYCBgSU9IYW5kbGVyYC5cbiAqXG4gKiBAZG9jIHtcbiAqICAgaGVhZGluZzogJ01vZGVscycsXG4gKiAgIHN1YmhlYWRpbmc6ICdMb2FkaW5nJyxcbiAqICAgbmFtZXNwYWNlOiAnaW8nLFxuICogICBpZ25vcmVDSTogdHJ1ZVxuICogfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnJvd3NlckRvd25sb2FkcyhmaWxlTmFtZVByZWZpeCA9ICdtb2RlbCcpOiBJT0hhbmRsZXIge1xuICByZXR1cm4gbmV3IEJyb3dzZXJEb3dubG9hZHMoZmlsZU5hbWVQcmVmaXgpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gSU9IYW5kbGVyIHRoYXQgbG9hZHMgbW9kZWwgYXJ0aWZhY3RzIGZyb20gdXNlci1zZWxlY3RlZCBmaWxlcy5cbiAqXG4gKiBUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCBmb3IgbG9hZGluZyBmcm9tIGZpbGVzIHN1Y2ggYXMgdXNlci1zZWxlY3RlZCBmaWxlc1xuICogaW4gdGhlIGJyb3dzZXIuXG4gKiBXaGVuIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgdGYubG9hZExheWVyc01vZGVsYCwgYW4gaW5zdGFuY2Ugb2ZcbiAqIGB0Zi5MYXllcnNNb2RlbGAgKEtlcmFzLXN0eWxlKSBjYW4gYmUgY29uc3RydWN0ZWQgZnJvbSB0aGUgbG9hZGVkIGFydGlmYWN0cy5cbiAqXG4gKiBgYGBqc1xuICogLy8gTm90ZTogVGhpcyBjb2RlIHNuaXBwZXQgd29uJ3QgcnVuIHByb3Blcmx5IHdpdGhvdXQgdGhlIGFjdHVhbCBmaWxlIGlucHV0XG4gKiAvLyAgIGVsZW1lbnRzIGluIHRoZSBIVE1MIERPTS5cbiAqXG4gKiAvLyBTdXBwb3NlIHRoZXJlIGFyZSB0d28gSFRNTCBmaWxlIGlucHV0IChgPGlucHV0IHR5cGU9XCJmaWxlXCIgLi4uPmApXG4gKiAvLyBlbGVtZW50cy5cbiAqIGNvbnN0IHVwbG9hZEpTT05JbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd1cGxvYWQtanNvbicpO1xuICogY29uc3QgdXBsb2FkV2VpZ2h0c0lucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3VwbG9hZC13ZWlnaHRzJyk7XG4gKiBjb25zdCBtb2RlbCA9IGF3YWl0IHRmLmxvYWRMYXllcnNNb2RlbCh0Zi5pby5icm93c2VyRmlsZXMoXG4gKiAgICAgW3VwbG9hZEpTT05JbnB1dC5maWxlc1swXSwgdXBsb2FkV2VpZ2h0c0lucHV0LmZpbGVzWzBdXSkpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGZpbGVzIGBGaWxlYHMgdG8gbG9hZCBmcm9tLiBDdXJyZW50bHksIHRoaXMgZnVuY3Rpb24gc3VwcG9ydHMgb25seVxuICogICBsb2FkaW5nIGZyb20gZmlsZXMgdGhhdCBjb250YWluIEtlcmFzLXN0eWxlIG1vZGVscyAoaS5lLiwgYHRmLk1vZGVsYHMpLCBmb3JcbiAqICAgd2hpY2ggYW4gYEFycmF5YCBvZiBgRmlsZWBzIGlzIGV4cGVjdGVkIChpbiB0aGF0IG9yZGVyKTpcbiAqICAgLSBBIEpTT04gZmlsZSBjb250YWluaW5nIHRoZSBtb2RlbCB0b3BvbG9neSBhbmQgd2VpZ2h0IG1hbmlmZXN0LlxuICogICAtIE9wdGlvbmFsbHksIG9uZSBvciBtb3JlIGJpbmFyeSBmaWxlcyBjb250YWluaW5nIHRoZSBiaW5hcnkgd2VpZ2h0cy5cbiAqICAgICBUaGVzZSBmaWxlcyBtdXN0IGhhdmUgbmFtZXMgdGhhdCBtYXRjaCB0aGUgcGF0aHMgaW4gdGhlIGB3ZWlnaHRzTWFuaWZlc3RgXG4gKiAgICAgY29udGFpbmVkIGJ5IHRoZSBhZm9yZW1lbnRpb25lZCBKU09OIGZpbGUsIG9yIGVycm9ycyB3aWxsIGJlIHRocm93blxuICogICAgIGR1cmluZyBsb2FkaW5nLiBUaGVzZSB3ZWlnaHRzIGZpbGVzIGhhdmUgdGhlIHNhbWUgZm9ybWF0IGFzIHRoZSBvbmVzXG4gKiAgICAgZ2VuZXJhdGVkIGJ5IGB0ZW5zb3JmbG93anNfY29udmVydGVyYCB0aGF0IGNvbWVzIHdpdGggdGhlIGB0ZW5zb3JmbG93anNgXG4gKiAgICAgUHl0aG9uIFBJUCBwYWNrYWdlLiBJZiBubyB3ZWlnaHRzIGZpbGVzIGFyZSBwcm92aWRlZCwgb25seSB0aGUgbW9kZWxcbiAqICAgICB0b3BvbG9neSB3aWxsIGJlIGxvYWRlZCBmcm9tIHRoZSBKU09OIGZpbGUgYWJvdmUuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBgRmlsZXNgIGBJT0hhbmRsZXJgLlxuICpcbiAqIEBkb2Mge1xuICogICBoZWFkaW5nOiAnTW9kZWxzJyxcbiAqICAgc3ViaGVhZGluZzogJ0xvYWRpbmcnLFxuICogICBuYW1lc3BhY2U6ICdpbycsXG4gKiAgIGlnbm9yZUNJOiB0cnVlXG4gKiB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBicm93c2VyRmlsZXMoZmlsZXM6IEZpbGVbXSk6IElPSGFuZGxlciB7XG4gIHJldHVybiBuZXcgQnJvd3NlckZpbGVzKGZpbGVzKTtcbn1cbiJdfQ==","import * as util from '../util';\n/**\n * Wraps a list of ArrayBuffers into a `slice()`-able object without allocating\n * a large ArrayBuffer.\n *\n * Allocating large ArrayBuffers (~2GB) can be unstable on Chrome. TFJS loads\n * its weights as a list of (usually) 4MB ArrayBuffers and then slices the\n * weight tensors out of them. For small models, it's safe to concatenate all\n * the weight buffers into a single ArrayBuffer and then slice the weight\n * tensors out of it, but for large models, a different approach is needed.\n */\nexport class CompositeArrayBuffer {\n    /**\n     * Concatenate a number of ArrayBuffers into one.\n     *\n     * @param buffers An array of ArrayBuffers to concatenate, or a single\n     *     ArrayBuffer.\n     * @returns Result of concatenating `buffers` in order.\n     */\n    static join(buffers) {\n        return new CompositeArrayBuffer(buffers).slice();\n    }\n    constructor(buffers) {\n        this.shards = [];\n        this.previousShardIndex = 0;\n        if (buffers == null) {\n            return;\n        }\n        // Normalize the `buffers` input to be `ArrayBuffer[]`.\n        if (!(buffers instanceof Array)) {\n            buffers = [buffers];\n        }\n        buffers = buffers.map((bufferOrTypedArray) => {\n            if (util.isTypedArray(bufferOrTypedArray)) {\n                return bufferOrTypedArray.buffer;\n            }\n            return bufferOrTypedArray;\n        });\n        // Skip setting up shards if there are no buffers.\n        if (buffers.length === 0) {\n            return;\n        }\n        this.bufferUniformSize = buffers[0].byteLength;\n        let start = 0;\n        for (let i = 0; i < buffers.length; i++) {\n            const buffer = buffers[i];\n            // Check that all buffers except the last one have the same length.\n            if (i !== buffers.length - 1 &&\n                buffer.byteLength !== this.bufferUniformSize) {\n                // Unset the buffer uniform size, since the buffer sizes are not\n                // uniform.\n                this.bufferUniformSize = undefined;\n            }\n            // Create the shards, including their start and end points.\n            const end = start + buffer.byteLength;\n            this.shards.push({ buffer, start, end });\n            start = end;\n        }\n        // Set the byteLenghth\n        if (this.shards.length === 0) {\n            this.byteLength = 0;\n        }\n        this.byteLength = this.shards[this.shards.length - 1].end;\n    }\n    slice(start = 0, end = this.byteLength) {\n        // If there are no shards, then the CompositeArrayBuffer was initialized\n        // with no data.\n        if (this.shards.length === 0) {\n            return new ArrayBuffer(0);\n        }\n        // NaN is treated as zero for slicing. This matches ArrayBuffer's behavior.\n        start = isNaN(Number(start)) ? 0 : start;\n        end = isNaN(Number(end)) ? 0 : end;\n        // Fix the bounds to within the array.\n        start = Math.max(0, start);\n        end = Math.min(this.byteLength, end);\n        if (end <= start) {\n            return new ArrayBuffer(0);\n        }\n        const startShardIndex = this.findShardForByte(start);\n        if (startShardIndex === -1) {\n            // This should not happen since the start and end indices are always\n            // within 0 and the composite array's length.\n            throw new Error(`Could not find start shard for byte ${start}`);\n        }\n        const size = end - start;\n        const outputBuffer = new ArrayBuffer(size);\n        const outputArray = new Uint8Array(outputBuffer);\n        let sliced = 0;\n        for (let i = startShardIndex; i < this.shards.length; i++) {\n            const shard = this.shards[i];\n            const globalStart = start + sliced;\n            const localStart = globalStart - shard.start;\n            const outputStart = sliced;\n            const globalEnd = Math.min(end, shard.end);\n            const localEnd = globalEnd - shard.start;\n            const outputSlice = new Uint8Array(shard.buffer, localStart, localEnd - localStart);\n            outputArray.set(outputSlice, outputStart);\n            sliced += outputSlice.length;\n            if (end < shard.end) {\n                break;\n            }\n        }\n        return outputBuffer;\n    }\n    /**\n     * Get the index of the shard that contains the byte at `byteIndex`.\n     */\n    findShardForByte(byteIndex) {\n        if (this.shards.length === 0 || byteIndex < 0 ||\n            byteIndex >= this.byteLength) {\n            return -1;\n        }\n        // If the buffers have a uniform size, compute the shard directly.\n        if (this.bufferUniformSize != null) {\n            this.previousShardIndex = Math.floor(byteIndex / this.bufferUniformSize);\n            return this.previousShardIndex;\n        }\n        // If the buffers don't have a uniform size, we need to search for the\n        // shard. That means we need a function to check where the byteIndex lies\n        // relative to a given shard.\n        function check(shard) {\n            if (byteIndex < shard.start) {\n                return -1;\n            }\n            if (byteIndex >= shard.end) {\n                return 1;\n            }\n            return 0;\n        }\n        // For efficiency, try the previous shard first.\n        if (check(this.shards[this.previousShardIndex]) === 0) {\n            return this.previousShardIndex;\n        }\n        // Otherwise, use a generic search function.\n        // This should almost never end up being used in practice since the weight\n        // entries should always be in order.\n        const index = search(this.shards, check);\n        if (index === -1) {\n            return -1;\n        }\n        this.previousShardIndex = index;\n        return this.previousShardIndex;\n    }\n}\n/**\n * Search for an element of a sorted array.\n *\n * @param sortedArray The sorted array to search\n * @param compare A function to compare the current value against the searched\n *     value. Return 0 on a match, negative if the searched value is less than\n *     the value passed to the function, and positive if the searched value is\n *     greater than the value passed to the function.\n * @returns The index of the element, or -1 if it's not in the array.\n */\nexport function search(sortedArray, compare) {\n    // Binary search\n    let min = 0;\n    let max = sortedArray.length;\n    while (min <= max) {\n        const middle = Math.floor((max - min) / 2) + min;\n        const side = compare(sortedArray[middle]);\n        if (side === 0) {\n            return middle;\n        }\n        else if (side < 0) {\n            max = middle;\n        }\n        else {\n            min = middle + 1;\n        }\n    }\n    return -1;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcG9zaXRlX2FycmF5X2J1ZmZlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtY29yZS9zcmMvaW8vY29tcG9zaXRlX2FycmF5X2J1ZmZlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFpQkEsT0FBTyxLQUFLLElBQUksTUFBTSxTQUFTLENBQUM7QUFRaEM7Ozs7Ozs7OztHQVNHO0FBRUgsTUFBTSxPQUFPLG9CQUFvQjtJQU0vQjs7Ozs7O09BTUc7SUFDSCxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQXFDO1FBQy9DLE9BQU8sSUFBSSxvQkFBb0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUNuRCxDQUFDO0lBRUQsWUFBWSxPQUNFO1FBakJOLFdBQU0sR0FBa0IsRUFBRSxDQUFDO1FBQzNCLHVCQUFrQixHQUFHLENBQUMsQ0FBQztRQWlCN0IsSUFBSSxPQUFPLElBQUksSUFBSSxFQUFFO1lBQ25CLE9BQU87U0FDUjtRQUNELHVEQUF1RDtRQUN2RCxJQUFJLENBQUMsQ0FBQyxPQUFPLFlBQVksS0FBSyxDQUFDLEVBQUU7WUFDL0IsT0FBTyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDckI7UUFDRCxPQUFPLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLGtCQUFrQixFQUFFLEVBQUU7WUFDM0MsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLGtCQUFrQixDQUFDLEVBQUU7Z0JBQ3pDLE9BQU8sa0JBQWtCLENBQUMsTUFBTSxDQUFDO2FBQ2xDO1lBQ0QsT0FBTyxrQkFBa0IsQ0FBQztRQUM1QixDQUFDLENBQUMsQ0FBQztRQUVILGtEQUFrRDtRQUNsRCxJQUFJLE9BQU8sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ3hCLE9BQU87U0FDUjtRQUVELElBQUksQ0FBQyxpQkFBaUIsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDO1FBQy9DLElB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QU0sSUFBSSxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUUxQyxJQUFJLElBQUksS0FBSyxDQUFDLEVBQUU7WUFDZCxPQUFPLE1BQU0sQ0FBQztTQUNmO2FBQU0sSUFBSSxJQUFJLEdBQUcsQ0FBQyxFQUFFO1lBQ25CLEdBQUcsR0FBRyxNQUFNLENBQUM7U0FDZDthQUFNO1lBQ0wsR0FBRyxHQUFHLE1BQU0sR0FBRyxDQUFDLENBQUM7U0FDbEI7S0FDRjtJQUNELE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFDWixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuaW1wb3J0IHtUeXBlZEFycmF5fSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwnO1xuXG50eXBlIEJ1ZmZlclNoYXJkID0ge1xuICBzdGFydDogbnVtYmVyLFxuICBlbmQ6IG51bWJlcixcbiAgYnVmZmVyOiBBcnJheUJ1ZmZlcixcbn07XG5cbi8qKlxuICogV3JhcHMgYSBsaXN0IG9mIEFycmF5QnVmZmVycyBpbnRvIGEgYHNsaWNlKClgLWFibGUgb2JqZWN0IHdpdGhvdXQgYWxsb2NhdGluZ1xuICogYSBsYXJnZSBBcnJheUJ1ZmZlci5cbiAqXG4gKiBBbGxvY2F0aW5nIGxhcmdlIEFycmF5QnVmZmVycyAofjJHQikgY2FuIGJlIHVuc3RhYmxlIG9uIENocm9tZS4gVEZKUyBsb2Fkc1xuICogaXRzIHdlaWdodHMgYXMgYSBsaXN0IG9mICh1c3VhbGx5KSA0TUIgQXJyYXlCdWZmZXJzIGFuZCB0aGVuIHNsaWNlcyB0aGVcbiAqIHdlaWdodCB0ZW5zb3JzIG91dCBvZiB0aGVtLiBGb3Igc21hbGwgbW9kZWxzLCBpdCdzIHNhZmUgdG8gY29uY2F0ZW5hdGUgYWxsXG4gKiB0aGUgd2VpZ2h0IGJ1ZmZlcnMgaW50byBhIHNpbmdsZSBBcnJheUJ1ZmZlciBhbmQgdGhlbiBzbGljZSB0aGUgd2VpZ2h0XG4gKiB0ZW5zb3JzIG91dCBvZiBpdCwgYnV0IGZvciBsYXJnZSBtb2RlbHMsIGEgZGlmZmVyZW50IGFwcHJvYWNoIGlzIG5lZWRlZC5cbiAqL1xuXG5leHBvcnQgY2xhc3MgQ29tcG9zaXRlQXJyYXlCdWZmZXIge1xuICBwcml2YXRlIHNoYXJkczogQnVmZmVyU2hhcmRbXSA9IFtdO1xuICBwcml2YXRlIHByZXZpb3VzU2hhcmRJbmRleCA9IDA7XG4gIHByaXZhdGUgYnVmZmVyVW5pZm9ybVNpemU/OiBudW1iZXI7XG4gIHB1YmxpYyByZWFkb25seSBieXRlTGVuZ3RoOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIENvbmNhdGVuYXRlIGEgbnVtYmVyIG9mIEFycmF5QnVmZmVycyBpbnRvIG9uZS5cbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlcnMgQW4gYXJyYXkgb2YgQXJyYXlCdWZmZXJzIHRvIGNvbmNhdGVuYXRlLCBvciBhIHNpbmdsZVxuICAgKiAgICAgQXJyYXlCdWZmZXIuXG4gICAqIEByZXR1cm5zIFJlc3VsdCBvZiBjb25jYXRlbmF0aW5nIGBidWZmZXJzYCBpbiBvcmRlci5cbiAgICovXG4gIHN0YXRpYyBqb2luKGJ1ZmZlcnM/OiBBcnJheUJ1ZmZlcltdIHwgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gbmV3IENvbXBvc2l0ZUFycmF5QnVmZmVyKGJ1ZmZlcnMpLnNsaWNlKCk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihidWZmZXJzPzogQXJyYXlCdWZmZXIgfCBBcnJheUJ1ZmZlcltdIHwgVHlwZWRBcnJheSB8XG4gICAgVHlwZWRBcnJheVtdKSB7XG4gICAgaWYgKGJ1ZmZlcnMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgdGhlIGBidWZmZXJzYCBpbnB1dCB0byBiZSBgQXJyYXlCdWZmZXJbXWAuXG4gICAgaWYgKCEoYnVmZmVycyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgYnVmZmVycyA9IFtidWZmZXJzXTtcbiAgICB9XG4gICAgYnVmZmVycyA9IGJ1ZmZlcnMubWFwKChidWZmZXJPclR5cGVkQXJyYXkpID0+IHtcbiAgICAgIGlmICh1dGlsLmlzVHlwZWRBcnJheShidWZmZXJPclR5cGVkQXJyYXkpKSB7XG4gICAgICAgIHJldHVybiBidWZmZXJPclR5cGVkQXJyYXkuYnVmZmVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1ZmZlck9yVHlwZWRBcnJheTtcbiAgICB9KTtcblxuICAgIC8vIFNraXAgc2V0dGluZyB1cCBzaGFyZHMgaWYgdGhlcmUgYXJlIG5vIGJ1ZmZlcnMuXG4gICAgaWYgKGJ1ZmZlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5idWZmZXJVbmlmb3JtU2l6ZSA9IGJ1ZmZlcnNbMF0uYnl0ZUxlbmd0aDtcbiAgICBsZXQgc3RhcnQgPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBidWZmZXIgPSBidWZmZXJzW2ldO1xuICAgICAgLy8gQ2hlY2sgdGhhdCBhbGwgYnVmZmVycyBleGNlcHQgdGhlIGxhc3Qgb25lIGhhdmUgdGhlIHNhbWUgbGVuZ3RoLlxuICAgICAgaWYgKGkgIT09IGJ1ZmZlcnMubGVuZ3RoIC0gMSAmJlxuICAgICAgICBidWZmZXIuYnl0ZUxlbmd0aCAhPT0gdGhpcy5idWZmZXJVbmlmb3JtU2l6ZSkge1xuICAgICAgICAvLyBVbnNldCB0aGUgYnVmZmVyIHVuaWZvcm0gc2l6ZSwgc2luY2UgdGhlIGJ1ZmZlciBzaXplcyBhcmUgbm90XG4gICAgICAgIC8vIHVuaWZvcm0uXG4gICAgICAgIHRoaXMuYnVmZmVyVW5pZm9ybVNpemUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSB0aGUgc2hhcmRzLCBpbmNsdWRpbmcgdGhlaXIgc3RhcnQgYW5kIGVuZCBwb2ludHMuXG4gICAgICBjb25zdCBlbmQgPSBzdGFydCArIGJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgdGhpcy5zaGFyZHMucHVzaCh7IGJ1ZmZlciwgc3RhcnQsIGVuZCB9KTtcbiAgICAgIHN0YXJ0ID0gZW5kO1xuICAgIH1cblxuICAgIC8vIFNldCB0aGUgYnl0ZUxlbmdodGhcbiAgICBpZiAodGhpcy5zaGFyZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmJ5dGVMZW5ndGggPSAwO1xuICAgIH1cbiAgICB0aGlzLmJ5dGVMZW5ndGggPSB0aGlzLnNoYXJkc1t0aGlzLnNoYXJkcy5sZW5ndGggLSAxXS5lbmQ7XG4gIH1cblxuICBzbGljZShzdGFydCA9IDAsIGVuZCA9IHRoaXMuYnl0ZUxlbmd0aCk6IEFycmF5QnVmZmVyIHtcbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gc2hhcmRzLCB0aGVuIHRoZSBDb21wb3NpdGVBcnJheUJ1ZmZlciB3YXMgaW5pdGlhbGl6ZWRcbiAgICAvLyB3aXRoIG5vIGRhdGEuXG4gICAgaWYgKHRoaXMuc2hhcmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICB9XG5cbiAgICAvLyBOYU4gaXMgdHJlYXRlZCBhcyB6ZXJvIGZvciBzbGljaW5nLiBUaGlzIG1hdGNoZXMgQXJyYXlCdWZmZXIncyBiZWhhdmlvci5cbiAgICBzdGFydCA9IGlzTmFOKE51bWJlcihzdGFydCkpID8gMCA6IHN0YXJ0O1xuICAgIGVuZCA9IGlzTmFOKE51bWJlcihlbmQpKSA/IDAgOiBlbmQ7XG5cbiAgICAvLyBGaXggdGhlIGJvdW5kcyB0byB3aXRoaW4gdGhlIGFycmF5LlxuICAgIHN0YXJ0ID0gTWF0aC5tYXgoMCwgc3RhcnQpO1xuICAgIGVuZCA9IE1hdGgubWluKHRoaXMuYnl0ZUxlbmd0aCwgZW5kKTtcbiAgICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0U2hhcmRJbmRleCA9IHRoaXMuZmluZFNoYXJkRm9yQnl0ZShzdGFydCk7XG4gICAgaWYgKHN0YXJ0U2hhcmRJbmRleCA9PT0gLTEpIHtcbiAgICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW4gc2luY2UgdGhlIHN0YXJ0IGFuZCBlbmQgaW5kaWNlcyBhcmUgYWx3YXlzXG4gICAgICAvLyB3aXRoaW4gMCBhbmQgdGhlIGNvbXBvc2l0ZSBhcnJheSdzIGxlbmd0aC5cbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgc3RhcnQgc2hhcmQgZm9yIGJ5dGUgJHtzdGFydH1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBzaXplID0gZW5kIC0gc3RhcnQ7XG4gICAgY29uc3Qgb3V0cHV0QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHNpemUpO1xuICAgIGNvbnN0IG91dHB1dEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkob3V0cHV0QnVmZmVyKTtcbiAgICBsZXQgc2xpY2VkID0gMDtcbiAgICBmb3IgKGxldCBpID0gc3RhcnRTaGFyZEluZGV4OyBpIDwgdGhpcy5zaGFyZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHNoYXJkID0gdGhpcy5zaGFyZHNbaV07XG5cbiAgICAgIGNvbnN0IGdsb2JhbFN0YXJ0ID0gc3RhcnQgKyBzbGljZWQ7XG4gICAgICBjb25zdCBsb2NhbFN0YXJ0ID0gZ2xvYmFsU3RhcnQgLSBzaGFyZC5zdGFydDtcbiAgICAgIGNvbnN0IG91dHB1dFN0YXJ0ID0gc2xpY2VkO1xuXG4gICAgICBjb25zdCBnbG9iYWxFbmQgPSBNYXRoLm1pbihlbmQsIHNoYXJkLmVuZCk7XG4gICAgICBjb25zdCBsb2NhbEVuZCA9IGdsb2JhbEVuZCAtIHNoYXJkLnN0YXJ0O1xuXG4gICAgICBjb25zdCBvdXRwdXRTbGljZSA9IG5ldyBVaW50OEFycmF5KHNoYXJkLmJ1ZmZlciwgbG9jYWxTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxFbmQgLSBsb2NhbFN0YXJ0KTtcbiAgICAgIG91dHB1dEFycmF5LnNldChvdXRwdXRTbGljZSwgb3V0cHV0U3RhcnQpO1xuICAgICAgc2xpY2VkICs9IG91dHB1dFNsaWNlLmxlbmd0aDtcblxuICAgICAgaWYgKGVuZCA8IHNoYXJkLmVuZCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dEJ1ZmZlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGluZGV4IG9mIHRoZSBzaGFyZCB0aGF0IGNvbnRhaW5zIHRoZSBieXRlIGF0IGBieXRlSW5kZXhgLlxuICAgKi9cbiAgcHJpdmF0ZSBmaW5kU2hhcmRGb3JCeXRlKGJ5dGVJbmRleDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5zaGFyZHMubGVuZ3RoID09PSAwIHx8IGJ5dGVJbmRleCA8IDAgfHxcbiAgICAgIGJ5dGVJbmRleCA+PSB0aGlzLmJ5dGVMZW5ndGgpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgYnVmZmVycyBoYXZlIGEgdW5pZm9ybSBzaXplLCBjb21wdXRlIHRoZSBzaGFyZCBkaXJlY3RseS5cbiAgICBpZiAodGhpcy5idWZmZXJVbmlmb3JtU2l6ZSAhPSBudWxsKSB7XG4gICAgICB0aGlzLnByZXZpb3VzU2hhcmRJbmRleCA9IE1hdGguZmxvb3IoYnl0ZUluZGV4IC8gdGhpcy5idWZmZXJVbmlmb3JtU2l6ZSk7XG4gICAgICByZXR1cm4gdGhpcy5wcmV2aW91c1NoYXJkSW5kZXg7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGJ1ZmZlcnMgZG9uJ3QgaGF2ZSBhIHVuaWZvcm0gc2l6ZSwgd2UgbmVlZCB0byBzZWFyY2ggZm9yIHRoZVxuICAgIC8vIHNoYXJkLiBUaGF0IG1lYW5zIHdlIG5lZWQgYSBmdW5jdGlvbiB0byBjaGVjayB3aGVyZSB0aGUgYnl0ZUluZGV4IGxpZXNcbiAgICAvLyByZWxhdGl2ZSB0byBhIGdpdmVuIHNoYXJkLlxuICAgIGZ1bmN0aW9uIGNoZWNrKHNoYXJkOiBCdWZmZXJTaGFyZCkge1xuICAgICAgaWYgKGJ5dGVJbmRleCA8IHNoYXJkLnN0YXJ0KSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChieXRlSW5kZXggPj0gc2hhcmQuZW5kKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gRm9yIGVmZmljaWVuY3ksIHRyeSB0aGUgcHJldmlvdXMgc2hhcmQgZmlyc3QuXG4gICAgaWYgKGNoZWNrKHRoaXMuc2hhcmRzW3RoaXMucHJldmlvdXNTaGFyZEluZGV4XSkgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzU2hhcmRJbmRleDtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIHVzZSBhIGdlbmVyaWMgc2VhcmNoIGZ1bmN0aW9uLlxuICAgIC8vIFRoaXMgc2hvdWxkIGFsbW9zdCBuZXZlciBlbmQgdXAgYmVpbmcgdXNlZCBpbiBwcmFjdGljZSBzaW5jZSB0aGUgd2VpZ2h0XG4gICAgLy8gZW50cmllcyBzaG91bGQgYWx3YXlzIGJlIGluIG9yZGVyLlxuICAgIGNvbnN0IGluZGV4ID0gc2VhcmNoKHRoaXMuc2hhcmRzLCBjaGVjayk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHRoaXMucHJldmlvdXNTaGFyZEluZGV4ID0gaW5kZXg7XG4gICAgcmV0dXJuIHRoaXMucHJldmlvdXNTaGFyZEluZGV4O1xuICB9XG59XG5cbi8qKlxuICogU2VhcmNoIGZvciBhbiBlbGVtZW50IG9mIGEgc29ydGVkIGFycmF5LlxuICpcbiAqIEBwYXJhbSBzb3J0ZWRBcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIHNlYXJjaFxuICogQHBhcmFtIGNvbXBhcmUgQSBmdW5jdGlvbiB0byBjb21wYXJlIHRoZSBjdXJyZW50IHZhbHVlIGFnYWluc3QgdGhlIHNlYXJjaGVkXG4gKiAgICAgdmFsdWUuIFJldHVybiAwIG9uIGEgbWF0Y2gsIG5lZ2F0aXZlIGlmIHRoZSBzZWFyY2hlZCB2YWx1ZSBpcyBsZXNzIHRoYW5cbiAqICAgICB0aGUgdmFsdWUgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbiwgYW5kIHBvc2l0aXZlIGlmIHRoZSBzZWFyY2hlZCB2YWx1ZSBpc1xuICogICAgIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCwgb3IgLTEgaWYgaXQncyBub3QgaW4gdGhlIGFycmF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VhcmNoPFQ+KHNvcnRlZEFycmF5OiBUW10sIGNvbXBhcmU6ICh0OiBUKSA9PiBudW1iZXIpOiBudW1iZXIge1xuICAvLyBCaW5hcnkgc2VhcmNoXG4gIGxldCBtaW4gPSAwO1xuICBsZXQgbWF4ID0gc29ydGVkQXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlIChtaW4gPD0gbWF4KSB7XG4gICAgY29uc3QgbWlkZGxlID0gTWF0aC5mbG9vcigobWF4IC0gbWluKSAvIDIpICsgbWluO1xuICAgIGNvbnN0IHNpZGUgPSBjb21wYXJlKHNvcnRlZEFycmF5W21pZGRsZV0pO1xuXG4gICAgaWYgKHNpZGUgPT09IDApIHtcbiAgICAgIHJldHVybiBtaWRkbGU7XG4gICAgfSBlbHNlIGlmIChzaWRlIDwgMCkge1xuICAgICAgbWF4ID0gbWlkZGxlO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaW4gPSBtaWRkbGUgKyAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG4iXX0="],"names":["DEFAULT_FILE_NAME_PREFIX","DEFAULT_JSON_EXTENSION_NAME","DEFAULT_WEIGHT_DATA_EXTENSION_NAME","defer","f","Promise","resolve","setTimeout","then","BrowserDownloads","constructor","fileNamePrefix","getBool","Error","startsWith","URL_SCHEME","slice","length","this","modelJsonFileName","weightDataFileName","save","modelArtifacts","weightBuffer","join","weightData","weightsURL","window","URL","createObjectURL","Blob","type","modelTopology","ArrayBuffer","weightsManifest","paths","weights","weightSpecs","modelJSON","modelJsonURL","JSON","stringify","jsonAnchor","modelJsonAnchor","document","createElement","download","href","dispatchEvent","MouseEvent","weightDataAnchor","modelArtifactsInfo","browserDownloadsRouter","url","Array","isArray","browserDownloads","registerSaveRouter","CompositeArrayBuffer","buffers","shards","previousShardIndex","map","bufferOrTypedArray","buffer","bufferUniformSize","byteLength","start","i","undefined","end","push","isNaN","Number","Math","max","min","startShardIndex","findShardForByte","size","outputBuffer","outputArray","Uint8Array","sliced","shard","globalStart","localStart","outputStart","globalEnd","localEnd","outputSlice","set","byteIndex","floor","check","index","search","sortedArray","compare","middle","side"],"sourceRoot":""}