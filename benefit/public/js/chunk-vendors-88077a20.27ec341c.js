"use strict";(self["webpackChunkbenefit"]=self["webpackChunkbenefit"]||[]).push([[3084],{28560:function(e,t,n){n.d(t,{BB:function(){return r},EX:function(){return a},EZ:function(){return h},GM:function(){return l},NO:function(){return c},PM:function(){return f},Qn:function(){return s},j:function(){return i},tT:function(){return o}});var r,o,i,u=n(9495);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s(e,t){return[t,e]}function a(e,t){return e*t}function l(e){const t=u.ZSL.sizeFromShape(e),n=Math.ceil(t/4);return u.ZSL.sizeToSquarishShape(n)}function c(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function f(e,t){const[n,r]=c(e,t);return n*r*4}function h(e,t){const n=e;let r,o,i,s,a,l,c,f,h,E;return 2===(0,u._K2)().getNumber("WEBGL_VERSION")?(r=n.R32F,o=n.R16F,i=n.RGBA16F,s=n.RGBA32F,a=n.RED,c=4,f=1,h=n.HALF_FLOAT,E=n.FLOAT,l=n.RGBA8):(r=e.RGBA,o=e.RGBA,i=e.RGBA,s=n.RGBA,a=e.RGBA,c=4,f=4,h=null!=t?t.HALF_FLOAT_OES:null,E=e.FLOAT,l=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:s,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:f,textureTypeHalfFloat:h,textureTypeFloat:E}}(function(e){e[e["DENSE"]=0]="DENSE",e[e["SHARED_BATCH"]=1]="SHARED_BATCH"})(r||(r={})),function(e){e[e["RENDER"]=0]="RENDER",e[e["UPLOAD"]=1]="UPLOAD",e[e["PIXELS"]=2]="PIXELS",e[e["DOWNLOAD"]=3]="DOWNLOAD"}(o||(o={})),function(e){e[e["UNPACKED_FLOAT16"]=0]="UNPACKED_FLOAT16",e[e["UNPACKED_FLOAT32"]=1]="UNPACKED_FLOAT32",e[e["PACKED_4X1_UNSIGNED_BYTE"]=2]="PACKED_4X1_UNSIGNED_BYTE",e[e["PACKED_2X2_FLOAT32"]=3]="PACKED_2X2_FLOAT32",e[e["PACKED_2X2_FLOAT16"]=4]="PACKED_2X2_FLOAT16"}(i||(i={}))},47403:function(e,t,n){n.d(t,{p:function(){return u}});var r=n(9495),o=n(47646),i=n(28560);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class u{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const r=f(t,n),o=h(e,r,n);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const u=a(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=u,this.log();const e=this.freeTextures[o].pop();return this.usedTextures[o].push(e),e}let s;return r===i.j.PACKED_2X2_FLOAT32?s=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===i.j.PACKED_2X2_FLOAT16?s=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===i.j.UNPACKED_FLOAT32?s=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===i.j.UNPACKED_FLOAT16?s=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===i.j.PACKED_4X1_UNSIGNED_BYTE&&(s=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[o].push(s),this.numUsedTextures++,this._numBytesAllocated+=u,this.log(),s}releaseTexture(e,t,n,o){if(null==this.freeTextures)return;const i=f(n,o),u=h(t,i,o);u in this.freeTextures||(this.freeTextures[u]=[]);const s=a(t,i,this.gpgpu.gl,this.gpgpu.textureConfig,o),l=(0,r._K2)().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==l&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=s):(this.freeTextures[u].push(e),this.numFreeTextures++,this._numBytesFree+=s),this.numUsedTextures--;const c=this.usedTextures[u],E=c&&c.indexOf(e);if(null==E||E<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[E]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function s(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function a(e,t,n,r,o){const u=l(t,r);let a;if(o){const[t,n]=(0,i.NO)(e[0],e[1]);a=t*n}else{const[t,n]=(0,i.Qn)(e[0],e[1]);a=t*n}const c=s(n,u);return a*c}function l(e,t){switch(e){case i.j.PACKED_2X2_FLOAT32:return(0,o.Ij)(t);case i.j.PACKED_2X2_FLOAT16:return(0,o.z8)(t);case i.j.UNPACKED_FLOAT32:return(0,o.fj)(t);case i.j.UNPACKED_FLOAT16:return(0,o.J$)(t);case i.j.PACKED_4X1_UNSIGNED_BYTE:return(0,o.wM)(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function c(e){return(0,r._K2)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?i.j.PACKED_2X2_FLOAT32:i.j.UNPACKED_FLOAT32:e?i.j.PACKED_2X2_FLOAT16:i.j.UNPACKED_FLOAT16}function f(e,t){if(e===i.tT.UPLOAD)return i.j.PACKED_2X2_FLOAT32;if(e===i.tT.RENDER||null==e)return c(t);if(e===i.tT.DOWNLOAD||e===i.tT.PIXELS)return i.j.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function h(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}},20771:function(e,t,n){n.d(t,{$:function(){return o}});var r=n(27575);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class o{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.rank=n.length;const o=(0,r.bf)(this.rank),u=i(e);this.userCode=`\n      void main() {\n        ${o} resRC = getOutputCoords();\n        setOutput(getA(${u}));\n      }\n    `}}function i(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let o=0;o<e.length;o++)r.push(`imod(${n[o]}, ${e[o]})`);return r.join()}},76540:function(e,t,n){n.d(t,{K:function(){return r},T:function(){return o}});class r{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class o{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}},23601:function(e,t,n){n.d(t,{R:function(){return r}});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class r{constructor(e,t,n,r,o,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const u="nearest"===n?1:2;let s;switch(r){case"constant":s=1;break;case"reflect":s=2;break;case"wrap":s=3;break;case"nearest":s=4;break;default:s=1;break}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${s} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${s} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${s} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${o});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${o});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${u} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}},81322:function(e,t,n){n.d(t,{u:function(){return o}});var r=n(27575);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class o{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.rank=n.length;const o=(0,r.bf)(this.rank),u=i(t);this.userCode=`\n    void main() {\n      ${o} resRC = getOutputCoords();\n      setOutput(getA(${u}));\n    }\n    `}}function i(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let o=0;o<e.length;o++)r[e[o]]=n[o];return r.join()}},55315:function(e,t,n){n.d(t,{Y:function(){return i}});var r=n(75694),o=n(27575);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class i{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const i=(0,o.bf)(this.rank),u=(0,r.Fd)("rc",this.rank),s=new Array(this.rank);for(let r=0;r<t.length;r++)s[t[r]]=u[r];const a=`vec2(${s.slice(-2).join()})`,l=`++${u[this.rank-1]} < ${n[this.rank-1]}`,c=`getChannel(getA(${s.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${i} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${c};\n      if(${l}) {\n        result[1] = ${c};\n      }\n      --${u[this.rank-1]};\n      if(++${u[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${c};\n        if(${l}) {\n          result[3] = ${c};\n        }\n      }\n      setOutput(result);\n    }\n    `}}},68173:function(e,t,n){n.d(t,{Hq:function(){return h},Nb:function(){return c},UC:function(){return f},X0:function(){return a},X8:function(){return l},_Q:function(){return u},dR:function(){return i},hE:function(){return o},pd:function(){return s}});var r=n(22792);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class o{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=(0,r.ik)(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const i="if (isnan(x)) return x;",u="return x;",s="return abs(x);";const a="return (x >= 0.0) ? x : (exp(x) - 1.0);",l=i+"\n  return (x < 0.0) ? 0.0 : x;\n",c=i+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",f="return x;",h="return 1.0 / (1.0 + exp(-1.0 * x));"},74890:function(e,t,n){n.d(t,{Hq:function(){return a},Nb:function(){return s},X0:function(){return i},X8:function(){return u},_Q:function(){return o},rf:function(){return l}});var r=n(22792);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o="return x;",i="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",u="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",s="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",a="return 1.0 / (1.0 + exp(-1.0 * x));";class l{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=(0,r.ik)(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}},46969:function(e,t,n){n.d(t,{z:function(){return u}});var r=n(22792),o=n(75694),i=n(27575);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class u{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=(0,r.ik)(this.outputShape.length);const t=e.length,n=(0,o.Jp)("rc",t),u=(0,i.bf)(t),s=(0,o.kp)(t,n),a=n.slice(-2),l=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`\n      void main() {\n        ${u} rc = getOutputCoords();\n        vec4 packedInput = getA(${s});\n\n        setOutput(getChannel(packedInput, ${l}));\n      }\n    `}}},80393:function(e,t,n){n.d(t,{bP:function(){return o}});var r=n(9495);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o(){(0,r._K2)().set("WEBGL_FORCE_F16_TEXTURES",!0)}},88380:function(e,t,n){n.d(t,{$e:function(){return F},CE:function(){return ee},FP:function(){return X},HM:function(){return h},HW:function(){return m},I2:function(){return H},N0:function(){return y},N6:function(){return Z},P0:function(){return $},Ph:function(){return w},Ql:function(){return z},R7:function(){return _},Rh:function(){return U},SO:function(){return S},Se:function(){return W},Ut:function(){return J},VJ:function(){return Y},Yn:function(){return O},Zj:function(){return V},bz:function(){return x},cr:function(){return p},dm:function(){return c},fA:function(){return v},jL:function(){return j},oN:function(){return b},ph:function(){return R},rC:function(){return g},rw:function(){return C},s6:function(){return I},sA:function(){return B},sZ:function(){return A},ul:function(){return u},yG:function(){return d},y_:function(){return L},yr:function(){return E}});var r=n(9495),o=n(597),i=n(28560);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function u(e,t){const n=t();return(0,r._K2)().getBool("DEBUG")&&s(e),n}function s(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+f(e,t))}const a=5.96e-8,l=65504;function c(e){return!!((0,r._K2)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||a<Math.abs(e)&&Math.abs(e)<l)}function f(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function h(e,t){return D(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}function E(e,t){const n=D(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(u(e,(()=>e.shaderSource(n,t))),u(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function d(e,t){const n=D(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(u(e,(()=>e.shaderSource(n,t))),u(e,(()=>e.compileShader(n))),(0,r._K2)().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw p(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const T=/ERROR: [0-9]+:([0-9]+):/g;function p(e,t){const n=T.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const o=+n[1],i=e.split("\n"),u=i.length.toString().length+2,s=i.map(((e,t)=>r.ZSL.rightPad((t+1).toString(),u)+e));let a=0;for(let r=0;r<s.length;r++)a=Math.max(s[r].length,a);const l=s.slice(0,o-1),c=s.slice(o-1,o),f=s.slice(o);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${r.ZSL.rightPad(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(f.join("\n"))}function g(e){return D(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}function _(e,t){if(u(e,(()=>e.linkProgram(t))),!(0,r._K2)().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function x(e,t){if(u(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function m(e,t){const n=D(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return u(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),u(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function F(e,t){const n=D(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return u(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),u(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function A(e){return D(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}function R(e,t){const n=(0,r._K2)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){const n=`[${e}x${t}]`;throw new Error("Requested texture size "+n+" is invalid.")}if(e>n||t>n){const r=`[${e}x${t}]`,o=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+o+".")}}function b(e){return D(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}function C(e,t,n,r,o,i,s){const a=e.getAttribLocation(t,n);return-1!==a&&(u(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),u(e,(()=>e.vertexAttribPointer(a,o,e.FLOAT,!1,i,s))),u(e,(()=>e.enableVertexAttribArray(a))),!0)}function N(e,t,n){P(e,n),u(e,(()=>e.activeTexture(e.TEXTURE0+n))),u(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}function U(e,t,n){return D(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}function O(e,t,n){return e.getUniformLocation(t,n)}function L(e,t,n,r){u(e,(()=>N(e,t,r))),u(e,(()=>e.uniform1i(n,r)))}function S(e,t,n){u(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),u(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function B(e,t){u(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),u(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function I(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+M(e,t))}function M(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function D(e,t,n){const r=u(e,(()=>t()));if(null==r)throw new Error(n);return r}function P(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){const e=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${e}.`)}}function y(e,t=2){return r.ZSL.sizeFromShape(e.slice(0,e.length-t))}function w(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function X(e){let t=[1,1,1];const n=0===e.length||1===e.length&&1===e[0];return n||(t=[y(e),...w(e)]),t}function v(e,t=!1){let n=(0,r._K2)().getNumber("WEBGL_MAX_TEXTURE_SIZE"),o=(0,r._K2)().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(o===1/0&&(0,r._K2)().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(o=n/2),t&&(n*=2,o*=2,e=e.map(((t,n)=>n>=e.length-2?r.ZSL.nearestLargerEven(e[n]):e[n])),1===e.length&&(e=[2,e[0]])),2!==e.length){const t=r.ZSL.squeezeShape(e);e=t.newShape}let i=r.ZSL.sizeFromShape(e),u=null;e.length<=1&&i<=n?u=[1,i]:2===e.length&&e[0]<=n&&e[1]<=n?u=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?u=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?u=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?u=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(u=[e[0],e[1]*e[2]*e[3]]);const s=null!=u&&Math.max(...u)>o&&Math.min(...u)<=(t?2:1)&&Math.min(...u)>0;if(null==u||s)if(t){const t=y(e);let n=2,o=2;e.length&&([n,o]=w(e)),i=t*(n/2)*(o/2),u=r.ZSL.sizeToSquarishShape(i).map((e=>2*e))}else u=r.ZSL.sizeToSquarishShape(i);return u}function k(e){return e%2===0}function $(e,t){if(e=e.slice(-2),t=t.slice(-2),r.ZSL.arraysEqual(e,t))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e[e.length-1],r=t[t.length-1];if(n===r)return!0;if(k(n)&&k(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&k(e[0])&&k(t[0])}let G,K;function W(e){if(null==G){const t=(0,o.bU)(e);G=t.getParameter(t.MAX_TEXTURE_SIZE)}return G}function j(e){if(null==K){const t=(0,o.bU)(e);K=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,K)}function Y(e){if(0===e)return 0;let t;const n=(0,o.bU)(e);return t=z(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:z(n,"EXT_disjoint_timer_query")?1:0,t}function z(e,t){const n=e.getExtension(t);return null!=n}function V(e){try{const t=(0,o.bU)(e);if(null!=t)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function H(e){if(0===e)return!1;const t=(0,o.bU)(e);if(1===e){if(!z(t,"OES_texture_float"))return!1}else if(!z(t,"EXT_color_buffer_float"))return!1;const n=q(t);return n}function Z(e){if(0===e)return!1;const t=(0,o.bU)(e);if(1!==e){if(z(t,"EXT_color_buffer_float"))return q(t);const e="EXT_color_buffer_half_float";if(z(t,e)){const n=t.getExtension(e);return Q(t,n)}return!1}if(!z(t,"OES_texture_float"))return!1;if(!z(t,"WEBGL_color_buffer_float"))return!1;const n=q(t);return n}function q(e){const t=(0,i.EZ)(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);const r=1,o=1;e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,r,o,0,t.textureFormatFloat,t.textureTypeFloat,null);const u=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,u),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(u),s}function Q(e,t){const n=(0,i.EZ)(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);const o=1,u=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,o,u,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(s),a}function J(e){if(2!==e)return!1;const t=(0,o.bU)(e),n=null!=t.fenceSync;return n}function ee(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&r.ZSL.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}}}]);
//# sourceMappingURL=chunk-vendors-88077a20.27ec341c.js.map