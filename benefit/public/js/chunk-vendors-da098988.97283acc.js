"use strict";(self["webpackChunkbenefit"]=self["webpackChunkbenefit"]||[]).push([[4528],{90212:function(e,t,n){n.d(t,{K:function(){return a}});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class a{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));const a=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${a};\n        setOutput(result);\n      }\n    `}}},31445:function(e,t,n){n.d(t,{c:function(){return a}});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class a{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));const a=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${a};\n        setOutput(result);\n      }\n    `}}},60287:function(e,t,n){n.d(t,{l:function(){return a}});
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class a{constructor(e,t,n){this.variableNames=["A"];const{windowSize:a,batchSize:s,outSize:i}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,i];const o="max"===t?">":"<",r=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${a};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${a}; i++) {\n          int inIdx = ${r};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${o} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}},62780:function(e,t,n){n.d(t,{l:function(){return o}});var a=n(9495),s=n(75694),i=n(27575);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class o{constructor(e,t,n,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,a.ZSL.assert(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const r=e[e.length-1],d=Math.ceil(r/t);this.outputShape=e.slice(0,-1),d>1&&this.outputShape.push(d),o||this.variableNames.push("bestIndicesA");const u=this.outputShape,h=u.length,c=(0,i.bf)(h),l=(0,s.Jp)("coords",h);let p,g;if(1===d){g=h+1;const e=(0,i.bf)(g);p=`\n        ${e} sourceLocR = ${e}(${l.join()}, 0);\n        ++${l[h-1]};\n        ${e} sourceLocG = ${e}(${l.join()}, 0);\n        ++${l[h-2]};\n        ${e} sourceLocA = ${e}(${l.join()}, 0);\n        --${l[h-1]};\n        ${e} sourceLocB = ${e}(${l.join()}, 0);\n        --${l[h-2]};`}else g=h,p=`\n        ${c} sourceLocR = coords;\n        ++${l[h-1]};\n        ${c} sourceLocG = coords;\n        ++${l[h-2]};\n        ${c} sourceLocA = coords;\n        --${l[h-1]};\n        ${c} sourceLocB = coords;\n        --${l[h-2]};`;const m=["x","y","z","w","u","v"].slice(0,g),f="."+m[g-1],x=m.map((e=>"int "+e)),y=(0,s.Jp)("sourceLocR",g-1).concat("inIdx.r"),I=(0,s.Jp)("sourceLocG",g-1).concat("inIdx.g"),C=(0,s.Jp)("sourceLocB",g-1).concat("inIdx.b"),L=(0,s.Jp)("sourceLocA",g-1).concat("inIdx.a"),w="max"===n?"greaterThan":"lessThan",b=o?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${I.join()}),\n                             getBestIndicesAChannel(${C.join()}),\n                             getBestIndicesAChannel(${L.join()})));`,T=`vec4(\n            getAChannel(${y.join()}),\n            hasNextCol ? getAChannel(${I.join()}) : 0.,\n            hasNextRow ? getAChannel(${C.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${L.join()}) : 0.)`,E=o?"":`\n      float getBestIndicesAChannel(${x.join()}) {\n        return getChannel(getBestIndicesA(${m.join()}),\n                                          vec2(${m.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${x.join()}) {\n        return getChannel(getA(${m.join()}),\n                               vec2(${m.slice(-2).join()}));\n      }\n      ${E}\n      void main() {\n        ${c} coords = getOutputCoords();\n        bool hasNextCol = ${l[h-1]} < ${u[h-1]-1};\n        bool hasNextRow = ${l[h-2]} < ${u[h-2]-1};\n        ${p}\n        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},\n          sourceLocB${f}, sourceLocA${f}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${T};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${b}\n          vec4 candidate = ${T};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${w}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}},94491:function(e,t,n){n.d(t,{q:function(){return s},x:function(){return a}});
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class a{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,s=e.strideWidth,i=e.dilationHeight,o=e.dilationWidth,r=e.effectiveFilterHeight,d=e.effectiveFilterWidth,u=r-1-e.padInfo.top,h=d-1-e.padInfo.left,c=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${h});\n      const float avgMultiplier = float(${c});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${r};\n            wR += ${i}) {\n          float dyR = float(dyRCorner + wR) / ${a}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${d};\n            wC+= ${o}) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class s{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,s=e.strideDepth,i=e.strideHeight,o=e.strideWidth,r=e.dilationDepth,d=e.dilationHeight,u=e.dilationWidth,h=e.effectiveFilterDepth,c=e.effectiveFilterHeight,l=e.effectiveFilterWidth,p=h-1-e.padInfo.front,g=c-1-e.padInfo.top,m=l-1-e.padInfo.left,f=1/(t*n*a);this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${g}, ${m});\n      const float avgMultiplier = float(${f});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${h};\n            wD += ${r}) {\n          float dyD = float(dyDCorner + wD) / ${s}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${c};\n              wR += ${d}) {\n            float dyR = float(dyRCorner + wR) / ${i}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${l};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${o}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}},77546:function(e,t,n){n.d(t,{Q6:function(){return _}});n(86541);var a=n(9495),s=n(597),i=n(54499),o=n(78576),r=n(35368),d=n(8697),u=n(24187),h=n(75320),c=n(63839),l=n(22792),p=n(76905),g=n(30282),m=n(1404),f=n(28560),x=n(47403),y=n(68173),I=n(74890),C=n(46969),L=n(88380);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const w=a.kpo.YO,b=1e-7,T=1e-4,E={};function D(e){return e in E||(E[e]={}),E[e]}const v=(0,a._K2)().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),P=600;function S(){return null==(0,a._K2)().global.screen?1024:(0,a._K2)().global.screen.height*(0,a._K2)().global.screen.width*window.devicePixelRatio*P/1024/1024}class _ extends a.uI_{nextDataId(){return _.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!(0,a._K2)().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof c.n)t=e;else{const n=(0,s.bU)((0,a._K2)().getNumber("WEBGL_VERSION"),e);t=new c.n(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=(0,s.bU)((0,a._K2)().getNumber("WEBGL_VERSION"));t=new c.n(e),this.binaryCache=D((0,a._K2)().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new x.p(this.gpgpu),this.numMBBeforeWarning=S(),this.texData=new a.GJx(this,(0,a.Hi9)())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,a,s,i){const o=this.makeTensorInfo(t,n),r=this.texData.get(o.dataId);r.isPacked=!1,r.texture={texture:e,texShape:[a,s]},r.texShape=[a,s];const d=L.FP(t),h=new u.C(d,!1,i),c=this.runWebGLProgram(h,[o],n,[[a,s]]);return c.shape=t,r.texture=null,this.disposeIntermediateTensorInfo(o),c.dataId}write(e,t,n){if(((0,a._K2)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||(0,a._K2)().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:t,dtype:n,values:e,usage:f.tT.UPLOAD,refCount:1}),s}refCount(e){if(this.texData.has(e)){const t=this.texData.get(e);return t.refCount}return 0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,n,s,i){if((0,a._K2)().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===s)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:s,values:t,usage:f.tT.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:s,complexTensorInfos:i,slice:o,shape:r,isPacked:d}=t;if(null!=o){let t;t=d?new I.rf(r,y.UC):new y.hE(r,y.UC);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:s}],s),a=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===s)return n;const u=null!=this.activeTimers;let h,c;if(u&&(h=a.ZSL.now()),"complex64"===s){const e=this.readSync(i.real.dataId),t=this.readSync(i.imag.dataId);c=a.C0T.mergeRealAndImagArrays(e,t)}else c=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=a.ZSL.now()-h),this.convertAndCacheOnCPU(e,c)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:s,slice:i,dtype:o,complexTensorInfos:r,isPacked:d}=t;if(null!=i){let t;t=d?new I.rf(s,y.UC):new y.hE(s,y.UC);const n=this.runWebGLProgram(t,[{dataId:e,shape:s,dtype:o}],o),a=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if((0,a._K2)().getBool("DEBUG")&&!(0,a._K2)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===(0,a._K2)().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u,h,c=null;if("complex64"!==o&&(0,a._K2)().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(e);const t=this.texData.get(u.dataId);c=this.gpgpu.createBufferFromTexture(t.texture.texture,...f.GM(s))}if(this.pendingRead.set(e,[]),"complex64"!==o&&await this.gpgpu.createAndWaitForFence(),"complex64"===o){const e=await Promise.all([this.read(r.real.dataId),this.read(r.imag.dataId)]),t=e[0],n=e[1];h=a.C0T.mergeRealAndImagArrays(t,n)}else if(null==c)h=this.getValuesFromTexture(e);else{const e=a.ZSL.sizeFromShape(s);h=this.gpgpu.downloadFloat32MatrixFromBuffer(c,e)}if(null!=u&&this.disposeIntermediateTensorInfo(u),null!=c){const e=this.gpgpu.gl;L.ul(e,(()=>e.deleteBuffer(c)))}const l=this.convertAndCacheOnCPU(e,h),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach((e=>e(l))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&(0,a.Hi9)().removeDataId(e,this),this.pendingDeletes--),l}readToGPU(e,t={}){const n=this.texData.get(e),{values:s,shape:i,slice:o,dtype:r,isPacked:d,texture:u}=n;if("complex64"===r)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=o){let n;n=d?new I.rf(i,y.UC):new y.hE(i,y.UC);const a=this.runWebGLProgram(n,[{dataId:e,shape:i,dtype:r}],r),s=this.readToGPU(a,t);return this.disposeIntermediateTensorInfo(a),s}if(null==u)throw null!=s?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const h=this.decode(e,t.customTexShape),c=(0,a.Hi9)().makeTensorFromTensorInfo(h),l=this.texData.get(h.dataId);return Object.assign({tensorRef:c},l.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>a.ZSL.decodeString(e)));return(0,a.ra8)(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,a.ra8)(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!L.dm(n)){if((0,a._K2)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:s}=this.texData.get(e),i=a.ZSL.sizeFromShape(t);if((0,a._K2)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),a=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(a.texture.texture,...f.GM(t)).subarray(0,i);return this.disposeIntermediateTensorInfo(n),s}const o=(0,a._K2)().getBool("WEBGL_PACK")&&!0===s,u=o?L.FP(t):t,h=o?new d.N(u):new r.$(u),c=this.runWebGLProgram(h,[{shape:u,dtype:n,dataId:e}],"float32"),l=this.texData.get(c.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture.texture,l.texShape[0],l.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(c),p}timerAvailable(){return(0,a._K2)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let s=!1;null==this.programTimersStack?(this.programTimersStack=n,s=!0):this.activeTimers.push(n),this.activeTimers=n,e();const i=a.ZSL.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),o=a.ZSL.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,s&&(this.programTimersStack=null);const r={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if((0,a._K2)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(i);r["kernelMs"]=a.ZSL.sum(e),r["getExtraProfileInfo"]=()=>e.map(((e,t)=>({name:o[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else r["kernelMs"]={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,r})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return(0,a._K2)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:a.ZSL.now(),endMs:null}}endTimer(e){return(0,a._K2)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=a.ZSL.now(),e)}async getQueryTime(e){if((0,a._K2)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:a,usage:s,isPacked:i,slice:o}=this.texData.get(e),r=o&&o.origDataId||e,d=this.dataRefCount.get(r);d>1?this.dataRefCount.set(r,d-1):(this.dataRefCount.delete(r),null!=t&&(this.numBytesInGPU-=this.computeBytes(a,n),this.textureManager.releaseTexture(t,a,s,i)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=v){return(0,a._K2)().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&a.ZSL.sizeFromShape(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){a.C0T.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return w(e.shape,t)}packedUnaryOp(e,t,n){const s=new I.rf(e.shape,t),i=this.compileAndRun(s,[e],n);return(0,a.Hi9)().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=(0,p.f8)(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if((0,a._K2)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,y.pd,e.dtype);const t=new y.hE(e.shape,y.pd),n=this.compileAndRun(t,[e]);return(0,a.Hi9)().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let s;if("string"===t&&null!=n&&n.length>0&&a.ZSL.isString(n[0])){const i=n.map((e=>a.ZSL.encodeString(e)));s=this.write(i,e,t)}else s=this.write(n,e,t);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:t}}makeOutput(e,t,n){return(0,a.Hi9)().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new C.z(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new g.m(e.shape),n=!0;return this.runWebGLProgram(t,[e],e.dtype,null,n)}packedReshape(e,t){const n=[L.N0(e.shape),...L.Ph(e.shape)],a={dtype:e.dtype,shape:n,dataId:e.dataId},s=[L.N0(t),...L.Ph(t)],i=new m.R(s,n),o=!0,r=[n],d=this.runWebGLProgram(i,[a],e.dtype,r,o);return{dataId:d.dataId,shape:t,dtype:d.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:s,shape:r,dtype:d}=n;if(null!=t){const e=a.ZSL.sizeFromShape(r),n=t[0]*t[1]*4;a.ZSL.assert(e<=n,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const u=L.FP(r);let h;h=s?new o.S(u):new i.K(u);const c=!0,l=[null!=t?t:f.GM(u)],p=this.runWebGLProgram(h,[{shape:u,dtype:d,dataId:e}],d,l,c,t);return{dtype:d,shape:r,dataId:p.dataId}}runWebGLProgram(e,t,n,s,i=!1,o){const r=this.makeTensorInfo(e.outputShape,n),d=this.texData.get(r.dataId);if(e.packedOutput&&(d.isPacked=!0),e.outPackingScheme===f.BB.DENSE){const t=null!=o?o:f.GM(e.outputShape);d.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(d.usage=e.outTexUsage),0===a.ZSL.sizeFromShape(r.shape))return d.values=a.ZSL.getTypedArrayFromDType(r.dtype,0),r;const u=[],h=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&a.ZSL.sizeFromShape(t.shape)<=(0,a._K2)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!==!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),u.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!L.P0(n.shape,t.shape)){const e=t,a=t.shape;t.shape=n.shape,t=this.packedReshape(t,a),u.push(t),n=this.texData.get(t.dataId),e.shape=a}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(r.dataId);const c={shape:r.shape,texData:d,isUniform:!1},p=l.Tb(e,h,c),g=this.getAndSaveBinary(p,(()=>l.Kz(this.gpgpu,e,h,c))),m=null!=this.activeTimers;let x;m&&(x=this.startTimer()),(0,a._K2)().get("ENGINE_COMPILE_ONLY")||l.mB(this.gpgpu,g,h,c,s),u.forEach((e=>this.disposeIntermediateTensorInfo(e))),m&&(x=this.endTimer(x),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(x)}));const y=(0,a._K2)().getNumber("WEBGL_FLUSH_THRESHOLD");if(y>0){const e=a.ZSL.now();e-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!(0,a._K2)().getBool("WEBGL_LAZILY_UNPACK")&&d.isPacked&&!1===i){const e=this.unpackTensor(r);return this.disposeIntermediateTensorInfo(r),e}return r}compileAndRun(e,t,n,a,s=!1){n=n||t[0].dtype;const i=this.runWebGLProgram(e,t,n,a,s);return i}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!(0,a._K2)().getBool("IS_TEST")){const e=Object.keys(this.binaryCache);e.forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!==typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=(0,a.DZQ)((()=>{if(!(0,a._K2)().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=(0,a._K2)().getBool("DEBUG");(0,a._K2)().set("DEBUG",!1);const t=this.abs((0,a.d_2)(1e-8)).dataSync()[0];if((0,a._K2)().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?b:T}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:s,values:i,texture:o,usage:r,isPacked:d}=t;if(null!=o)return;const c=null!=this.activeTimers;let l;c&&(l=a.ZSL.now());let p=t.texShape;if(null==p&&(p=L.fA(n,d),t.texShape=p),null!=i){const e=L.FP(n);let o,r=p[1],g=p[0];const m=i instanceof Uint8Array||i instanceof Uint8ClampedArray;!d&&m||([r,g]=f.NO(p[0],p[1])),o=d?new h.A(e,m):new u.C(e,m);const x=m?[g,r]:p,y=this.makeTensorInfo(x,s),I=this.texData.get(y.dataId);I.usage=m?f.tT.PIXELS:f.tT.UPLOAD,I.texShape=x,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(y.dataId),r,g,i);const C=[[g,r]],w=!0,b=this.runWebGLProgram(o,[y],s,C,w),T=this.texData.get(b.dataId);t.texShape=T.texShape,t.isPacked=T.isPacked,t.usage=T.usage,(0,a._K2)().get("ENGINE_COMPILE_ONLY")?this.disposeData(b.dataId):(t.texture=T.texture,t.values=null,this.texData.delete(b.dataId)),this.disposeIntermediateTensorInfo(y),c&&(this.uploadWaitMs+=a.ZSL.now()-l)}else{const e=this.acquireTexture(p,r,s,d);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:a}=n;return null!=t&&(n.values=$(t,a)),n.values}acquireTexture(e,t,n,a){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,a)}computeBytes(e,t){return e[0]*e[1]*a.ZSL.bytesPerElement(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await(0,a.dA1)(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw L.cr(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:a,nanLoc:s,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:r}=(0,l.Tw)(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=a,e.nanLoc=s,e.outShapeLocation=i,e.outShapeStridesLocation=o,e.outTexShapeLocation=r}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:s,height:i,width:o,channels:r}=e,d=(0,a.Hi9)().backend;if(!d.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const u=d.writeTexture(s,t,n,i,o,r);return(0,a.Hi9)().makeTensorFromDataId(u,t,n,d)}}function $(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}_.nextDataId=0}}]);
//# sourceMappingURL=chunk-vendors-da098988.97283acc.js.map