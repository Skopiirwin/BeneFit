{"version":3,"file":"js/chunk-vendors-1df7d678.bf391f48.js","mappings":";;;;;;;;;;;;;;;;;AAuCA,SAASA,EAAoBC,EAAOC,EAASC,EAASC,GAAgB,GAClE,MAAMC,GAAS,QAAgBJ,EAAO,QAAS,qBAAsB,UAC/DK,EAAQ,CAAEJ,UAASC,UAASC,iBAClC,OAAO,KAAOG,UAAU,MAAoB,CAAEC,EAAGH,GAAUC,EAC/D,CACO,MAAMG,GAAqC,IAAAC,IAAG,CAAEV,uB;;;;;;;;;;;;;;;;;ACiBvD,SAASW,EAAcC,EAAMC,EAAYC,EAAWC,EAAaC,EAASC,EAAUC,EAAUC,GAC1F,MAAMC,GAAQ,QAAgBR,EAAM,OAAQ,eAAgB,UAC5D,GAAoB,WAAhBQ,EAAMC,MACN,MAAM,IAAIC,MAAM,mCAEpB,GAA2B,IAAvBF,EAAMG,MAAMC,OACZ,MAAM,IAAIF,MAAM,+BAA+BF,EAAMG,SAEzD,MAAME,GAAc,QAAgBZ,EAAY,aAAc,gBAC9D,GAA0B,UAAtBY,EAAYJ,MACZ,MAAM,IAAIC,MAAM,yCAEpB,MAAMhB,EAAQ,CACVQ,YACAC,cACAC,UACAC,WACAC,WACAC,0BAEEO,EAAS,CAAEd,KAAMQ,EAAOP,WAAYY,GACpCE,EAAS,KAAOpB,UAAU,MAAcmB,EAAQpB,GACtD,MAAO,CAAEsB,OAAQD,EAAO,GAAIE,aAAcF,EAAO,GACrD,CACO,MAAMG,GAA+B,IAAApB,IAAG,CAAEC,iB;;;;;;;;;;;;;;;;;ACjCjD,SAASoB,EAAa9B,EAAO+B,EAAWC,GAAY,GAChD,MAAM5B,GAAS,QAAgBJ,EAAO,QAAS,cAAe,UACxDiC,GAAa,QAAgBF,EAAW,YAAa,cAAe,UAC1E,GAAoB,IAAhB3B,EAAO8B,KACP,MAAM,IAAIb,MAAM,+CAA+CjB,EAAOkB,SAE1E,GAAwB,IAApBW,EAAWC,KACX,MAAM,IAAIb,MAAM,mDAAmDY,EAAWX,SAElF,MAAMjB,EAAQ,CAAE2B,aACVP,EAAS,CAAEzB,MAAOI,EAAQ2B,UAAWE,GACrCP,EAAS,KAAOpB,UAAU,MAAamB,EAAQpB,GACrD,MAAO,CAAE8B,QAAST,EAAO,GAAIU,OAAQV,EAAO,GAAIJ,MAAOI,EAAO,GAClE,CACO,MAAMW,GAA8B,IAAA5B,IAAG,CAAEqB,gB;;;;;;;;;;;;;;;;;ACzBhD,SAASQ,EAAwBtC,EAAOuC,GACpC,MAAMnC,GAAS,QAAgBJ,EAAO,QAAS,yBAA0B,UACnEK,EAAQ,CAAEkC,cAChB,GAAIA,GAAc,EACd,MAAM,IAAIlB,MAAM,wCAEpB,MAAMI,EAAS,CAAEzB,MAAOI,GACxB,OAAO,KAAOE,UAAU,MAAwBmB,EAAQpB,EAC5D,CACO,MAAMmC,GAAyC,IAAA/B,IAAG,CAAE6B,2B","sources":["webpack://benefit/./node_modules/@tensorflow/tfjs-core/dist/ops/string/static_regex_replace.js","webpack://benefit/./node_modules/@tensorflow/tfjs-core/dist/ops/string/string_n_grams.js","webpack://benefit/./node_modules/@tensorflow/tfjs-core/dist/ops/string/string_split.js","webpack://benefit/./node_modules/@tensorflow/tfjs-core/dist/ops/string/string_to_hash_bucket_fast.js"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../../engine';\nimport { StaticRegexReplace } from '../../kernel_names';\nimport { convertToTensor } from '../../tensor_util_env';\nimport { op } from '../operation';\n/**\n * Replace the match of a `pattern` in `input` with `rewrite`.\n *\n * ```js\n * const result = tf.string.staticRegexReplace(\n *     ['format       this   spacing      better'], ' +', ' ');\n * result.print(); // ['format this spacing better']\n * ```\n * @param input: A Tensor of type string. The text to be processed.\n * @param pattern: A string. The regular expression to match the input.\n * @param rewrite: A string. The rewrite to be applied to the matched\n *     expression.\n * @param replaceGlobal: An optional bool. Defaults to True. If True, the\n *     replacement is global, otherwise the replacement is done only on the\n *     first match.\n * @return A Tensor of type string.\n *\n * @doc {heading: 'Operations', subheading: 'String'}\n */\nfunction staticRegexReplace_(input, pattern, rewrite, replaceGlobal = true) {\n    const $input = convertToTensor(input, 'input', 'staticRegexReplace', 'string');\n    const attrs = { pattern, rewrite, replaceGlobal };\n    return ENGINE.runKernel(StaticRegexReplace, { x: $input }, attrs);\n}\nexport const staticRegexReplace = /* @__PURE__ */ op({ staticRegexReplace_ });\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGljX3JlZ2V4X3JlcGxhY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWNvcmUvc3JjL29wcy9zdHJpbmcvc3RhdGljX3JlZ2V4X3JlcGxhY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLGNBQWMsQ0FBQztBQUNwQyxPQUFPLEVBQUMsa0JBQWtCLEVBQTBCLE1BQU0sb0JBQW9CLENBQUM7QUFHL0UsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBRXRELE9BQU8sRUFBQyxFQUFFLEVBQUMsTUFBTSxjQUFjLENBQUM7QUFFaEM7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWtCRztBQUNILFNBQVMsbUJBQW1CLENBQzFCLEtBQTBCLEVBQUUsT0FBZSxFQUFFLE9BQWUsRUFDNUQsYUFBYSxHQUFDLElBQUk7SUFFbEIsTUFBTSxNQUFNLEdBQUcsZUFBZSxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsb0JBQW9CLEVBQ3BDLFFBQVEsQ0FBQyxDQUFDO0lBQ3pDLE1BQU0sS0FBSyxHQUE0QixFQUFDLE9BQU8sRUFBRSxPQUFPLEVBQUUsYUFBYSxFQUFDLENBQUM7SUFDekUsT0FBTyxNQUFNLENBQUMsU0FBUyxDQUFDLGtCQUFrQixFQUFFLEVBQUMsQ0FBQyxFQUFFLE1BQU0sRUFBQyxFQUMvQixLQUFnQyxDQUFDLENBQUM7QUFDNUQsQ0FBQztBQUVELE1BQU0sQ0FBQyxNQUFNLGtCQUFrQixHQUFHLGVBQWUsQ0FBQyxFQUFFLENBQUMsRUFBQyxtQkFBbUIsRUFBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7RU5HSU5FfSBmcm9tICcuLi8uLi9lbmdpbmUnO1xuaW1wb3J0IHtTdGF0aWNSZWdleFJlcGxhY2UsIFN0YXRpY1JlZ2V4UmVwbGFjZUF0dHJzfSBmcm9tICcuLi8uLi9rZXJuZWxfbmFtZXMnO1xuaW1wb3J0IHtOYW1lZEF0dHJNYXB9IGZyb20gJy4uLy4uL2tlcm5lbF9yZWdpc3RyeSc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vdGVuc29yJztcbmltcG9ydCB7Y29udmVydFRvVGVuc29yfSBmcm9tICcuLi8uLi90ZW5zb3JfdXRpbF9lbnYnO1xuaW1wb3J0IHtUZW5zb3JMaWtlfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQge29wfSBmcm9tICcuLi9vcGVyYXRpb24nO1xuXG4vKipcbiAqIFJlcGxhY2UgdGhlIG1hdGNoIG9mIGEgYHBhdHRlcm5gIGluIGBpbnB1dGAgd2l0aCBgcmV3cml0ZWAuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHJlc3VsdCA9IHRmLnN0cmluZy5zdGF0aWNSZWdleFJlcGxhY2UoXG4gKiAgICAgWydmb3JtYXQgICAgICAgdGhpcyAgIHNwYWNpbmcgICAgICBiZXR0ZXInXSwgJyArJywgJyAnKTtcbiAqIHJlc3VsdC5wcmludCgpOyAvLyBbJ2Zvcm1hdCB0aGlzIHNwYWNpbmcgYmV0dGVyJ11cbiAqIGBgYFxuICogQHBhcmFtIGlucHV0OiBBIFRlbnNvciBvZiB0eXBlIHN0cmluZy4gVGhlIHRleHQgdG8gYmUgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHBhdHRlcm46IEEgc3RyaW5nLiBUaGUgcmVndWxhciBleHByZXNzaW9uIHRvIG1hdGNoIHRoZSBpbnB1dC5cbiAqIEBwYXJhbSByZXdyaXRlOiBBIHN0cmluZy4gVGhlIHJld3JpdGUgdG8gYmUgYXBwbGllZCB0byB0aGUgbWF0Y2hlZFxuICogICAgIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0gcmVwbGFjZUdsb2JhbDogQW4gb3B0aW9uYWwgYm9vbC4gRGVmYXVsdHMgdG8gVHJ1ZS4gSWYgVHJ1ZSwgdGhlXG4gKiAgICAgcmVwbGFjZW1lbnQgaXMgZ2xvYmFsLCBvdGhlcndpc2UgdGhlIHJlcGxhY2VtZW50IGlzIGRvbmUgb25seSBvbiB0aGVcbiAqICAgICBmaXJzdCBtYXRjaC5cbiAqIEByZXR1cm4gQSBUZW5zb3Igb2YgdHlwZSBzdHJpbmcuXG4gKlxuICogQGRvYyB7aGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnU3RyaW5nJ31cbiAqL1xuZnVuY3Rpb24gc3RhdGljUmVnZXhSZXBsYWNlXyhcbiAgaW5wdXQ6IFRlbnNvciB8IFRlbnNvckxpa2UsIHBhdHRlcm46IHN0cmluZywgcmV3cml0ZTogc3RyaW5nLFxuICByZXBsYWNlR2xvYmFsPXRydWUpOiBUZW5zb3Ige1xuXG4gIGNvbnN0ICRpbnB1dCA9IGNvbnZlcnRUb1RlbnNvcihpbnB1dCwgJ2lucHV0JywgJ3N0YXRpY1JlZ2V4UmVwbGFjZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3RyaW5nJyk7XG4gIGNvbnN0IGF0dHJzOiBTdGF0aWNSZWdleFJlcGxhY2VBdHRycyA9IHtwYXR0ZXJuLCByZXdyaXRlLCByZXBsYWNlR2xvYmFsfTtcbiAgcmV0dXJuIEVOR0lORS5ydW5LZXJuZWwoU3RhdGljUmVnZXhSZXBsYWNlLCB7eDogJGlucHV0fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnMgYXMgdW5rbm93biBhcyBOYW1lZEF0dHJNYXApO1xufVxuXG5leHBvcnQgY29uc3Qgc3RhdGljUmVnZXhSZXBsYWNlID0gLyogQF9fUFVSRV9fICovIG9wKHtzdGF0aWNSZWdleFJlcGxhY2VffSk7XG4iXX0=","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../../engine';\nimport { StringNGrams } from '../../kernel_names';\nimport { convertToTensor } from '../../tensor_util_env';\nimport { op } from '../operation';\n/**\n * Creates ngrams from ragged string data.\n *\n * This op accepts a ragged tensor with 1 ragged dimension containing only\n * strings and outputs a ragged tensor with 1 ragged dimension containing ngrams\n * of that string, joined along the innermost axis.\n *\n * ```js\n * const result = tf.string.stringNGrams(\n *   ['a', 'b', 'c', 'd'], tf.tensor1d([0, 2, 4], 'int32'),\n *   '|', [1, 2], 'LP', 'RP', -1, false);\n * result['nGrams'].print(); // ['a', 'b', 'LP|a', 'a|b', 'b|RP',\n *                           //  'c', 'd', 'LP|c', 'c|d', 'd|RP']\n * result['nGramsSplits'].print(); // [0, 5, 10]\n * ```\n * @param data: The values tensor of the ragged string tensor to make ngrams out\n *     of. Must be a 1D string tensor.\n * @param dataSplits: The splits tensor of the ragged string tensor to make\n *     ngrams out of.\n * @param separator: The string to append between elements of the token. Use \"\"\n *     for no separator.\n * @param nGramWidths: The sizes of the ngrams to create.\n * @param leftPad: The string to use to pad the left side of the ngram sequence.\n *     Only used if pad_width !== 0.\n * @param rightPad: The string to use to pad the right side of the ngram\n *     sequence. Only used if pad_width !== 0.\n * @param padWidth: The number of padding elements to add to each side of each\n *     sequence. Note that padding will never be greater than `nGramWidths`-1\n *     regardless of this value. If `padWidth`=-1, then add max(`nGramWidths`)-1\n *     elements.\n * @param preserveShortSequences: If true, then ensure that at least one ngram\n *     is generated for each input sequence. In particular, if an input sequence\n *     is shorter than min(ngramWidth) + 2*padWidth, then generate a single\n *     ngram containing the entire sequence. If false, then no ngrams are\n *     generated for these short input sequences.\n * @return A map with the following properties:\n *     - nGrams: The values tensor of the output ngrams ragged tensor.\n *     - nGramsSplits: The splits tensor of the output ngrams ragged tensor.\n *\n * @doc {heading: 'Operations', subheading: 'String'}\n */\nfunction stringNGrams_(data, dataSplits, separator, nGramWidths, leftPad, rightPad, padWidth, preserveShortSequences) {\n    const $data = convertToTensor(data, 'data', 'stringNGrams', 'string');\n    if ($data.dtype !== 'string') {\n        throw new Error('Data must be of datatype string');\n    }\n    if ($data.shape.length !== 1) {\n        throw new Error(`Data must be a vector, saw: ${$data.shape}`);\n    }\n    const $dataSplits = convertToTensor(dataSplits, 'dataSplits', 'stringNGrams');\n    if ($dataSplits.dtype !== 'int32') {\n        throw new Error('Data splits must be of datatype int32');\n    }\n    const attrs = {\n        separator,\n        nGramWidths,\n        leftPad,\n        rightPad,\n        padWidth,\n        preserveShortSequences\n    };\n    const inputs = { data: $data, dataSplits: $dataSplits };\n    const result = ENGINE.runKernel(StringNGrams, inputs, attrs);\n    return { nGrams: result[0], nGramsSplits: result[1] };\n}\nexport const stringNGrams = /* @__PURE__ */ op({ stringNGrams_ });\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RyaW5nX25fZ3JhbXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWNvcmUvc3JjL29wcy9zdHJpbmcvc3RyaW5nX25fZ3JhbXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLGNBQWMsQ0FBQztBQUNwQyxPQUFPLEVBQUMsWUFBWSxFQUF3QyxNQUFNLG9CQUFvQixDQUFDO0FBR3ZGLE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUV0RCxPQUFPLEVBQUMsRUFBRSxFQUFDLE1BQU0sY0FBYyxDQUFDO0FBRWhDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBd0NHO0FBQ0gsU0FBUyxhQUFhLENBQ2xCLElBQXlCLEVBQUUsVUFBNkIsRUFBRSxTQUFpQixFQUMzRSxXQUFxQixFQUFFLE9BQWUsRUFBRSxRQUFnQixFQUFFLFFBQWdCLEVBQzFFLHNCQUErQjtJQUNqQyxNQUFNLEtBQUssR0FBRyxlQUFlLENBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRSxjQUFjLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDdEUsSUFBSSxLQUFLLENBQUMsS0FBSyxLQUFLLFFBQVEsRUFBRTtRQUM1QixNQUFNLElBQUksS0FBSyxDQUFDLGlDQUFpQyxDQUFDLENBQUM7S0FDcEQ7SUFDRCxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtRQUM1QixNQUFNLElBQUksS0FBSyxDQUFDLCtCQUErQixLQUFLLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztLQUMvRDtJQUVELE1BQU0sV0FBVyxHQUFHLGVBQWUsQ0FBQyxVQUFVLEVBQUUsWUFBWSxFQUFFLGNBQWMsQ0FBQyxDQUFDO0lBQzlFLElBQUksV0FBVyxDQUFDLEtBQUssS0FBSyxPQUFPLEVBQUU7UUFDakMsTUFBTSxJQUFJLEtBQUssQ0FBQyx1Q0FBdUMsQ0FBQyxDQUFDO0tBQzFEO0lBRUQsTUFBTSxLQUFLLEdBQXNCO1FBQy9CLFNBQVM7UUFDVCxXQUFXO1FBQ1gsT0FBTztRQUNQLFFBQVE7UUFDUixRQUFRO1FBQ1Isc0JBQXNCO0tBQ3ZCLENBQUM7SUFFRixNQUFNLE1BQU0sR0FBdUIsRUFBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUMsQ0FBQztJQUMxRSxNQUFNLE1BQU0sR0FDUixNQUFNLENBQUMsU0FBUyxDQUFDLFlBQVksRUFBRSxNQUFZLEVBQUUsS0FBVyxDQUFDLENBQUM7SUFDOUQsT0FBTyxFQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsWUFBWSxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDO0FBQ3RELENBQUM7QUFFRCxNQUFNLENBQUMsTUFBTSxZQUFZLEdBQUcsZUFBZSxDQUFDLEVBQUUsQ0FBQyxFQUFDLGFBQWEsRUFBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7RU5HSU5FfSBmcm9tICcuLi8uLi9lbmdpbmUnO1xuaW1wb3J0IHtTdHJpbmdOR3JhbXMsIFN0cmluZ05HcmFtc0F0dHJzLCBTdHJpbmdOR3JhbXNJbnB1dHN9IGZyb20gJy4uLy4uL2tlcm5lbF9uYW1lcyc7XG5pbXBvcnQge1RlbnNvciwgVGVuc29yMUR9IGZyb20gJy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge05hbWVkVGVuc29yTWFwfSBmcm9tICcuLi8uLi90ZW5zb3JfdHlwZXMnO1xuaW1wb3J0IHtjb252ZXJ0VG9UZW5zb3J9IGZyb20gJy4uLy4uL3RlbnNvcl91dGlsX2Vudic7XG5pbXBvcnQge1RlbnNvckxpa2V9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7b3B9IGZyb20gJy4uL29wZXJhdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBuZ3JhbXMgZnJvbSByYWdnZWQgc3RyaW5nIGRhdGEuXG4gKlxuICogVGhpcyBvcCBhY2NlcHRzIGEgcmFnZ2VkIHRlbnNvciB3aXRoIDEgcmFnZ2VkIGRpbWVuc2lvbiBjb250YWluaW5nIG9ubHlcbiAqIHN0cmluZ3MgYW5kIG91dHB1dHMgYSByYWdnZWQgdGVuc29yIHdpdGggMSByYWdnZWQgZGltZW5zaW9uIGNvbnRhaW5pbmcgbmdyYW1zXG4gKiBvZiB0aGF0IHN0cmluZywgam9pbmVkIGFsb25nIHRoZSBpbm5lcm1vc3QgYXhpcy5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgcmVzdWx0ID0gdGYuc3RyaW5nLnN0cmluZ05HcmFtcyhcbiAqICAgWydhJywgJ2InLCAnYycsICdkJ10sIHRmLnRlbnNvcjFkKFswLCAyLCA0XSwgJ2ludDMyJyksXG4gKiAgICd8JywgWzEsIDJdLCAnTFAnLCAnUlAnLCAtMSwgZmFsc2UpO1xuICogcmVzdWx0WyduR3JhbXMnXS5wcmludCgpOyAvLyBbJ2EnLCAnYicsICdMUHxhJywgJ2F8YicsICdifFJQJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICdjJywgJ2QnLCAnTFB8YycsICdjfGQnLCAnZHxSUCddXG4gKiByZXN1bHRbJ25HcmFtc1NwbGl0cyddLnByaW50KCk7IC8vIFswLCA1LCAxMF1cbiAqIGBgYFxuICogQHBhcmFtIGRhdGE6IFRoZSB2YWx1ZXMgdGVuc29yIG9mIHRoZSByYWdnZWQgc3RyaW5nIHRlbnNvciB0byBtYWtlIG5ncmFtcyBvdXRcbiAqICAgICBvZi4gTXVzdCBiZSBhIDFEIHN0cmluZyB0ZW5zb3IuXG4gKiBAcGFyYW0gZGF0YVNwbGl0czogVGhlIHNwbGl0cyB0ZW5zb3Igb2YgdGhlIHJhZ2dlZCBzdHJpbmcgdGVuc29yIHRvIG1ha2VcbiAqICAgICBuZ3JhbXMgb3V0IG9mLlxuICogQHBhcmFtIHNlcGFyYXRvcjogVGhlIHN0cmluZyB0byBhcHBlbmQgYmV0d2VlbiBlbGVtZW50cyBvZiB0aGUgdG9rZW4uIFVzZSBcIlwiXG4gKiAgICAgZm9yIG5vIHNlcGFyYXRvci5cbiAqIEBwYXJhbSBuR3JhbVdpZHRoczogVGhlIHNpemVzIG9mIHRoZSBuZ3JhbXMgdG8gY3JlYXRlLlxuICogQHBhcmFtIGxlZnRQYWQ6IFRoZSBzdHJpbmcgdG8gdXNlIHRvIHBhZCB0aGUgbGVmdCBzaWRlIG9mIHRoZSBuZ3JhbSBzZXF1ZW5jZS5cbiAqICAgICBPbmx5IHVzZWQgaWYgcGFkX3dpZHRoICE9PSAwLlxuICogQHBhcmFtIHJpZ2h0UGFkOiBUaGUgc3RyaW5nIHRvIHVzZSB0byBwYWQgdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIG5ncmFtXG4gKiAgICAgc2VxdWVuY2UuIE9ubHkgdXNlZCBpZiBwYWRfd2lkdGggIT09IDAuXG4gKiBAcGFyYW0gcGFkV2lkdGg6IFRoZSBudW1iZXIgb2YgcGFkZGluZyBlbGVtZW50cyB0byBhZGQgdG8gZWFjaCBzaWRlIG9mIGVhY2hcbiAqICAgICBzZXF1ZW5jZS4gTm90ZSB0aGF0IHBhZGRpbmcgd2lsbCBuZXZlciBiZSBncmVhdGVyIHRoYW4gYG5HcmFtV2lkdGhzYC0xXG4gKiAgICAgcmVnYXJkbGVzcyBvZiB0aGlzIHZhbHVlLiBJZiBgcGFkV2lkdGhgPS0xLCB0aGVuIGFkZCBtYXgoYG5HcmFtV2lkdGhzYCktMVxuICogICAgIGVsZW1lbnRzLlxuICogQHBhcmFtIHByZXNlcnZlU2hvcnRTZXF1ZW5jZXM6IElmIHRydWUsIHRoZW4gZW5zdXJlIHRoYXQgYXQgbGVhc3Qgb25lIG5ncmFtXG4gKiAgICAgaXMgZ2VuZXJhdGVkIGZvciBlYWNoIGlucHV0IHNlcXVlbmNlLiBJbiBwYXJ0aWN1bGFyLCBpZiBhbiBpbnB1dCBzZXF1ZW5jZVxuICogICAgIGlzIHNob3J0ZXIgdGhhbiBtaW4obmdyYW1XaWR0aCkgKyAyKnBhZFdpZHRoLCB0aGVuIGdlbmVyYXRlIGEgc2luZ2xlXG4gKiAgICAgbmdyYW0gY29udGFpbmluZyB0aGUgZW50aXJlIHNlcXVlbmNlLiBJZiBmYWxzZSwgdGhlbiBubyBuZ3JhbXMgYXJlXG4gKiAgICAgZ2VuZXJhdGVkIGZvciB0aGVzZSBzaG9ydCBpbnB1dCBzZXF1ZW5jZXMuXG4gKiBAcmV0dXJuIEEgbWFwIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogICAgIC0gbkdyYW1zOiBUaGUgdmFsdWVzIHRlbnNvciBvZiB0aGUgb3V0cHV0IG5ncmFtcyByYWdnZWQgdGVuc29yLlxuICogICAgIC0gbkdyYW1zU3BsaXRzOiBUaGUgc3BsaXRzIHRlbnNvciBvZiB0aGUgb3V0cHV0IG5ncmFtcyByYWdnZWQgdGVuc29yLlxuICpcbiAqIEBkb2Mge2hlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ1N0cmluZyd9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ05HcmFtc18oXG4gICAgZGF0YTogVGVuc29yMUR8VGVuc29yTGlrZSwgZGF0YVNwbGl0czogVGVuc29yfFRlbnNvckxpa2UsIHNlcGFyYXRvcjogc3RyaW5nLFxuICAgIG5HcmFtV2lkdGhzOiBudW1iZXJbXSwgbGVmdFBhZDogc3RyaW5nLCByaWdodFBhZDogc3RyaW5nLCBwYWRXaWR0aDogbnVtYmVyLFxuICAgIHByZXNlcnZlU2hvcnRTZXF1ZW5jZXM6IGJvb2xlYW4pOiBOYW1lZFRlbnNvck1hcCB7XG4gIGNvbnN0ICRkYXRhID0gY29udmVydFRvVGVuc29yKGRhdGEsICdkYXRhJywgJ3N0cmluZ05HcmFtcycsICdzdHJpbmcnKTtcbiAgaWYgKCRkYXRhLmR0eXBlICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBtdXN0IGJlIG9mIGRhdGF0eXBlIHN0cmluZycpO1xuICB9XG4gIGlmICgkZGF0YS5zaGFwZS5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGEgbXVzdCBiZSBhIHZlY3Rvciwgc2F3OiAkeyRkYXRhLnNoYXBlfWApO1xuICB9XG5cbiAgY29uc3QgJGRhdGFTcGxpdHMgPSBjb252ZXJ0VG9UZW5zb3IoZGF0YVNwbGl0cywgJ2RhdGFTcGxpdHMnLCAnc3RyaW5nTkdyYW1zJyk7XG4gIGlmICgkZGF0YVNwbGl0cy5kdHlwZSAhPT0gJ2ludDMyJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBzcGxpdHMgbXVzdCBiZSBvZiBkYXRhdHlwZSBpbnQzMicpO1xuICB9XG5cbiAgY29uc3QgYXR0cnM6IFN0cmluZ05HcmFtc0F0dHJzID0ge1xuICAgIHNlcGFyYXRvcixcbiAgICBuR3JhbVdpZHRocyxcbiAgICBsZWZ0UGFkLFxuICAgIHJpZ2h0UGFkLFxuICAgIHBhZFdpZHRoLFxuICAgIHByZXNlcnZlU2hvcnRTZXF1ZW5jZXNcbiAgfTtcblxuICBjb25zdCBpbnB1dHM6IFN0cmluZ05HcmFtc0lucHV0cyA9IHtkYXRhOiAkZGF0YSwgZGF0YVNwbGl0czogJGRhdGFTcGxpdHN9O1xuICBjb25zdCByZXN1bHQ6IFRlbnNvcltdID1cbiAgICAgIEVOR0lORS5ydW5LZXJuZWwoU3RyaW5nTkdyYW1zLCBpbnB1dHMgYXMge30sIGF0dHJzIGFzIHt9KTtcbiAgcmV0dXJuIHtuR3JhbXM6IHJlc3VsdFswXSwgbkdyYW1zU3BsaXRzOiByZXN1bHRbMV19O1xufVxuXG5leHBvcnQgY29uc3Qgc3RyaW5nTkdyYW1zID0gLyogQF9fUFVSRV9fICovIG9wKHtzdHJpbmdOR3JhbXNffSk7XG4iXX0=","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../../engine';\nimport { StringSplit } from '../../kernel_names';\nimport { convertToTensor } from '../../tensor_util_env';\nimport { op } from '../operation';\n/**\n * Split elements of `input` based on `delimiter` into a SparseTensor .\n *\n * Let N be the size of source (typically N will be the batch size). Split each\n * element of `input` based on `delimiter` and return a SparseTensor containing\n * the splitted tokens. Empty tokens are ignored if `skipEmpty` is set to True.\n *\n * `delimiter` can be empty, or a string of split characters. If `delimiter` is\n * an empty string, each element of `input` is split into individual\n * character strings. Otherwise every character of `delimiter` is a potential\n * split point.\n *\n * ```js\n * const result = tf.string.stringSplit(['hello world',  'a b c'], ' ');\n * result['indices'].print(); // [[0, 0], [0, 1], [1, 0], [1, 1], [1, 2]]\n * result['values'].print(); // ['hello', 'world', 'a', 'b', 'c']\n * result['shape'].print(); // [2, 3]\n * ```\n * @param input: 1-D. Strings to split.\n * @param delimiter: 0-D. Delimiter characters, or empty string.\n * @param skipEmpty: Optional. If true, skip the empty strings from the result.\n *     Defaults to true.\n * @return A map with the following properties:\n *     - indices: A dense matrix of int32 representing the indices of the sparse\n *       tensor.\n *     - values: A vector of strings corresponding to the splited values.\n *     - shape: a length-2 vector of int32 representing the shape of the sparse\n * tensor, where the first value is N and the second value is the maximum number\n * of tokens in a single input entry.\n *\n * @doc {heading: 'Operations', subheading: 'String'}\n */\nfunction stringSplit_(input, delimiter, skipEmpty = true) {\n    const $input = convertToTensor(input, 'input', 'stringSplit', 'string');\n    const $delimiter = convertToTensor(delimiter, 'delimiter', 'stringSplit', 'string');\n    if ($input.rank !== 1) {\n        throw new Error(`Input should be Tensor1D but received shape ${$input.shape}`);\n    }\n    if ($delimiter.rank !== 0) {\n        throw new Error(`Delimiter should be a scalar but received shape ${$delimiter.shape}`);\n    }\n    const attrs = { skipEmpty };\n    const inputs = { input: $input, delimiter: $delimiter };\n    const result = ENGINE.runKernel(StringSplit, inputs, attrs);\n    return { indices: result[0], values: result[1], shape: result[2] };\n}\nexport const stringSplit = /* @__PURE__ */ op({ stringSplit_ });\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RyaW5nX3NwbGl0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1jb3JlL3NyYy9vcHMvc3RyaW5nL3N0cmluZ19zcGxpdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sY0FBYyxDQUFDO0FBQ3BDLE9BQU8sRUFBQyxXQUFXLEVBQXNDLE1BQU0sb0JBQW9CLENBQUM7QUFHcEYsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBRXRELE9BQU8sRUFBQyxFQUFFLEVBQUMsTUFBTSxjQUFjLENBQUM7QUFFaEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0ErQkc7QUFDSCxTQUFTLFlBQVksQ0FDakIsS0FBMEIsRUFBRSxTQUE0QixFQUN4RCxTQUFTLEdBQUcsSUFBSTtJQUNsQixNQUFNLE1BQU0sR0FBRyxlQUFlLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxhQUFhLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDeEUsTUFBTSxVQUFVLEdBQ1osZUFBZSxDQUFDLFNBQVMsRUFBRSxXQUFXLEVBQUUsYUFBYSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBRXJFLElBQUksTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLEVBQUU7UUFDckIsTUFBTSxJQUFJLEtBQUssQ0FDWCwrQ0FBK0MsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7S0FDcEU7SUFDRCxJQUFJLFVBQVUsQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFFO1FBQ3pCLE1BQU0sSUFBSSxLQUFLLENBQ1gsbURBQW1ELFVBQVUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0tBQzVFO0lBRUQsTUFBTSxLQUFLLEdBQXFCLEVBQUMsU0FBUyxFQUFDLENBQUM7SUFDNUMsTUFBTSxNQUFNLEdBQXNCLEVBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFDLENBQUM7SUFDekUsTUFBTSxNQUFNLEdBQ1IsTUFBTSxDQUFDLFNBQVMsQ0FBQyxXQUFXLEVBQUUsTUFBWSxFQUFFLEtBQVcsQ0FBQyxDQUFDO0lBQzdELE9BQU8sRUFBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDO0FBQ25FLENBQUM7QUFFRCxNQUFNLENBQUMsTUFBTSxXQUFXLEdBQUcsZUFBZSxDQUFDLEVBQUUsQ0FBQyxFQUFDLFlBQVksRUFBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7RU5HSU5FfSBmcm9tICcuLi8uLi9lbmdpbmUnO1xuaW1wb3J0IHtTdHJpbmdTcGxpdCwgU3RyaW5nU3BsaXRBdHRycywgU3RyaW5nU3BsaXRJbnB1dHN9IGZyb20gJy4uLy4uL2tlcm5lbF9uYW1lcyc7XG5pbXBvcnQge1NjYWxhciwgVGVuc29yLCBUZW5zb3IxRH0gZnJvbSAnLi4vLi4vdGVuc29yJztcbmltcG9ydCB7TmFtZWRUZW5zb3JNYXB9IGZyb20gJy4uLy4uL3RlbnNvcl90eXBlcyc7XG5pbXBvcnQge2NvbnZlcnRUb1RlbnNvcn0gZnJvbSAnLi4vLi4vdGVuc29yX3V0aWxfZW52JztcbmltcG9ydCB7U2NhbGFyTGlrZSwgVGVuc29yTGlrZX0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHtvcH0gZnJvbSAnLi4vb3BlcmF0aW9uJztcblxuLyoqXG4gKiBTcGxpdCBlbGVtZW50cyBvZiBgaW5wdXRgIGJhc2VkIG9uIGBkZWxpbWl0ZXJgIGludG8gYSBTcGFyc2VUZW5zb3IgLlxuICpcbiAqIExldCBOIGJlIHRoZSBzaXplIG9mIHNvdXJjZSAodHlwaWNhbGx5IE4gd2lsbCBiZSB0aGUgYmF0Y2ggc2l6ZSkuIFNwbGl0IGVhY2hcbiAqIGVsZW1lbnQgb2YgYGlucHV0YCBiYXNlZCBvbiBgZGVsaW1pdGVyYCBhbmQgcmV0dXJuIGEgU3BhcnNlVGVuc29yIGNvbnRhaW5pbmdcbiAqIHRoZSBzcGxpdHRlZCB0b2tlbnMuIEVtcHR5IHRva2VucyBhcmUgaWdub3JlZCBpZiBgc2tpcEVtcHR5YCBpcyBzZXQgdG8gVHJ1ZS5cbiAqXG4gKiBgZGVsaW1pdGVyYCBjYW4gYmUgZW1wdHksIG9yIGEgc3RyaW5nIG9mIHNwbGl0IGNoYXJhY3RlcnMuIElmIGBkZWxpbWl0ZXJgIGlzXG4gKiBhbiBlbXB0eSBzdHJpbmcsIGVhY2ggZWxlbWVudCBvZiBgaW5wdXRgIGlzIHNwbGl0IGludG8gaW5kaXZpZHVhbFxuICogY2hhcmFjdGVyIHN0cmluZ3MuIE90aGVyd2lzZSBldmVyeSBjaGFyYWN0ZXIgb2YgYGRlbGltaXRlcmAgaXMgYSBwb3RlbnRpYWxcbiAqIHNwbGl0IHBvaW50LlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCByZXN1bHQgPSB0Zi5zdHJpbmcuc3RyaW5nU3BsaXQoWydoZWxsbyB3b3JsZCcsICAnYSBiIGMnXSwgJyAnKTtcbiAqIHJlc3VsdFsnaW5kaWNlcyddLnByaW50KCk7IC8vIFtbMCwgMF0sIFswLCAxXSwgWzEsIDBdLCBbMSwgMV0sIFsxLCAyXV1cbiAqIHJlc3VsdFsndmFsdWVzJ10ucHJpbnQoKTsgLy8gWydoZWxsbycsICd3b3JsZCcsICdhJywgJ2InLCAnYyddXG4gKiByZXN1bHRbJ3NoYXBlJ10ucHJpbnQoKTsgLy8gWzIsIDNdXG4gKiBgYGBcbiAqIEBwYXJhbSBpbnB1dDogMS1ELiBTdHJpbmdzIHRvIHNwbGl0LlxuICogQHBhcmFtIGRlbGltaXRlcjogMC1ELiBEZWxpbWl0ZXIgY2hhcmFjdGVycywgb3IgZW1wdHkgc3RyaW5nLlxuICogQHBhcmFtIHNraXBFbXB0eTogT3B0aW9uYWwuIElmIHRydWUsIHNraXAgdGhlIGVtcHR5IHN0cmluZ3MgZnJvbSB0aGUgcmVzdWx0LlxuICogICAgIERlZmF1bHRzIHRvIHRydWUuXG4gKiBAcmV0dXJuIEEgbWFwIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogICAgIC0gaW5kaWNlczogQSBkZW5zZSBtYXRyaXggb2YgaW50MzIgcmVwcmVzZW50aW5nIHRoZSBpbmRpY2VzIG9mIHRoZSBzcGFyc2VcbiAqICAgICAgIHRlbnNvci5cbiAqICAgICAtIHZhbHVlczogQSB2ZWN0b3Igb2Ygc3RyaW5ncyBjb3JyZXNwb25kaW5nIHRvIHRoZSBzcGxpdGVkIHZhbHVlcy5cbiAqICAgICAtIHNoYXBlOiBhIGxlbmd0aC0yIHZlY3RvciBvZiBpbnQzMiByZXByZXNlbnRpbmcgdGhlIHNoYXBlIG9mIHRoZSBzcGFyc2VcbiAqIHRlbnNvciwgd2hlcmUgdGhlIGZpcnN0IHZhbHVlIGlzIE4gYW5kIHRoZSBzZWNvbmQgdmFsdWUgaXMgdGhlIG1heGltdW0gbnVtYmVyXG4gKiBvZiB0b2tlbnMgaW4gYSBzaW5nbGUgaW5wdXQgZW50cnkuXG4gKlxuICogQGRvYyB7aGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnU3RyaW5nJ31cbiAqL1xuZnVuY3Rpb24gc3RyaW5nU3BsaXRfKFxuICAgIGlucHV0OiBUZW5zb3IxRHxUZW5zb3JMaWtlLCBkZWxpbWl0ZXI6IFNjYWxhcnxTY2FsYXJMaWtlLFxuICAgIHNraXBFbXB0eSA9IHRydWUpOiBOYW1lZFRlbnNvck1hcCB7XG4gIGNvbnN0ICRpbnB1dCA9IGNvbnZlcnRUb1RlbnNvcihpbnB1dCwgJ2lucHV0JywgJ3N0cmluZ1NwbGl0JywgJ3N0cmluZycpO1xuICBjb25zdCAkZGVsaW1pdGVyID1cbiAgICAgIGNvbnZlcnRUb1RlbnNvcihkZWxpbWl0ZXIsICdkZWxpbWl0ZXInLCAnc3RyaW5nU3BsaXQnLCAnc3RyaW5nJyk7XG5cbiAgaWYgKCRpbnB1dC5yYW5rICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW5wdXQgc2hvdWxkIGJlIFRlbnNvcjFEIGJ1dCByZWNlaXZlZCBzaGFwZSAkeyRpbnB1dC5zaGFwZX1gKTtcbiAgfVxuICBpZiAoJGRlbGltaXRlci5yYW5rICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRGVsaW1pdGVyIHNob3VsZCBiZSBhIHNjYWxhciBidXQgcmVjZWl2ZWQgc2hhcGUgJHskZGVsaW1pdGVyLnNoYXBlfWApO1xuICB9XG5cbiAgY29uc3QgYXR0cnM6IFN0cmluZ1NwbGl0QXR0cnMgPSB7c2tpcEVtcHR5fTtcbiAgY29uc3QgaW5wdXRzOiBTdHJpbmdTcGxpdElucHV0cyA9IHtpbnB1dDogJGlucHV0LCBkZWxpbWl0ZXI6ICRkZWxpbWl0ZXJ9O1xuICBjb25zdCByZXN1bHQ6IFRlbnNvcltdID1cbiAgICAgIEVOR0lORS5ydW5LZXJuZWwoU3RyaW5nU3BsaXQsIGlucHV0cyBhcyB7fSwgYXR0cnMgYXMge30pO1xuICByZXR1cm4ge2luZGljZXM6IHJlc3VsdFswXSwgdmFsdWVzOiByZXN1bHRbMV0sIHNoYXBlOiByZXN1bHRbMl19O1xufVxuXG5leHBvcnQgY29uc3Qgc3RyaW5nU3BsaXQgPSAvKiBAX19QVVJFX18gKi8gb3Aoe3N0cmluZ1NwbGl0X30pO1xuIl19","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../../engine';\nimport { StringToHashBucketFast } from '../../kernel_names';\nimport { convertToTensor } from '../../tensor_util_env';\nimport { op } from '../operation';\n/**\n * Converts each string in the input Tensor to its hash mod by a number of\n * buckets.\n *\n * The hash function is deterministic on the content of the string within the\n * process and will never change. However, it is not suitable for cryptography.\n * This function may be used when CPU time is scarce and inputs are trusted or\n * unimportant. There is a risk of adversaries constructing inputs that all hash\n * to the same bucket.\n *\n * ```js\n * const result = tf.string.stringToHashBucketFast(\n *   ['Hello', 'TensorFlow', '2.x'], 3);\n * result.print(); // [0, 2, 2]\n * ```\n * @param input: The strings to assign a hash bucket.\n * @param numBuckets: The number of buckets.\n * @return A Tensor of the same shape as the input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'String'}\n */\nfunction stringToHashBucketFast_(input, numBuckets) {\n    const $input = convertToTensor(input, 'input', 'stringToHashBucketFast', 'string');\n    const attrs = { numBuckets };\n    if (numBuckets <= 0) {\n        throw new Error(`Number of buckets must be at least 1`);\n    }\n    const inputs = { input: $input };\n    return ENGINE.runKernel(StringToHashBucketFast, inputs, attrs);\n}\nexport const stringToHashBucketFast = /* @__PURE__ */ op({ stringToHashBucketFast_ });\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RyaW5nX3RvX2hhc2hfYnVja2V0X2Zhc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWNvcmUvc3JjL29wcy9zdHJpbmcvc3RyaW5nX3RvX2hhc2hfYnVja2V0X2Zhc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLGNBQWMsQ0FBQztBQUNwQyxPQUFPLEVBQUMsc0JBQXNCLEVBQTRELE1BQU0sb0JBQW9CLENBQUM7QUFFckgsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBRXRELE9BQU8sRUFBQyxFQUFFLEVBQUMsTUFBTSxjQUFjLENBQUM7QUFFaEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBb0JHO0FBQ0gsU0FBUyx1QkFBdUIsQ0FDNUIsS0FBd0IsRUFBRSxVQUFrQjtJQUM5QyxNQUFNLE1BQU0sR0FDUixlQUFlLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUN4RSxNQUFNLEtBQUssR0FBZ0MsRUFBQyxVQUFVLEVBQUMsQ0FBQztJQUV4RCxJQUFJLFVBQVUsSUFBSSxDQUFDLEVBQUU7UUFDbkIsTUFBTSxJQUFJLEtBQUssQ0FBQyxzQ0FBc0MsQ0FBQyxDQUFDO0tBQ3pEO0lBRUQsTUFBTSxNQUFNLEdBQWlDLEVBQUMsS0FBSyxFQUFFLE1BQU0sRUFBQyxDQUFDO0lBQzdELE9BQU8sTUFBTSxDQUFDLFNBQVMsQ0FBQyxzQkFBc0IsRUFBRSxNQUFZLEVBQUUsS0FBVyxDQUFDLENBQUM7QUFDN0UsQ0FBQztBQUVELE1BQU0sQ0FBQyxNQUFNLHNCQUFzQixHQUFHLGVBQWUsQ0FBQyxFQUFFLENBQUMsRUFBQyx1QkFBdUIsRUFBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7RU5HSU5FfSBmcm9tICcuLi8uLi9lbmdpbmUnO1xuaW1wb3J0IHtTdHJpbmdUb0hhc2hCdWNrZXRGYXN0LCBTdHJpbmdUb0hhc2hCdWNrZXRGYXN0QXR0cnMsIFN0cmluZ1RvSGFzaEJ1Y2tldEZhc3RJbnB1dHN9IGZyb20gJy4uLy4uL2tlcm5lbF9uYW1lcyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vdGVuc29yJztcbmltcG9ydCB7Y29udmVydFRvVGVuc29yfSBmcm9tICcuLi8uLi90ZW5zb3JfdXRpbF9lbnYnO1xuaW1wb3J0IHtUZW5zb3JMaWtlfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQge29wfSBmcm9tICcuLi9vcGVyYXRpb24nO1xuXG4vKipcbiAqIENvbnZlcnRzIGVhY2ggc3RyaW5nIGluIHRoZSBpbnB1dCBUZW5zb3IgdG8gaXRzIGhhc2ggbW9kIGJ5IGEgbnVtYmVyIG9mXG4gKiBidWNrZXRzLlxuICpcbiAqIFRoZSBoYXNoIGZ1bmN0aW9uIGlzIGRldGVybWluaXN0aWMgb24gdGhlIGNvbnRlbnQgb2YgdGhlIHN0cmluZyB3aXRoaW4gdGhlXG4gKiBwcm9jZXNzIGFuZCB3aWxsIG5ldmVyIGNoYW5nZS4gSG93ZXZlciwgaXQgaXMgbm90IHN1aXRhYmxlIGZvciBjcnlwdG9ncmFwaHkuXG4gKiBUaGlzIGZ1bmN0aW9uIG1heSBiZSB1c2VkIHdoZW4gQ1BVIHRpbWUgaXMgc2NhcmNlIGFuZCBpbnB1dHMgYXJlIHRydXN0ZWQgb3JcbiAqIHVuaW1wb3J0YW50LiBUaGVyZSBpcyBhIHJpc2sgb2YgYWR2ZXJzYXJpZXMgY29uc3RydWN0aW5nIGlucHV0cyB0aGF0IGFsbCBoYXNoXG4gKiB0byB0aGUgc2FtZSBidWNrZXQuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHJlc3VsdCA9IHRmLnN0cmluZy5zdHJpbmdUb0hhc2hCdWNrZXRGYXN0KFxuICogICBbJ0hlbGxvJywgJ1RlbnNvckZsb3cnLCAnMi54J10sIDMpO1xuICogcmVzdWx0LnByaW50KCk7IC8vIFswLCAyLCAyXVxuICogYGBgXG4gKiBAcGFyYW0gaW5wdXQ6IFRoZSBzdHJpbmdzIHRvIGFzc2lnbiBhIGhhc2ggYnVja2V0LlxuICogQHBhcmFtIG51bUJ1Y2tldHM6IFRoZSBudW1iZXIgb2YgYnVja2V0cy5cbiAqIEByZXR1cm4gQSBUZW5zb3Igb2YgdGhlIHNhbWUgc2hhcGUgYXMgdGhlIGlucHV0IHRlbnNvci5cbiAqXG4gKiBAZG9jIHtoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdTdHJpbmcnfVxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0hhc2hCdWNrZXRGYXN0XyhcbiAgICBpbnB1dDogVGVuc29yfFRlbnNvckxpa2UsIG51bUJ1Y2tldHM6IG51bWJlcik6IFRlbnNvciB7XG4gIGNvbnN0ICRpbnB1dCA9XG4gICAgICBjb252ZXJ0VG9UZW5zb3IoaW5wdXQsICdpbnB1dCcsICdzdHJpbmdUb0hhc2hCdWNrZXRGYXN0JywgJ3N0cmluZycpO1xuICBjb25zdCBhdHRyczogU3RyaW5nVG9IYXNoQnVja2V0RmFzdEF0dHJzID0ge251bUJ1Y2tldHN9O1xuXG4gIGlmIChudW1CdWNrZXRzIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE51bWJlciBvZiBidWNrZXRzIG11c3QgYmUgYXQgbGVhc3QgMWApO1xuICB9XG5cbiAgY29uc3QgaW5wdXRzOiBTdHJpbmdUb0hhc2hCdWNrZXRGYXN0SW5wdXRzID0ge2lucHV0OiAkaW5wdXR9O1xuICByZXR1cm4gRU5HSU5FLnJ1bktlcm5lbChTdHJpbmdUb0hhc2hCdWNrZXRGYXN0LCBpbnB1dHMgYXMge30sIGF0dHJzIGFzIHt9KTtcbn1cblxuZXhwb3J0IGNvbnN0IHN0cmluZ1RvSGFzaEJ1Y2tldEZhc3QgPSAvKiBAX19QVVJFX18gKi8gb3Aoe3N0cmluZ1RvSGFzaEJ1Y2tldEZhc3RffSk7XG4iXX0="],"names":["staticRegexReplace_","input","pattern","rewrite","replaceGlobal","$input","attrs","runKernel","x","staticRegexReplace","op","stringNGrams_","data","dataSplits","separator","nGramWidths","leftPad","rightPad","padWidth","preserveShortSequences","$data","dtype","Error","shape","length","$dataSplits","inputs","result","nGrams","nGramsSplits","stringNGrams","stringSplit_","delimiter","skipEmpty","$delimiter","rank","indices","values","stringSplit","stringToHashBucketFast_","numBuckets","stringToHashBucketFast"],"sourceRoot":""}